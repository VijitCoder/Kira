# Использование конфигурации приложения

Класс `\kira\core\App`

Конфигурация грузится при первой попытке чтения/записи в ней, загрузка один раз на время работы приложения. Даже если вы в приложении ничего не читаете, движку все равно нужны некоторые обязательные параметры, см. док *"Конфигурация приложения"*. Так что обращение к конфигу происходит почти при любой работе приложения.

### Чтение значения

Статичный метод

```PHP
App::conf(string $key, bool $strict = true): mixed
```

Ключ конфига указываем в первом параметре. Через точку можно указать вложенные конфиги, например `App::conf('db.options')`. Функция вернет значение по конечному ключу, в данном примере - массив PDO-параметров. В чем выгода указывать конечные ключи? Функция проверяет всю цепочку настроек на существование, не придется делать это в клиентском коде.

Очевидно, что использовать точку в именах ключей конфига нельзя, функция расценит ее, как разделитель и попытается найти вложенный массив по заданному имени.

Второй параметр, `$strict`, управляет реакцией на отстутствие настройки. Если он равен `true`, будет проброшено исключение `kira\exceptions\ConfigException`. Если отсутствие настройки некритично для приложения, тогда вторым параметром передаем `false` и функция вернет `NULL`.

### Запись значения

Статичный метод

```PHP
App::changeConf(string $key, mixed $value)
```

Ключ может быть составным, через точку (по аналогии с чтением конфига). Новое значение **перезаписывает** текущее.

Этим методом можно поменять значение в конфиге приложения, но только если ключ уже существует. Такое ограничение введено для предотвращения попытки сохранить в конфиге произвольное глобальное значение. Для этого есть Реестр (`\kira\utils\Registry`).

### Пример

Конфигурация

```php
...
'db' => [
    'dsn'      => 'mysql:host=127.0.0.1; dbname=some_base; charset=utf8',
    'user'     => 'user1',
    'password' => 'secret',
    'options' => [
        PDO::ATTR_TIMEOUT => 10,
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
    ],
],
...
```

Читаем значение из вложенного массива конфигурации, перезаписываем его и снова читаем. Просто для демонстрации возможностей:

```php
    $key = 'db.options.' . PDO::ATTR_TIMEOUT;
    $timeout = App::conf($key);             // значение - 10
    App::changeConf($key, $timeout * 2);    // удваиваем таймаут соединения с БД
    $timeout = App::conf($key);             // теперь значение - 20
```

## Проблема циклического чтения конфигурации

Проблема возникает, когда загружаемая конфигурация опирается сама на себя. Например, в роутах прописан некий URL, и этот же адрес *через роутер движка* пытаемся получить для какого-то значения конфигурации.

```php
'router' => [
    '404_handler'   => HttpErrorController::class,
    'log_redirects' => true,
    'routes'        => [
        'app\controllers' => [
            'csp-report' => 'CSPReportController',      // Этот роут нас интересует
            ...
            '<controller:[a-z]+>'                 => '<controller>',
            '<controller:[a-z]+>/<action:[a-z]+>' => '<controller>/<action>',
        ],
    ],
],

...

// Content Security Policy
'CSP' => [
    'report-uri' => App::router()->url(['app\controllers', 'CSPReportController']),
    'default-src' => "'self' 'unsafe-inline'",
]
```

Что произойдет: при первом обращении к конфигурации начнется ее загрузка в память. Когда дело дойдет до `CSP.report-uri`, движок спросит у роутера URL. Роутер полезет за картой в конфигурацию. А она еще не загрузилась, она же сейчас на `report-uri` стоит. Движок увидит, что конфиг еще не загружен, попытается это сделать.. и так по кругу, пока препроцессор не прервет этот бесконечный цикл.

Выход первый: не использовать движок в конфигурации. Учитывая, что он сам на нее опирается, логично дать ему возможность сначала загрузить конфу, а уже потом что-то требовать.

Другой вариант: загрузка конфигурации по частям. Все уже реализовано в движке, со стороны "пользователя" нужно только разделить **главные файлы** конфигурации.

Что есть главный файл. В примере выше весь конфиг в одном файле. В реальных приложениях получается "простынка", поэтому обычно заводят главный файл конфигурации, а в него уже подключают блоки конфигурации через `require` или слиянием (оба действия можно увидеть в доке *"конфигурация приложения"*).

Допустим, главный конфиг называется `main.php`. Создаем зависимый от него конфиг с именем `main2.php` и переносим в него настройку CSP из примера выше. Теперь цикличности не будет. Требования: имена зависимых конфигов должны отличаться от главного только числом в конце, без разделителей. Число любое, порядок загрузки определяется этим значением.

Как это работает: движок грузит главный конфиг `main.php` и все, что в него подключается. Отмечает у себя, что эта часть загружена. Потом переходит к загрузке следующей части - `main2.php`, там обнаруживается необходимость уже как-то использовать конфигурацию. Тогда движок использует то, что успел загрузить.

Нет никаких жестких требований, что где размещать, главное - зависимые части должны идти после обеспечивающих. Если частей будет, например, три, и последняя зависит от первой - так будет работать. Если вторая зависит от последней - не будет работать.

Главные части сливаются через `kira\utils\Arrays::merge_recursive()`, т.е. при совпадении ключей в конфиге окажутся самые последние значения.

Технически частичная загрузка конфигов реализована в классе `\kira\internal\ConfigurationManager`. Класс находится во внутренней части движка и не предполагает его использование напрямую. Тем не менее, там есть статичный метод `enumerateMains()`, который можно вызвать в целях отладки. Он возвращает список найденных главных конфигов в том порядке, как они будут загружены в приложении.
