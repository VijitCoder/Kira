# Утилиты

### Arrays 

Работа с массивами. В это трудно поверить, но при всем богатстве php-методов все еще есть, что свое написать :)

---

Оборачиваем массив любой вложенности в класс *ArrayObject* для доступа к элементам, как свойствам класса.

_static function_ __arrObject(array $data)__: _ArrayObject_

_param_ **array $data** исходный массив

Одно ограничение: не принимаются массивы со смешанными ключами. Каждый вложенный массив либо полностью ассоциативный, либо полностью неассоциативный. Числовые ключи, обернутые в строки, распознаются и массив приравнивается к неассоциативному.

---

Фильтрация массива по ключам через функцию обратного вызова. Используется в PHP < 5.6

_static function_ __filter_keys(callable $callback, array $arr)__: _array_

_param_ **callable $callback** 
функция обратного вызвова. Имеет один параметр, в который передается ключ текущего элемента. Возвращает `true`, если ключ подходит, иначе `false`.

_param_ **array $arr** целевой массив для фильтрации

Функция делает тоже самое, что и [php::array_filter()](http://php.net/manual/ru/function.array-filter.php) в сочетании с константой ARRAY_FILTER_USE_KEY.

---

Рекурсивное объединение **двух** массивов.

_static function_ __merge_recursive(array &$array1, array &$array2)__: _array_

Это объединение массивов, как описано в [справке](http://php.net/manual/ru/function.array-merge-recursive.php), а не как на самом деле работает `php::array_merge_recursive()`.

Логика объединения:

- значения с числовыми ключами всегда добавляются в конец, независимо от самих значений.
- строковые ключи перезаписываются. Если у обоих массивов значения окажутся подмассивами, тогда они объединяются  в рекурсивном вызове этой функции.

Схематично (для строковых ключей):
value1 + array2 = array2
array1 + value2 = value2
array1 + array2 > recurse call

Замечание: функция написана на основе [комментария](http://php.net/manual/ru/function.array-merge-recursive.php#92195) к той же справке. Но там другое объединение, числовые ключи заменяются так же, как и строковые.

### Dumper

Дамп переменной. Взял в Yii 1.x и слегка переделал по своему усмотрению. Все публичные методы этой утилиты работают аналогично [php::var_dump()](http://php.net/manual/ru/function.var-dump.php) и [php::print_r()](http://php.net/manual/ru/function.print-r.php), но возвращают информацию в более приглядном виде.

---

Вывод дампа переменной в *stdout*. Второй метод - дамп с выходом из приложения.

_static function_ __dump($var, $depth = 10, $highlight = true)__: _void_
_static function_ __dumpEx($var, $depth = 10, $highlight = true)__: _void_

---

Дамп переменной в строку.

_static function_ __dumpAsString($var, $depth = 10, $highlight = true)__: _string_


### Env

Среда окружения сайта. Я решил объединить методы по теме "среды окружения" с функционалом определения сервера, на котором запущен сайт. Возможно зря это сделал, класс получился слегка запутанным. 

---

Имя домена. Типа *"my.site.com"*

_static function_ __domain()__: _string|null_

Пытаемся его получить из переменной $_SERVER. В крайнем случае ищем в настройках приложения *'domain'*, если таковая имеется.

---

Домен + схема. С конечным слешем. 
_static function_ __domainWithScheme__: _string|null_

Схема не всегда может быть определена, это зависит от настроек сервера. Если не получилось ее выяснить, считаем 'http'.

---

Главная страница сайта
_static function_ __indexPage__: _string|null_

Сейчас это просто синоним функции `domainWithScheme()`, введен для удобства понимания кода. Возможно в приложении потребуется переопределение метода.

---

Геттеры "Сервер, на котором запущен сайт"
_static function_ __isLocal()__: _bool_
_static function_ __isDevelopment()__: _bool_
_static function_ __isStage()__: _bool_
_static function_ __isProduction()__: _bool_
_static function_ __isMobile()__: _bool_

В коде получились сложные манипуляции с интерфейсами и наследованием, поясню тут проще: если планируете использовать указанные методы, тогда необходимо сделать свою реализацию метода ***detectEnvironment()*** в конкретном приложении. Лучшее решение: переопределить метод в классе-наследнике. 

Возможные способы определения окружения *(local, dev, stage, production, mobile)*: анализ заголовков, переменных среды ОС, спец.файлы где-нибудь, проверка ip, схемы, домена, доп.конфиг. Что угодно, в зависимости от реального окружения.

### Request

@TODO описание

---

Проверяем, что запрос пришел с мобильного браузера.

static function __isMobileBrowser()__: _bool_

Это не то же самое, что "мобильная версия сайта" (см. `Env::isMobile()`). Данный метод можно использовать для отзывчивой (responsive) верстки. Например, подключать какие-то особые js-скрипты.

### Session

@TODO описание

### Strings

Функции работы со строками.

---

Склонение слов в зависимости от числа.

_static function_ __declination($n, array $s, $glued = true)__: _string_

_param_ **int   $n**     число
_param_ **array $s**     набор слов
_param_ **bool  $glued** объединить результат с числом? Объединение будет через пробел

Замечание: функция не использует возможности движка по локализации. Для этого потребуется отдельный вызов переводчика ***core\App::t()***

Пример передаваемых данных в массиве $s = \['комментарий', 'комментария', 'комментариев'\]:
1 комментарий
2 комментария
5 комментариев

---

Транслит с русского на английский и обратно

__static function__ _rus2eng($str)_: _string_
__static function__ _eng2rus($str)_: _string_

Замечание: транслит с английского сделан только для **однобуквенных** (в русском эквиваленте) строк. Больше нигде не требовалось и не тестировалось.

---

Заглавная/строчная первая буква. Мультибайтная версия. В PHP <=5.9 нет подобной реализации.

__static function__ _mb_ucfirst($str)_: _string_
__static function__ _mb_lcfirst($str)_: _string_
