# Утилиты

### Arrays 

Работа с массивами. В это трудно поверить, но при всем богатстве php-методов все еще есть, что свое написать :)

---

Оборачиваем массив любой вложенности в класс *ArrayObject* для доступа к элементам, как свойствам класса.

_static function_ __arrObject(array $data)__: _ArrayObject_

_param_ **array $data** исходный массив

Одно ограничение: не принимаются массивы со смешанными ключами. Каждый вложенный массив либо полностью ассоциативный, либо полностью неассоциативный. Числовые ключи, обернутые в строки, распознаются и массив приравнивается к неассоциативному.

---

Фильтрация массива по ключам через функцию обратного вызова. Используется в PHP < 5.6

_static function_ __filter_keys(callable $callback, array $arr)__: _array_

_param_ **callable $callback** 
функция обратного вызвова. Имеет один параметр, в который передается ключ текущего элемента. Возвращает `true`, если ключ подходит, иначе `false`.

_param_ **array $arr** целевой массив для фильтрации

Функция делает тоже самое, что и [php::array_filter()](http://php.net/manual/ru/function.array-filter.php) в сочетании с константой ARRAY_FILTER_USE_KEY.

---

Рекурсивное объединение **двух** массивов.

_static function_ __merge_recursive(array &$array1, array &$array2)__: _array_

Это объединение массивов, как описано в [справке](http://php.net/manual/ru/function.array-merge-recursive.php), а не как на самом деле работает `php::array_merge_recursive()`.

Логика объединения:

- значения с числовыми ключами всегда добавляются в конец, независимо от самих значений.
- строковые ключи перезаписываются. Если у обоих массивов значения окажутся подмассивами, тогда они объединяются  в рекурсивном вызове этой функции.

Схематично (для строковых ключей):
value1 + array2 = array2
array1 + value2 = value2
array1 + array2 > recurse call

Замечание: функция написана на основе [комментария](http://php.net/manual/ru/function.array-merge-recursive.php#92195) к той же справке. Но там другое объединение, числовые ключи заменяются так же, как и строковые.

### Dumper

Дамп переменной. Взял в Yii 1.x и слегка переделал по своему усмотрению. Все публичные методы этой утилиты работают аналогично [php::var_dump()](http://php.net/manual/ru/function.var-dump.php) и [php::print_r()](http://php.net/manual/ru/function.print-r.php), но возвращают информацию в более приглядном виде.

---

Вывод дампа переменной в *stdout*. Второй метод - дамп с выходом из приложения.

_static function_ __dump($var, $depth = 10, $highlight = true)__: _void_
_static function_ __dumpEx($var, $depth = 10, $highlight = true)__: _void_

---

Дамп переменной в строку.

_static function_ __dumpAsString($var, $depth = 10, $highlight = true)__: _string_


### EnvDetect

Определение окружения *(local, dev, stage, production, mobile)*. Любым возможным способом: анализ заголовков, переменных среды ОС, спец.файлы где-нибудь, проверка ip, схемы, домена, доп.конфиг. Что угодно, в зависимости от реального окружения.

**Важно!** Данная утилита требует реализации абстрактного метода ***detectEnvironment()*** в конкретном приложении.

В наличии следущие публичные методы:
_static function_ __isLocal()__: _bool_
_static function_ __isDevelopment()__: _bool_
_static function_ __isStage()__: _bool_
_static function_ __isProduction()__: _bool_
_static function_ __isMobile()__: _bool_

### Session

@TODO описание

### Strings

Функции работы со строками.

---

Склонение слов в зависимости от числа.

_static function_ __declination($n, array $s, $glued = true)__: _string_

_param_ **int   $n**     число
_param_ **array $s**     набор слов
_param_ **bool  $glued** объединить результат с числом? Объединение будет через пробел

Замечание: функция не использует возможности движка по локализации. Для этого потребуется отдельный вызов переводчика ***core\App::t()***

Пример передаваемых данных в массиве $s = \['комментарий', 'комментария', 'комментариев'\]:
1 комментарий
2 комментария
5 комментариев

---

Транслит с русского на английский и обратно

__static function__ _rus2eng($str)_: _string_
__static function__ _eng2rus($str)_: _string_

Замечание: транслит с английского сделан только для **однобуквенных** (в русском эквиваленте) строк. Больше нигде не требовалось и не тестировалось.

---

Заглавная/строчная первая буква. Мультибайтная версия. В PHP <=5.9 нет подобной реализации.

__static function__ _mb_ucfirst($str)_: _string_
__static function__ _mb_lcfirst($str)_: _string_

### VarRequest

@TODO описание

### VarServer

@TODO описание
