# Утилиты. FS

Класс `\kira\utils\FS`

Файловая система. В основном это обертки PHP-функций, но с перехватом ошибок. Если что-то пойдет не так, функции этого класса возвращают сообщение об ошибке, а не роняют код с E_ERROR. Особого внимания заслуживают функции работы с каталогами.

---

function __normalizePath($path, $isFile = false)__: _string_
function __isWindowsRootedPath($path)__: _bool_

Первая функция приводит любую запись пути каталогов к одному виду: все слеши заменяются на прямые (как принято в Linux), нет слеша в начале, есть слеш в конце, если переданный путь не ведет к файлу.

Удаление ведущего слеша порождает проблему: когда нужно получить абсолютный путь, приходится его дописывать. Но тогда нарушится кросс-платформенность приложения, потому что абсолютные пути в стиле Windows не содержат ведущий слеш. Поэтому придумана вторая функция, для определения, на какой каталог похожа проверяемая строка.

Зачем такие заморочки, можно бы просто при нормализации не изменять наличие ведущего слеша? Тогда нет уверенности, что нормализованный каталог будет именно таким, как ожидается. И поэтому приходится в клиентском коде втыкать удаление этого слеша для получения гарантированно однозначного результата. Практика показала, что текущее решение - удобнее.

**Важно** Очень рекомендую использовать `isWindowsRootedPath()` в своем коде, если вы строите абсолютный путь. Сам наступил на эти грабли :( Код спозиционировал только под Linux, пишу unit-тест, где файловую систему имитирует `vfsStream`. И не работает мой тест.. А все из-за ведущего слеша, который я явно дописал.

Вот пример построения стабильного *кроссплатформенного абсолютного* пути:

```php
$path = FS::normalizePath($path));
if (!FS::isWindowsRootedPath($path)) {
    $path = '/' . $path;
}

// Теперь $path точно заканчивается слешем. Если путь не windows-rooted, тогда в начале тоже слеш. Иначе без ведущего слеша.
```

Конечно, если полагаетесь на свои силы и 100% уверены, в каком виде у вас указан путь и/или приложение всегда будет крутиться только на Linux (или Windows), тогда эти преобразования вам не к чему.

---

Создание каталога:

function __makeDir($path, $mode = 0777)__: _true|string_

Как работает: выясняем, сколько каталогов по пути нужно будет создать. Создаем все разом через `php::mkdir()`. Каждому новому каталогу с конца назначаем требуемые права. Почему с конца: если запрещено исполнение, то в каталог нельзя будет попасть после установки прав.

Не используем для вычисления родителя функцию `php::dirname()`, она привносит свои заморочки.

**Какая польза от этого метода**

По умолчанию, линуксовые команды из PHP скрипта выполняются от имени юзера, запускающего скрипт. Т.е. когда скрипт запускает сервер Apache, юзером числится *www-data*.

При создании каталогов с назначением прав через [php::mkdir()](http://php.net/manual/ru/function.mkdir.php) учитывается так же текущее значение `umask`. Об этом можно почитать в [Википедии](https://ru.wikipedia.org/wiki/Umask) и в мануале PHP по соответствующим функциям. Коротко: что указано в umask, то будет запрещено в правах к каталогу. На практике обычно получаем такие права к каталогу: 755. Это значит, что кроме создателя остальным можно только читать из него.

Сообсно, в чем суть проблемы: во время разработки сайта с такими каталогами неудобно работать, прав не хватает. Даже если создать каталог с полным доступом всем, получим грабли при создании вложенных каталогов!

Пример. Допустим, есть временный каталог приложения [/www/site/temp/]. В нем для импорта нужно создать такую иерархию [/www/site/temp/import/XXX/], где XXX - это timestamp на момент создания. Код с использованием нативных php-функций будет таким:

```php
$path = '/www/site/temp/import/' . time();
mkdir($path);
chmod($path, 0777);
```

В итоге получим права:

```sh
user@comp:/www/site/temp$ ls -l
drwxr-xr-x 3 www-data www-data   4096 Jun  3 14:10 import

user@comp:/www/site/temp/import$ ls -l
drwxrwxrwx 2 www-data www-data 4096 Jun  3 14:12 1464937950
```

В чем проблема? Нельзя удалить каталог из [import/], т.к. прав недостаточно. Зато свободно можно работать в его подкаталоге. Вообщем, мне это неудобно. Функция

```php
function makeDir($path, $mode): bool|string
```

создает все каталоги до заданного и задает всем новым каталогам указанные права.

Кроме прочего, она перехватывает ошибки от PHP функций `mkdir()` и `chmod()` и возвращает их строкой. Без перехвата был бы `E_WARNING`.

---

function __removeDir($path, $fuseLevel = 1)__: _true|string_

Удаление каталога с подкаталогами и файлами.

`$fuseLevel` - максимальный уровень вложенности каталогов используется как предохранитель (чтобы себе в ногу не выстрелить): сначала выясняем, превышает ли заданный уровень реальная вложенность, и возвращаем ошибку, если так. Только потом удаляем, через рекурсию вспомогательной функции.

Сделал суровые условия: удалить можно от 1 до 4 уровней каталогов. Это очень опасная функция, нужно вообще избегать ее использования.

---

function __clearDir($path, $filter = '')__: _true|string_

Очистка каталога от файлов.

Не работает с подкаталогами из соображений безопасности, очистка проводится только в текущем каталоге. Удаляем все файлы или подходящие под заданный фильтр (регулярное выражение). Символические ссылки тоже удаляются, оригиналы файлов при этом не будут затронуты.

*Прим.: для очистки процессу нужен доступ на запись в целевой каталог. Доступ к файлам может вообще отсутствовать.*

---

function __pathInfo(string $source)__: _\\kira\\utils\\FilePathInfo_

Парсинг файлового пути.

Аналог [php::pathinfo()](http://php.net/manual/en/function.phpinfo.php) и [php::SplFileInfo](http://php.net/manual/en/class.splfileinfo.php), но более адекватный.

Ограничение: любые слеши расцениваются, как разделители каталогов.

Улучшения:

- кроссплатформа: корректно распознаются пути с прямыми и обратными слешами;
- только если путь заканчивается на слеш, он определяется как каталог, иначе - это файл;
- каталоги парсятся правильно, не появляются там "файлы" из последней части пути, чем страдают обе нативные функции PHP;
- если в имени файла первый символ - точка, это все еще имя файла, а не *"файл без имени, только расширение"*;
- распарсенный каталог всегда заканчивается на слеш (обратный слеш).

Функция возвращает DTO-объект `\kira\utils\FilePathInfo`, что куда удобнее, чем ассоциативный массив, ключи которого без манула не вспомнить :) Свойства объекта прокомментированы. К тому же, вы всегда получаете доступ ко всем частям распарсенного пути, не перегружая при этом клиентский код, не нужно мудрить с константами `php::PATHINFO_*`.

Я не стал копировать все методы из `php::SplFileInfo`, потому что по моему мнению там много лишнего: если мне нужно распарсить путь к файлу, вряд ли я хочу *тут же* знать, какие у него права или владелец. Скорее всего я буду делать что-то с частями его пути и/или имени. Если же мне нужно знать его права и т.п., для этого есть отдельные функции. Поэтому мой класс `FilePathInfo` содержит только два вспомогательных метода - `isDir()` и `isFile()`.
