# Утилиты. FS

Класс `\kira\utils\FS`

Файловая система. В основном это обертки PHP-функций, но с перехватом ошибок. Если что-то пойдет не так, функции этого класса возвращают сообщение об ошибке, а не роняют код с E_ERROR. Особого внимания заслуживают функции работы с каталогами.

---

function __normalizePath($path, $isFile = false)__: _string_
function __isWindowsRootedPath($path)__: _bool_

Первая функция приводит любую запись пути каталогов к одному виду: все слеши заменяются на прямые (как принято в Linux), нет слеша в начале, есть слеш в конце, если переданный путь не ведет к файлу.

Удаление ведущего слеша порождает проблему: когда нужно получить абсолютный путь, приходится его дописывать. Но тогда нарушится кросс-платформенность приложения, потому что абсолютные пути в стиле Windows не содержат ведущий слеш. Поэтому придумана вторая функция, для определения, на какой каталог похожа проверяемая строка.

Зачем такие заморочки, можно бы просто при нормализации не изменять наличие ведущего слеша? Тогда нет уверенности, что нормализованный каталог будет именно таким, как ожидается. И поэтому приходится в клиентском коде втыкать удаление этого слеша для получения гарантированно однозначного результата. Практика показала, что текущее решение - удобнее.

**Важно** Очень рекомендую использовать `isWindowsRootedPath()` в своем коде, если вы строите абсолютный путь. Сам наступил на эти грабли :( Код спозиционировал только под Linux, пишу unit-тест, где файловую систему имитирует `vfsStream`. И не работает мой тест.. А все из-за ведущего слеша, который я явно дописал.

Вот пример построения стабильного *кроссплатформенного абсолютного* пути:

```php
$path = FS::normalizePath($path));
if (!FS::isWindowsRootedPath($path)) {
    $path = '/' . $path;
}

// Теперь $path точно заканчивается слешем. Если путь не windows-rooted, тогда в начале тоже слеш. Иначе без ведущего слеша.
```

Конечно, если полагаетесь на свои силы и 100% уверены, в каком виде у вас указан путь и/или приложение всегда будет крутиться только на Linux (или Windows), тогда эти преобразования вам не к чему.

---

Создание каталога:

function __makeDir($path, $mode = 0777)__: _true|string_

Как работает: выясняем, сколько каталогов по пути нужно будет создать. Создаем все разом через `php::mkdir()`. Каждому новому каталогу с конца назначаем требуемые права. Почему с конца: если запрещено исполнение, то в каталог нельзя будет попасть после установки прав.

Не используем для вычисления родителя функцию `php::dirname()`, она привносит свои заморочки.

**Какая польза от этого метода**

По умолчанию, линуксовые команды из PHP скрипта выполняются от имени юзера, запускающего скрипт. Т.е. когда скрипт запускает сервер Apache, юзером числится *www-data*.

При создании каталогов с назначением прав через [php::mkdir()](http://php.net/manual/ru/function.mkdir.php) учитывается так же текущее значение `umask`. Об этом можно почитать в [Википедии](https://ru.wikipedia.org/wiki/Umask) и в мануале PHP по соответствующим функциям. Коротко: что указано в umask, то будет запрещено в правах к каталогу. На практике обычно получаем такие права к каталогу: 755. Это значит, что кроме создателя остальным можно только читать из него.

Сообсно, в чем суть проблемы: во время разработки сайта с такими каталогами неудобно работать, прав не хватает. Даже если создать каталог с полным доступом всем, получим грабли при создании вложенных каталогов!

Пример. Допустим, есть временный каталог приложения [/www/site/temp/]. В нем для импорта нужно создать такую иерархию [/www/site/temp/import/XXX/], где XXX - это timestamp на момент создания. Код с использованием нативных php-функций будет таким:

```php
$path = '/www/site/temp/import/' . time();
mkdir($path);
chmod($path, 0777);
```

В итоге получим права:

```sh
user@comp:/www/site/temp$ ls -l
drwxr-xr-x 3 www-data www-data   4096 Jun  3 14:10 import

user@comp:/www/site/temp/import$ ls -l
drwxrwxrwx 2 www-data www-data 4096 Jun  3 14:12 1464937950
```

В чем проблема? Нельзя удалить каталог из [import/], т.к. прав недостаточно. Зато свободно можно работать в его подкаталоге. Вообщем, мне это неудобно. Функция

```php
function makeDir($path, $mode): bool|string
```

создает все каталоги до заданного и задает всем новым каталогам указанные права.

Кроме прочего, она перехватывает ошибки от PHP функций `mkdir()` и `chmod()` и возвращает их строкой. Без перехвата был бы `E_WARNING`.

---

function __removeDir($path, $fuseLevel = 1)__: _true|string_

Удаление каталога с подкаталогами и файлами.

`$fuseLevel` - максимальный уровень вложенности каталогов используется как предохранитель (чтобы себе в ногу не выстрелить): сначала выясняем, превышает ли заданный уровень реальная вложенность, и возвращаем ошибку, если так. Только потом удаляем, через рекурсию вспомогательной функции.

Сделал суровые условия: удалить можно от 1 до 4 уровней каталогов. Это очень опасная функция, нужно вообще избегать ее использования.

---

function __clearDir($path, $filter = '')__: _true|string_

Очистка каталога от файлов.

Не работает с подкаталогами из соображений безопасности, очистка проводится только в текущем каталоге. Удаляем все файлы или подходящие под заданный фильтр (регулярное выражение). Символические ссылки тоже удаляются, оригиналы файлов при этом не будут затронуты.

*Прим.: для очистки процессу нужен доступ на запись в целевой каталог. Доступ к файлам может вообще отсутствовать.*
