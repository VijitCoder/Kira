# Data Transfer Object (DTO)

Класс `\kira\core\DTO`

Исключение `\kira\exceptions\DtoException`

*DTO - Data Transfer Object*. Это универсальный паттерн, который используется с одной целью: передача данных. Если нам надо собрать данные из нескольких разных сущностей и передать эти данные в какой-либо сервис или в представление (view), то мы упаковываем эти данные в DTO. При этом DTO может не содержать сущности целиком, а только необходимые данные. Одно в принципе может не соответствовать какой-либо сущности.

[Ликбез о DTO](https://ru.wikipedia.org/wiki/DTO)

Общий подход: создаем наследника от этого класса, описываем в нем публичные свойства, каждому назначаем комментарий и тип. Пользуемся :) Тривиальный пример:

```
namespace App\DTO;

use kira\core\Dto;

class UserDto extends Dto
{
    /**
     * id пользователя
     * @var int
     */
     public $id;

    /**
     * Логин пользователя
     * @var string
     */
     public $login;
     ...
}
```

Далее, где-то в коде:

```
$user = new UserDto([
    'id' => 4,
    'login' => 'Pupkin',
]);

echo $user->id . ' ' . $user->login;
```

*Это совсем фиговый пример, не раскрывающий потенциал DTO. В движке есть пока только один рабочий пример - DTO результата запроса с пагинацией, `kira\db\specifications\Paginate`.*

Область применения DTO не ограничивается каким-то слоем архитектуры приложения. Главное приемущество DTO: формализация данных, которыми обмениваются классы или слои приложения. К тому же каждое свойство в DTO может иметь комментарий, что на порядок лучше, чем просто ассоциативный массив с данными.

Учитывая, что DTO класс содержит только свойства, напрашивается решение сделать их статическими. Но не надо так делать :), иначе как создать два одинаковых DTO, например? Т.е. несмотря на простоту класса в данном случае является нормальным создавать от него объект и только потом его заполнять.

## Особенности реализации

Моя реализация несколько нарушает принцип *"не должен содержать какого-либо поведения"* в пользу удобства использования.

Класс содержит конструктор, позволяющий заполнять его свойства через массив, переданный в параметре конструктора. В нормальном коде такая возможность - зло, т.к. не видно, что заполняем и сложно читать код. Однако в unit-тестах оказалось весьма удобно. Так же стоит учесть, что автозаполнение работает медленнее явного присвоения значений свойствам DTO-класса, потому что используется рефлекция класса, которая сама по себе не шустрая.

Так же супер-класс содержит метод для перевода DTO-объекта в массив - `toArray()`. Это метод ограниченного действия. Он каскадом вызовет конвертацию вложенных DTO, но оставит без изменений любые другие типы данных. Метод экспериментальный, его необходимость пока не ясна. Возможно будет удален в будущем. Или допилен..

Не трансформируется в массив любой объект, потому что у обычных объектов нет из коробки метода для выборки только публичных свойств в массив. И необходимость такого метода пока не установлена. Если же просто приводить объект к массиву через `(array)SomeObject`, то во-первых, в результат попадают все свойства, а не только публичные, во-вторых, ключи результата непредсказуемые. Короче, транформируем в массив только сам DTO.

Обычно (и полезно) в паре с DTO заводить спец.класс - трансформер. Он должен содержать логику преобразования данных для заполнения DTO. Зона ответственности трансформера несколько размыта, к тому же у меня нет полезного примера. Примите на заметку. Трансформеры необязательны, разумеется, можно заполнять DTO там, где это логично и удобно. Как в примере с `Paginate`, на который я ссылался выше: этот DTO-класс заполняется из DB-модели.

Есть более продвинутый подход к созданию DTO: все свойства делают приватными, заполняют через рефлекцию, магический сеттер или явные сеттеры. Читают через (магические) геттеры. В своих DTO я решил так не заморачиваться и держать все свойства публичными. Более того, в супер-классе запрещена магия, см. следующий раздел.

## Ограничение магии в DTO классах

PHP допускает неявное присвоение свойств класса, через магию `__set()`. По-хорошему, такие свойства должны быть описаны хотя бы в комментариях класса через `@property`. Если опечататься в названии подобного свойства класса, PHP ничего не скажет. Для сеттера с опечаткой будет присвоение значения в неявное свойство класса. Геттер с опечаткой просто вернет NULL, если свойство не найдено. Такая свобода PHP может приводить с ошибкам.

Что же касается DTO, такие классы должны явно описывать свои свойства, потому что они только для хранения данных и созданы. Если при работе с ними допустить ошибку, это может серьезно выйти боком. Поэтому я добавил ограничения в качестве предохранителя, чтобы магия в этих классах кидала исключение.
