# DB. Примеры использования

Работа с MySQL (а по умолчанию работаем именно с ней) идет через PDO. У движка есть обертки для подключения, подготовки и отправки запросов на сервер с последующим разбором ответа.

Подключение к БД осуществляется в конструкторе модели. Для переключения объекта модели на другую базу есть метод `DbModel::switchConnection()`.

## Примеры работы с классом DbModel и его наследниками

**#1. Простой запрос**

```PHP
$ids = (new UserModel)
    ->query('SELECT id FROM Users ORDER BY id')
    ->fetchAll(\PDO::FETCH_NUM);
```

**#2. Запрос с подстановками**

```PHP
$uid = Request::getAsInt('uid');
$sql = 'SELECT login, mail, `status`, salt FROM Users WHERE id = ?';
$row = $this->query($sql, [$uid])->fetch();
```

*Прим.: поддерживаеются так же именованные подстановки. В таком случае передаем ассоциативный массив. См. так же полезный метод `DbModel::valueSet()`*

**#3. Служебные манипуляции, без выделения модели-наследника**

```PHP
if ((new DbModel)->query('TRUNCATE kira_log')->effect() > 0) {
    echo 'Таблица очищена';
}
```

**#4. Подготовка IN-условия**

```PHP
$sql = 'SELECT * FROM users WHERE id IN(:ids) AND status IN (:statuses) AND role = :role';
$params = [
    ':ids'      => [1, 4, 56],
    ':statuses' => ['active', 'new'],
    ':role'     => 'user'
];
$rows = (new UserModel)
    ->prepareIN($sql, $params)
    ->query($sql, $params)
    ->fetchAll();
```

Любые значения-массивы из списка параметров рассматриваются, как подстановки в IN-условие. Метод `prepareIN()` нацелен именно на значения-массивы.

Все IN-подстановки будут подготовлены за один вызов метода `DBModel::prepareIN()`. Подстановка возможна только для именованного плейсходлера, т.к. заменить какой-то из кучи безымянных плейсхолдеров (помеченных знаком вопроса) - нетривиальная задача. Проще тогда написать свой парсер целиком.

Текстовые значения будут экранированы, другие значения останутся без изменений. Содержимое всего массива определяется по его первому элементу, т.е. считается что в нем однотипные данные.

Для экранирования строк используется [PDO::quote()](@see http://php.net/manual/en/pdo.quote.php). У него тоже есть ограничения, но это лучше, чем ничего.

**#5. Использование итератора**

```PHP
$iter = (new BlogModel)
    ->query('SELECT * FROM blog WHERE show_rec = 1 LIMIT 100')
    ->getIterator();

foreach ($iter as $row) {
    echo $row['date'] . ': ' . $row['title'];
    ...
}
```

Итераторы удобны тем, что в память выгружаются не все данные, а только один элемент массива. Применительно к запросу в базу: не все записи, а только одна. Экономия памяти в случае большого результата запроса. При этом, реализуя интерфейс \Iterator, получаем возможность обхода всех записей через цикл.

**#6. Запросы с LIKE и подстановками**

> Работая с подготовленными выражениями, следует понимать, что плейсхолдер может заменять только строку или число. Ни ключевое слово, ни идентификатор, ни часть строки или набор строк через плейсхолдер подставить нельзя. Поэтому для LIKE надо сначала подготовить строку поиска целиком, а потом ее подставлять в запрос (c) <http://phpfaq.ru/pdo#like>

Максимум, что берет на себя PDO при подстановке - это экранирование кавычек. Т.о. запрос может быть таким:

```php
// Найти всех юзеров, начинающихся с Мак'Кормик

$sql = 'SELECT * FROM users WHERE name LIKE :name';
$params = [':name' => "Mac'Cormick%"];
$names = (new UserModel)->query($sql, $params)->fetchColumn('name');
dd($names);

// Результат

array(
    "Mac'Cormick Genry",
    "Mac'Cormick Jhon",
    "Mac'Cormick Maggy",
)
```

Другой момент: символы `%` и `_` являются подстановочными знаками (wildcards) в LIKE-выражениях. И тут уже только кодер может знать, когда экранировать такие символы, а когда использовать, как элементы маски поиска. Вспомогательный метод `DbModel::escapeLike()` можно использовать для экранирования всех вхождений таких символов в строке. Пример использования:

```php
// Найти все активы, израсходованные на 50%

$sql = 'SELECT * FROM activities WHERE rest LIKE :half';
$params = [':half' => '%' . ActivitiesModel::escapeLike('50%') . '%'];
$activities = (new ActivitiesModel)->query($sql, $params)->fetchAll();
dd($activities);

// Результат

array(
    '50% of whater',
    'gold - 50%',
    'oxigen - 50%, carbon - 35%'
);
```

**#7. Запрос с пагинацией**

Допустим, у нас есть большой список данных, нам нужно получить его срез - данные для одной страницы. При этом нужна инфа об общем количестве записей, соответствущих запросу. Для этих нужд служит метод `DbModel::paginate()`. Он дополняет переданный в него запрос инструкцией `SQL_CALC_FOUND_ROWS` для последующего вызова спец. запроса [FOUND_ROWS()](https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_found-rows). В итоге метод вернет все необходимые данные. От вас требуется передать ему: сам текст запроса **без выражения LIMIT**, параметры подстановки, номер страницы и количество записей на страницу.

```php
$sql =
    'SELECT *
    FROM blog
    WHERE `status`="public"
        AND title LIKE :title
    ORDER BY created_at';

$params = ['title' => 'Тру-ля-%'];

$page = max(1, Request::getAsInt('page', 1));

$result = (new BlogModel)->paginate($sql, $params, $page, $perPage = 10);
```

Результат - это DTO-объект класса `\kira\db\specifications\PaginateSpec`. Он содержит итератор с найденными записями и два счетчика: все записи и количество записей для текущей страницы. Последний счетчик не особо и нужен, он для удобства.

Про спецификации, к которым относится `PaginateSpec`, см. отдельный док *"Спецификации"*, про DTO тоже есть отдельный док - *"DTO"*.

**Важно**: поскольку метод универсальный, он имеет некоторый overhead - вызывает `Db::prepareIN()` для подготовки IN-условий, даже если их нет в запросе. Это не ломает запрос и ни к чему не обязывает клиентский код. Просто выполняется вся возможная подготовка запроса.
