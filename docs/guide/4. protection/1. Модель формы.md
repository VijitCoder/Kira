# Модель формы. Валидация форм

Класс `kira\web\From`. Сам по себе не используется, клиентские модели форм должны наследовать от него.

Возможности модели форм в этом движке:

- любая вложенность исходных данных
- валидация массива однородных данных одним правилом
- любое количество валидаторов на конкретное значение. Есть ограничение на количество валидаторов по типу, см. ниже.
- свои сообщения об ошибках от любого валидатора

Пример использования модели формы:

```PHP
$form = new SomeForm;
if ($form->load($_POST)->validate()) {
...
} else {
    $errors = $form->getErrors();
}
```


*Прим: иногда для маленьких форм невыгодно заводить модель. Валидировать значения можно так же через серию методов `kira\net\Request`, см. функции класса `get()`, `post()`, `cookie()`, `request()` и их производные.*

## Структура контракта

Основное понятие - **контракт на поля формы**. Это массив с именами полей и списком валидаторов для их проверки.

**Важно:** служебные слова `validators`, `default` заняты в описании контракта. Названия полей формы не должны сопадать с этими словами, иначе результат непредсказуем.

Зачем `validators`: механизм валидации поддерживает *многомерные массивы с описанием полей*. Без явного указания через `validators` в многомерном массиве невозможно отличить, где иерархия имени поля, а где - валидаторы.

Зачем `default`: если поле необязательное, оно может быть не передано в запросе браузера. Тогда значением поля станет `NULL`. Однако если требуется иное значение, укажите его в ключе `default`. Важно отметить, что значения по умолчанию будут присвоены только валидным полям, имеющим `NULL` после валидации. Это позволяет по-прежнему отлавливать ошибки, если значение поля задано.

Формы могут быть любой сложности и вложенности данных. Контракт должен повторять иерархию вложенности данных. Рассмотрим на примере сложной html-формы с большой вложенностью данных:

```html
<form method="POST" action="create">
    <input type="text" value="test" name="inp0">

    <input type="text" value="test1" name="inp1[]">
    <input type="text" value="test2" name="inp1[]">
    <input type="text" value="test3" name="inp1[]">

    <input type="text" value="test4" name="inp2[one]">
    <input type="text" value="test5" name="inp2[two]">

    <input type="text" value="true" name="inp3[lvl1][lvl11]">
    <input type="text" value="test7" name="inp3[lvl1][lvl12]">
    <input type="text" value="test8" name="inp3[lvl1][lvl12][lvl121]">
    <input type="submit">
</form>
```

Дамп переменной $_POST:

```PHP
array
(
    'inp0' => 'test'
    'inp1' => array
    (
        0 => 'test1'
        1 => 'test2'
        2 => 'test3'
    )
    'inp2' => array
    (
        'one' => 'test4'
        'two' => 'test5'
    )
    'inp3' => array
    (
        'lvl1' => array
        (
            'lvl11' => 'true'
            'lvl12' => array   // обратите внимание: "test7" отсутствует
            (
                'lvl121' => 'test8'
            )
        )
    )
)
```

Пример контракта на поля формы:

```PHP
use kira\validation\validators\Typecast;

class SomeForm extends kira\utils\Form {
    protected $contract = [
        'inp0' => [
            'validators' => [          // здесь три валидатора
                'required' => true,

                'filter_var' => [
                    'filter'  => FILTER_VALIDATE_REGEXP,
                    'options' => ['regexp' => '~^[a-z0-9-_]+$~i'],
                    'message' => 'Недопустимые символы в логине',
                ],

                'limits' => ['min' => 5, 'max' => 30,],
            ],
        ],

        'inp1' => [
            'validators' => [
                'expect_array' => true,     // обязательный флаг для обработки массивов данных
                'normalize_string' => true,
            ],
         ]

        'inp2' => [
            'validators' => [
                'expect_array' => true,
                ...
            ],
        ],

        'inp3' => [
            'lvl1' => [
                'lvl11' => [
                    'default'    => false,
                    'validators' => ['typecast' => Typecast::BOOL,],
                ],
                'lvl12' => [
                    'default' => '',
                    'lvl121'  => null,  // принять без валидации
                ],
            ],
        ],
    ];
}
```

Валидаторы могут быть назначены только на конечный узел иерархии, т.е. на данные конкретного поля формы. Исключение составляет массив данных с валидатором `expect_array`, см. документ *Валидаторы*.

Валидаторы описываются в отдельном ассоциативном массиве с ключом `validators`. В свою очередь ключи такого массива - конкретные названия валидаторов, значения массива - параметры валидаторов.

Если валидация поля не нужна, пишем `null` в качестве значения.

Для простых форм требуемое описание контракта может казаться излишне сложным. Тем не менее такой подход оправдан, т.к. поддерживается единый интерфейс контракта для форм любой сложности. Один раз разобраться и потом можно читать и править любую модель. Это лучше, чем если бы я ввел еще и "легкую" версию контракта и запоминать пришлось бы два интерфейса.

## Валидаторы

См. отдельный документ *Валидаторы*

## Структура модели формы

После вызова конструктора модели ее уже можно использовать на веб-формах. Это удобно, когда предполагается повторное заполнение формы данными при ошибках валидации. Логика такая: пишем шаблон со вставками данных из модели формы. Контроллер создает экземпляр модели и передает его в шаблон. Все. Не нужно в шаблоне проверять наличие поля через `isset()`. Все поля есть согласно описания контракта. Все данные в них равны `null`.

Чтобы проверить полученные данные, их нужно загрузить в модель. Для этого служит метод

```PHP
function load(array &$data):From
```

Эти данные будут сохранены, как "сырые": передаваемый на загрузку массив никак не изменяется и даже сохранятся элементы, не заявленные в контракте.

Метод возвращает объект текущей модели, что позволяет выполнить вызов следующего метода по цепочке.

Собственно проверка вызывается методом

```PHP
function validate():bool
```

#### Внутреннее представление данных

Модель формы хранит три массива, соответствующие иерархии исходных данных:

- *Сырые данные* (RawData). Это все, что было передано в модель. Как есть, без валидации, независимо от полей контракта.

- *Проверенные данные* (Values). В этот массив попадет только то, что **заявлено в контракте** и прошло валидацию.

Очередной валидатор меняет тут значение только в случае успешной проверки (если конечно предполагается такое изменение). Иначе значение остается таким, каким было получено на вход валидатора. Такой подход позволит комбинировать выдачу юзеру. Можно вернуть текущее значение и указать на ошибку.

- *Ошибки* (Errors). В массив ошибок можно добавлять свои из клиентского кода.

Для получения данных из этих массивов используются соответственно:

```PHP
function getRawData(mixed $key = null):mixed
function getValues(mixed $key = null):mixed
function getErrors(mixed $key = null):array|null
```

Параметр `$key` необязателен. Если не задан - возвращается весь массив.

Для многомерных массивов можно достать данные с любого уровня, указывая ключ типа `['level1' => ['level2' => 'level3']]`.

---

Для сборки всех ошибок в строку из многомерного массива может оказаться полезной функция:

```php
function getErrorsAsStringPerField(string $key = null, string $glue = ' ', string $eol = '')
```

Ее результат может быть разным:

- если `$key` не указан, возвращает **одномерный** ассоциативный массив, где ключи это имена полей, а значения - все ошибки по каждому полю, склееные в строку. Между ошибками будет вставлен `$glue`. Если форма/контракт являются многомерным массивом, тогда ошибки подмассивов тоже склеиваются строки и такие строки отделяются друг от друга `$eol`. Т.е. в итоге, независимо от вложенности контракта получится одномерный массив \[старший ключ (поле) => все ошибки в одной строке].

- если `$key` указан, функция вернет строку с ошибками для заданного поля. Для многомерных массивов будут склеены все ошибки с более глубоких уровней до заданного в `$key` поля.

Пример с многомерным массивом:

```php
// Массив ошибок соответствует сложной структуре некоторой формы
$form->errors = [
    'modules' => ['Недопустимые символы.'],
    'db' => [
        'server' => ['Неизвестный сервер.', 'Еще одна ошибка.'],
        'database' => ['База данных не найдена.'],
    ],
    'auth_key' => null,
];
...

dd($form->getErrorsAsStringPerField());

// [
//     'modules' => 'Недопустимые символы.',
//     'db' => 'Неизвестный сервер. Еще одна ошибка. База данных не найдена.',
//     'auth_key' => null,
// ]

...

dd($form->getErrorsAsStringPerField('db'));

// 'Неизвестный сервер. Еще одна ошибка. База данных не найдена.'

...

dd($form->getErrorsAsStringPerField(['db' => 'server']));

// 'Неизвестный сервер. Еще одна ошибка.'
```

#### Дополнительные функции модели формы

```PHP
function addError(array $message):void
```

Добавление своего сообщения в массив ошибок. Ключ в массиве - имя поля, значение - собственно сообщение. В случае многомерного массива описывается полный путь вложений к требуемому полю и потом сообщение.

---

```PHP
function hasErrors():bool
```

Проверка, есть ли какие-то ошибки. Не обязательно ошибки валидации. Такое возможно, учитывая использование метода `addError()`.

---

```PHP
function isValid():bool
```

Получение информации о результате валидации. Очевидно, что вызывать такой метод имеет смысл только после вызова `validate()`.

---

```PHP
function setValues(array $values):self
```

Добавить свои значения в массив **валидированных** данных. Если какое-то значение нужно разместить в многоуровневом массиве, пишем всю вложенность ключей и новое значение на нужном уровне. Старое значение будет переписано, если оно есть. Наличие поля не проверяется, что дает больше возможностей для управления массивом итоговых данных.

## Защита от CSRF атаки

см. отдельный документ *Защита от CSRF*

## Исключения

Модель формы или супер-класс валидатора пробрасывает исключение `kira\exceptions\FormException`. В основном все случаи исключения такого типа указывают на неверное использование функционала (ошибка кодера). Один уникальный случай: проверка CSRF-токена. Если проверка не пройдет, будет `FormException` с кодом 400.

## Магический доступ к полям формы

Есть геттер и сеттер для доступа к полям формы. Доступны все поля, хранящиеся в `Form::$values`, т.е. все валидированные данные. Если поле не найдено, будет исключение. Если поля формы - многомерный массив, то на вложенные уровни нельзя попасть через магию. Простой пример:

```php
class LoginForm
{
    protected $contract = [
        'login' => [
            'validators' => [...]
        ],
        'password' => [
            'validators' => [...]
        ],
    ];
}

$form = new LoginForm->load(Request::get());
if ($form->validate()) {
    dd($form->login, $form->password); // магический доступ к валидированным значениям
    $form->rememberMe = true;          // будет исключение, такого поля нет в модели формы
}
```

## Нерешенные вопросы

Если поле в контракте - необязательное и его нет в проверяемых данных, то его значение будет равно NULL. Т.е. его можно будет получить через `Form::getValues()`, но только NULL. А что, если мне нужно для таких полей задать дефолтные значения, если дял них не передали данные? Пока я не придумал решения, красивого и при этом понятного с клиентской точки зрения.

-

Кастомные сообщения об ошибках прогоняются через переводчик, но нет возможности использовать его с подстановкой значений. Для дефолтных значений я переопределил метод полностью, где это нужно было. Например, в `Limits`. Но это некритичная сейчас проблема, не хочу ей заниматься.
