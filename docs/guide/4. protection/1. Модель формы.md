# Модель формы. Валидация форм

Класс `kira\web\From`. Сам по себе не используется, клиентские модели форм должны наследовать от него.

Возможности модели форм в этом движке:

- любая вложенность исходных данных
- валидация массива однородных данных одним правилом
- любое количество валидаторов на конкретное значение. Есть ограничение на количество валидаторов по типу, см. ниже.
- свои сообщения об ошибках от любого валидатора

Пример использования модели формы:

```PHP
$form = new SomeForm;
if ($form->load($_POST)->validate()) {
...
} else {
    $errors = $form->getErrors();
}
```


*Прим: иногда для маленьких форм невыгодно заводить модель. Валидировать значения можно так же через серию методов `kira\net\Request`, см. функции класса `get()`, `post()`, `cookie()`, `request()` и их производные.*

## Структура контракта

Основное понятие - **контракт на поля формы**. Это массив с именами полей и списком валидаторов для их проверки. Простой пример контракта:

```
$contract = [
    'startFrom' => [
        'validators' => [
            'required' => ['message' => 'This field is required'],

            'limits' => [
                'max' => 20,
                'message' => 'Too long file name.',
            ],
        ],
    ],

    'debugMode' => [
        'default' => true,
        'validators' => ['typecast' => Typecast::BOOL]
    ],
];
```

_В данном примере ключи старшего массива соответствуют полям некоторой HTML формы, подмассивы описывают валидаторы для каждого поля._

**Важно:** служебные слова `validators`, `default` заняты в описании контракта. Названия полей формы не должны сопадать с этими словами, иначе результат непредсказуем.

Зачем `validators`: механизм валидации поддерживает *многомерные массивы с описанием полей* (об этом чуть ниже). Без явного указания через `validators` в многомерном массиве невозможно отличить, где иерархия имени поля, а где - валидаторы.

Зачем `default`: если поле необязательное, оно может быть не передано в запросе браузера. Тогда значением поля будет `NULL`. Однако если требуется иное значение, укажите его в ключе `default`.

Значения по умолчанию присваиваются сырым данным и валидным полям сразу же при создании объекта формы, т.е. еще до загрузки данных от пользователя и до валидации, само собой. Поэтому такие значения должны отвечать валидаторам для соответствующего поля, иначе его проверка не пройдет.

Для простых форм требуемое описание контракта может казаться излишне сложным. Тем не менее такой подход оправдан, т.к. поддерживается единый интерфейс контракта для форм любой сложности. Один раз разобраться и потом можно читать и править любую модель. Это лучше, чем если бы я ввел еще и "легкую" версию контракта и запоминать пришлось бы два интерфейса.

### Форма большой вложенности

Формы могут быть любой сложности и вложенности данных. Контракт должен повторять иерархию вложенности данных. Рассмотрим на примере сложной html-формы с большой вложенностью данных:

```html
<form method="POST" action="create">
    <input type="text" value="test" name="inp0">

    <input type="text" value="test1" name="inp1[]">
    <input type="text" value="test2" name="inp1[]">
    <input type="text" value="test3" name="inp1[]">

    <input type="text" value="test4" name="inp2[one]">
    <input type="text" value="test5" name="inp2[two]">

    <input type="text" value="true" name="inp3[lvl1][lvl11]">
    <input type="text" value="test7" name="inp3[lvl1][lvl12]">
    <input type="text" value="test8" name="inp3[lvl1][lvl12][lvl121]">
    <input type="submit">
</form>
```

Дамп переменной $_POST:

```PHP
array
(
    'inp0' => 'test'
    'inp1' => array
    (
        0 => 'test1'
        1 => 'test2'
        2 => 'test3'
    )
    'inp2' => array
    (
        'one' => 'test4'
        'two' => 'test5'
    )
    'inp3' => array
    (
        'lvl1' => array
        (
            'lvl11' => 'true'
            'lvl12' => array   // обратите внимание: "test7" отсутствует
            (
                'lvl121' => 'test8'
            )
        )
    )
)
```

Пример контракта на поля формы:

```PHP
use kira\validation\validators\Typecast;

class SomeForm extends kira\utils\Form {
    protected $contract = [
        'inp0' => [
            'validators' => [          // здесь три валидатора
                'required' => true,

                'filter_var' => [
                    'filter'  => FILTER_VALIDATE_REGEXP,
                    'options' => ['regexp' => '~^[a-z0-9-_]+$~i'],
                    'message' => 'Недопустимые символы в логине',
                ],

                'limits' => ['min' => 5, 'max' => 30,],
            ],
        ],

        'inp1' => [
            'validators' => [
                'expect_array' => true,     // обязательный флаг для обработки массивов данных
                'normalize_string' => true,
            ],
         ]

        'inp2' => [
            'validators' => [
                'expect_array' => true,
                ...
            ],
        ],

        'inp3' => [
            'lvl1' => [
                'lvl11' => [
                    'default'    => false,
                    'validators' => ['typecast' => Typecast::BOOL,],
                ],
                'lvl12' => [
                    'default' => '',
                    'lvl121'  => null,  // принять без валидации
                ],
            ],
        ],
    ];
}
```

## Валидаторы

См. отдельный документ *Валидаторы*

## Структура модели формы

После вызова конструктора модели ее уже можно использовать на веб-формах. Это удобно, когда предполагается повторное заполнение формы данными при ошибках валидации. Логика такая: пишем шаблон со вставками данных из модели формы. Контроллер создает экземпляр модели и передает его в шаблон. Все. Не нужно в шаблоне проверять наличие поля через `isset()`. Все поля есть согласно описания контракта. Все данные в них равны `null`.

Чтобы проверить полученные данные, их нужно загрузить в модель. Для этого служит метод

```PHP
function load(array &$data):From
```

Эти данные будут сохранены, как "сырые": передаваемый на загрузку массив никак не изменяется и даже сохранятся элементы, не заявленные в контракте.

Метод возвращает объект текущей модели, что позволяет выполнить вызов следующего метода по цепочке.

Собственно проверка вызывается методом

```PHP
function validate():bool
```

#### Внутреннее представление данных

Модель формы хранит три массива, соответствующие иерархии исходных данных:

- *Сырые данные* (RawData). Это все, что было передано в модель. Как есть, без валидации, независимо от полей контракта.

- *Проверенные данные* (Values). В этот массив попадет только то, что **заявлено в контракте** и прошло валидацию.

Очередной валидатор меняет тут значение только в случае успешной проверки (если конечно предполагается такое изменение). Иначе значение остается таким, каким было получено на вход валидатора. Такой подход позволит комбинировать выдачу юзеру. Можно вернуть текущее значение и указать на ошибку.

- *Ошибки* (Errors). В массив ошибок можно добавлять свои из клиентского кода.

Для получения данных из этих массивов используются соответственно:

```PHP
function getRawData(mixed $key = null):mixed
function getValues(mixed $key = null):mixed
function getErrors(mixed $key = null):array|null
```

Параметр `$key` необязателен. Если не задан - возвращается весь массив.

Для многомерных массивов можно достать данные с любого уровня, указывая ключ типа `['level1' => ['level2' => 'level3']]`.

---

Для сборки всех ошибок в строку из многомерного массива может оказаться полезной функция:

```php
function getErrorsAsStringPerField(string $key = null, string $glue = ' ', string $eol = '')
```

Ее результат может быть разным:

- если `$key` не указан, возвращает **одномерный** ассоциативный массив, где ключи это имена полей, а значения - все ошибки по каждому полю, склееные в строку. Между ошибками будет вставлен `$glue`. Если форма/контракт являются многомерным массивом, тогда ошибки подмассивов тоже склеиваются строки и такие строки отделяются друг от друга `$eol`. Т.е. в итоге, независимо от вложенности контракта получится одномерный массив \[старший ключ (поле) => все ошибки в одной строке].

- если `$key` указан, функция вернет строку с ошибками для заданного поля. Для многомерных массивов будут склеены все ошибки с более глубоких уровней до заданного в `$key` поля.

Пример с многомерным массивом:

```php
// Массив ошибок соответствует сложной структуре некоторой формы
$form->errors = [
    'modules' => ['Недопустимые символы.'],
    'db' => [
        'server' => ['Неизвестный сервер.', 'Еще одна ошибка.'],
        'database' => ['База данных не найдена.'],
    ],
    'auth_key' => null,
];
...

dd($form->getErrorsAsStringPerField());

// [
//     'modules' => 'Недопустимые символы.',
//     'db' => 'Неизвестный сервер. Еще одна ошибка. База данных не найдена.',
//     'auth_key' => null,
// ]

...

dd($form->getErrorsAsStringPerField('db'));

// 'Неизвестный сервер. Еще одна ошибка. База данных не найдена.'

...

dd($form->getErrorsAsStringPerField(['db' => 'server']));

// 'Неизвестный сервер. Еще одна ошибка.'
```

#### Дополнительные функции модели формы

```PHP
function addError(array $message):void
```

Добавление своего сообщения в массив ошибок. Ключ в массиве - имя поля, значение - собственно сообщение. В случае многомерного массива описывается полный путь вложений к требуемому полю и потом сообщение.

---

```PHP
function hasErrors():bool
```

Проверка, есть ли какие-то ошибки. Не обязательно ошибки валидации. Такое возможно, учитывая использование метода `addError()`.

---

```PHP
function isValid():bool
```

Получение информации о результате валидации. Очевидно, что вызывать такой метод имеет смысл только после вызова `validate()`.

---

```PHP
function setValues(array $values):self
```

Добавить свои значения в массив **валидированных** данных. Если какое-то значение нужно разместить в многоуровневом массиве, пишем всю вложенность ключей и новое значение на нужном уровне. Старое значение будет переписано, если оно есть. Наличие поля не проверяется, что дает больше возможностей для управления массивом итоговых данных.

## Защита от CSRF атаки

см. отдельный документ *Защита от CSRF*

## Исключения

Модель формы или супер-класс валидатора пробрасывает исключение `kira\exceptions\FormException`. В основном все случаи исключения такого типа указывают на неверное использование функционала (ошибка кодера). Один уникальный случай: проверка CSRF-токена. Если проверка не пройдет, будет `FormException` с кодом 400.

## Магический доступ к полям формы

Есть геттер и сеттер для доступа к полям формы. Доступны все поля, хранящиеся в `Form::$values`, т.е. все валидированные данные. Если поле не найдено, будет исключение. Если поля формы - многомерный массив, то на вложенные уровни нельзя попасть через магию. Простой пример:

```php
class LoginForm
{
    protected $contract = [
        'login' => [
            'validators' => [...]
        ],
        'password' => [
            'validators' => [...]
        ],
    ];
}

$form = new LoginForm->load(Request::get());
if ($form->validate()) {
    dd($form->login, $form->password); // магический доступ к валидированным значениям
    $form->rememberMe = true;          // будет исключение, такого поля нет в модели формы
}
```

## Хак для checkbox, поднятый по умолчанию 

_Решение пока сырое, может найду способ получше._

Допустим, есть форма: 

```html
<form action='POST'>
    <input name="debugMode" <?= $form->debugMode ? 'checked' : '' ?>>
    <button type="submit">Отправить</button>
</form>
```

И я хочу, чтобы по умолчанию флаг был _поднят_. 

Вариант 1. Изменить представление:

```
<input name="debugMode" <?= ($form->debugMode === null || $form->debugMode) ? 'checked' : '' ?>>
```

Вариант 2. Не менять представление, а указать в контракте формы дефолтное значение:

```php
$contract = [
    'debugMode' => ['default' => true]
];
```

Теперь проблема: если отправить эту форму со сброшенным флагом, то в запросе не будет указан элемент $_POST['debugMode']. И тогда либо в представлении условие сработает неверно - `$form->debugMode === null` и после перезагрузки страницы поднимет флаг, либо модель формы возьмет значение по умолчанию, что прописано в контракте - `true`, - и так же поднимет флаг. Т.е. юзер флаг сбросил, а мы его определили, как поднятый. Причина проблемы в том, что checkbox в HTML - это не логическое поле, поэтому место нормальных true/false его состояние передается через "есть элемент/нет элемента" в массиве параметров.

Короче, вот какой хак: нужно переопределить унаследованный метод `Form::load()`:

```php
public function load(array $data)
{
    if (!array_key_exists('debugMode', $data)) {
        $data['debugMode'] = false;
    }
    return parent::load($data);
}
```

## Нерешенные вопросы

Кастомные сообщения об ошибках прогоняются через переводчик, но нет возможности использовать его с подстановкой значений. Для дефолтных значений я переопределил метод полностью, где это нужно было. Например, в `Limits`. Но это некритичная сейчас проблема, не хочу ей заниматься.
