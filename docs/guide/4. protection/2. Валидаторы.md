# Модель формы: валидаторы

Валидаторы могут быть назначены только на конечный узел иерархии, т.е. на данные конкретного поля формы. Исключение составляет массив данных с валидатором `expect_array`, см. ниже.

Валидаторы описываются в контракте формы в отдельном ассоциативном массиве с ключом `validators`. В свою очередь ключи такого массива - конкретные названия валидаторов, значения массива - параметры валидаторов.

Если валидация поля не нужна, пишем `null` в качестве значения.

**Важно:** каждый валидатор имеет название. На одно проверяемое значение нельзя повешать два валидатора с одним названием. Это очевидно, т.к. название валидатора задается в ключе массива валидаторов и повторное его использование перепишет предыдущее значение в массиве.

Валидаторы движка нельзя переписать. Но можно создать и использовать свои кастомный функции валидации. Для этого служат валидаторы `external` и `filter_var` со значением `'filter'  => FILTER_CALLBACK`.

## Сообщения

Любой валидатор может сопровождаться своим сообщением. Так же кастомные валидаторы, подключаемые через `external`, могут возвращать свои сообщения. Если сообщение указано в контракте, при валидации прогоняем его через переводчик (см. док *"Локализация сайта"*). Сообщения из кастомных валидаторов принимаем без перевода.

Дефолтные сообщения валидаторов так же прогоняются через переводчик.

Сообщение, заданное в контракте для конкретного валидатора, заменяет дефолтное его сообщение.

## Очередь выполнения валидаторов

Сначала проверяется тип ожидаемого значения, должен ли быть массив или нет. Независимо от положения `expect_array` в списке валидаторов он будет выполнен первым.

Потом к данным поля формы применяется `required`, (если он задан), причем так же независимо от его положения в списке валидаторов. Это позволит остальным валидаторам не ругаться на неправильные значения, когда их просто нет. Остальные валидаторы выполняются в порядке очереди. Т.о. следует использовать, например, проверку длины **после** дезинфицирующих фильтров, поскольку длина строки может измениться.

Если очередной валидатор забраковал значение, последующие валидаторы для поля не вызываются.

## Описания валидаторов

*Список в алфавитном порядке*

[date](#date)
[email](#email)
[enum](#enum)
[expect_array](#expect_array)
[expect_id](#expect_id)
[external](#external)
[filter_var](#filter_var)
[limits](#limits)
[normalize_string](#normalize_string)
[password](#password)
[required](#required)
[typecast](#typecast)

#### date

Валидатор даты. Проверка даты по формату и ее реальности. Полностью основан на этом [комментарии к мануалу PHP](http://php.net/manual/ru/function.checkdate.php#113205)

Настройки:

```php
'date' => [
   'format'  => 'Y-m-d H:i:s', // формат по умолчанию
   'message' => string,        // свое сообщение об ошибке
]
```

Формат описываем по правилам [DateTime::createFromFormat()](http://php.net/manual/ru/datetime.createfromformat.php). Все просто :)

Если устраивают настройки по умолчанию, тогда подключение валидатора выглядит так:

```php
'some-date' => [
    'validators' => ['date' => true],
]
```

#### email

Проверка email адреса на корректность и черные сервера. Настройки:

```php
'email' => [
    'regexp' => '/\S+@\S+\.\S+/', // значение по умолчанию
    'black_servers' => array | NULL
]
```

Проверка адреса на корректность выполняется простой регуляркой (см. выше). Почему так просто, см. [тут](http://habrahabr.ru/post/175375/)  Конечно вы можете определить свое регулярное выражение.

Проверка на черный список серверов необязательна. Нет списка - нет проверки.

#### enum

Валидатор проверяет значение по списку допустимых значений.

Можно указать набор значений в неассоциативном массиве или просто в строке с разделителем "|". Это минимальная
настройка валидатора.

Полный формат валидатора:

```php
[
   values      => [val1, val2, ...] или 'val1|val2|...',
   insensitive => bool,   // TRUE - регистр не важен, FALSE (по умолчанию) - регистрозависимое сравнение.
   message     => string, // свое сообщение об ошибке
]
```

Примеры:

```php
$contract = [
    'union' => [
        'validators' => ['enum' => 'or|and'],
    ],

    'years' => [
        'default' => 1997,
        'validators' => ['enum' => [1997, 1998, 1999, 2001, 2005]],
    ],

    'bikeManufactor' => [
        'validators' => [
            'enum' => [
               'values' => ['Honda', 'Suzuki', 'BMW', 'Triumph'],
               'insensitive' => true,
            ]
        ],
    ],
];
```

#### expect_array

Особый валидатор, позволяющий применить все остальные валидаторы к проверяемому значению, как к массиву однотипных данных, если в контракте указано, что ждем массив. Если же этого указания нет, то механизм валидации все равно проверит тип значения, но уже на отличие от массива. Т.о. массивы данных пройдут проверку только там, где они ожидаются.

Зачем такой валидатор: неверный тип данных может привести к непредвиденной ошибке в других валидаторах или в клиентском коде. Поэтому требуется отдельная проверка на тип "массив/не массив".

Очевидно, что при валидации массива не имеет смысла задавать конкретные сообщения об ошибках, т.к. для каждого невалидного значения будет использовано одно и тоже сообщение.

По умолчанию `expect_array` равно `false`, т.е. в каждом поле ожидаем единичное значение, не массив.

Этот валидатор в некотором роде служебный, является дополнительной защитой от попытки поломать сайт и получить какие-нибудь ошибки. Т.е. обычный пользователь не сможет тут нарушить логику сайта, поэтому для данного валидатора нельзя назначить пользовательское сообщение об ошибке. К тому же это технически сложно, т.к. сообщений нужно задать два.

Поведение валидатора `required` тут так же имеет особенность: он проверит, что массив в целом не пустой и что каждый его элемент - не пустой.

При указании дефолтного значения к такому полю оно применится к нему в целом, а не для каждого элемента. Это оправданно: так можно описать ожидаемый массив с разными значениями в качестве дефолтных.

Если дефолтное значение не задано и ничего не передано из формы, после успешной валидации в поле будет `NULL`, а не пустой массив. Это тоже оправданно: модель хранит в точности те данные, которые получила в запросе. Если же нужно, чтобы был пустой массив, его можно объявить в качестве дефолтного значения.

#### expect_id

Валидатор проверяет значение, как целое положительное число. Валидатор имеет только одну настройку - `message`. Если сообщение не требуется, можно просто указать `TRUE` вместо настроек валидатора.

Пример использования:

```php
$contract = [
    'id' => [
        'validators' => [except_id => true]
    ],
    'userId' => [
        'validators' => [except_id => ['message' => 'Неверный id пользователя']]
    ],
    'page' => [
        'validators' => [except_id => ['message' => 'Неверный номер страницы']]
    ],
];
```

#### external

Валидатор-посредник. Служит для вызова кастомных валидаторов, не зашитых в движке.

Сам валидатор не проводит проверку. Он передает настройки и сообщение в указанный внешний валидатор, забирает из него результат
и возвращает без изменений.

Настройки External:

```php
$options = [
     'class'   => string // FQN класса-валидатора
     'options' => mixed  // Настройки вызываемого валидатора
];
```

Если нужно переопределить сообщение в вызываемом валидаторе, прописывать его надо в `options => [message => string]`.

Пример:

```php
'external' => [
    'class'   => CustomValidator::class,
    'options' => [
        'allowNegative' => true,
        'min'           => -100,
        'message'       => 'Неверное что-то в кастомном валидаторе',
    ],
]
```

Требования к вашему внешнему валидатору:

- наследник `AbstractValidator`, реализация метода `validate()`. Метод должен возвращать `bool`.
- присвоение проверенного значения в `AbstractValidator::$value`. Оно будет передано дальше в цепочке валидаторов.
- ошибку писать в `AbstractValidator::$error`. Оттуда его достанет механизм валидации, если проверка не пройдет.

Так же стоит изучить конструктор `AbstractValidator`. Переопределить его, если не устраивает. Ваш класс должен быть создан с расчетом на то, что один объект валидатора может быть использоваться для проверки нескольких значений. Т.е. нигде не должно залипнуть старое значение или ошибка валидации.

*Прим.: все валидаторы движка наследуют `AbstractValidator`. Их тоже можно изучить вместе с тестами для понимания, как написать свой валидатор. Самые простые валидаторы - `required` и `expect_id`, поддерживающий несколько взаимоисключающих сообщений - `email`.*

#### filter_var

Описывается по правилам [php::filter_var()](http://php.net/manual/ru/function.filter-var.php), для валидации будет вызвана именно эта функция. Обязательный элемент - `filter`, мое дополнение - `message`. Пример:

```PHP
...
'login' => [
    'validators' => [
        'filter_var' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => [
                'regexp' => '~^[a-z0-9-_]+$~i'
            ],
            'flags' => null, // для этого типа фильтра нет флагов. Но для фильтров, где флаги возможны, описывать тут
            'message' => 'Недопустимые символы в логине',
        ],
    ],
],
...
```

Некоторые фильтры позволяют задать значение по умолчанию через `options['defalut']`. Если оно есть, то в случае неудачи функция возвращает это значение, а не `FALSE`. Основной метод валидации воспримет такую ситуацию, как успешную и запишет полученное значение в проверенные данные. Я думаю, это логично: кодер указал, что принимать по умолчанию. Следовательно он не хочет ошибку валидации.

Некоторые фильтры поддерживают настройку через флаги. Такие значения передавать через ключ `flags` **рядом** с `options` (см. пример в этом разделе). Если фильтр не поддерживает флаги или их использование не требуется, то в контракте их можно вообще не описывать.

#### limits

Проверка значения на соблюдение заданных пределов. Для числел - диапазон значений, для строк - длина строки.

Главное удобство этого валидатора в возможности задать свое сообщение именно на нарушение границ длины строки или диапазона числа. Если свое сообщение не требуется, контроль длины/диапазона можно совместить с регуляркой в `filter_var` и выдавать что-нибудь общее в качестве сообщения.

Настройки валидатора:

```php
'limits' => [
    'min'     => number,
    'max'     => number,
    'message' => string|array [min => string, max => string],
],
```

Любой из параметров можно пропустить. Значение `NULL` - не проверять границу с этой стороны.

Пример:

```php
'limits' => [
    'min'     => 5.7,
    'max'     => 10,
    'message' => [
        'min' => 'Число не меньше :min', // тут будет использована подстановка значения min = 5.7
        'max' => 'Слишком большое число',
    ],
]
```

**Важно**: если значение ранее не приведено к нужному типу, то сначала оно будет рассматриваться, как строка и будет применена проверка на длину строки. Во избежание недопонимания ставьте перед этим валидатором приведение к типу через `filter_var` или `typecast`, если ожидаете значение-число.

#### normalize_string

Дезинфекция и нормализация строки. Тут нет проверок, только изменение переданного значения:

- удаляем начальные и конечные пробельные пробелы, а так же "\n, \r, \t, \v, \0" **из любого места в строке**
- Удаляем лишние пробелы внутри строки
- преобразуем html-сущности, кодировка 'UTF-8' ИЛИ вообще вырезаем теги (опционально)
- удаляем обратные слеши для исключения возможности написания скриптов на Perl

Без настроек валидатора, используется так:

```php
...
'normalize_string' => true,
...
```

Настройки:

- `keep_line_breaks` - сохранять переносы строк в тексте. По умолчанию - FALSE.
- `strip_tags` - TRUE = удалять теги, FALSE = сохранять, но преобразовывать html-сущности. По умолчанию - FALSE.
- `ent_flags` - флаги для `php::htmlspecialchars()`. См. [справку по функции](http://php.net/manual/en/function.htmlspecialchars.php).  По умолчанию - `ENT_QUOTES | ENT_HTML5`, т.е. код рассматривается, как HTML5; вместе с сущностями преобразуются любые кавычки.

Пример вызова с настройкой удаления тегов:

```php
'text' => [
    'validators' => [
        'normalize_string' => ['strip_tags' => true],
    ]
]
```

Если задано удаление тегов, при этом *все равно преобразуются* кавычки/двойные кавычки, амперсант и другие html-сущности. Так вы гарантированно получаете строку, которая не порвет шаблон. Т.е. тут такая последовательность: если требуется, сначала вырезаем теги через `php::strip_tags()`, затем независимо от настройки применяем `htmlspecialchars($value, $options['ent_flags'], 'UTF-8')`.

#### password

Проверка пароля на допустимые символы и количество используемых наборов символов в одном пароле. Проще говоря, когда вы от пользователя хотите пароль минимум в 5 символов и с обязательным использованием двух регистров + цифры - это как раз тот самый валидатор.

В пароле засчитываются следующие наборы символов (это хардкод валидатора, не настраивается):

- цифры
- буквы в нижнем регистре
- буквы в верхнем регистре
- спецсимволы: _ - + = : ; , . ! @ # $ % ^ & ` ~ и пробел

Буквы в верхнем/нижнем регистре считаются разными наборами при проверке минимальной комбинации символов.

Настройки валидатора (указаны значения по умолчанию):

```
'password' => [
   'min_length' => 0,      // минимальная длина пароля. 0 = любая длина подходит.
   'min_combination' => 1, // минимальная комбинация наборов символов в пароле
   'glue' => ' ',          // чем склеить ошибки валидации. Их может быть несколько, применится php::implode()
]
```

Про ошибки нужно пояснить: если пароль не отвечает нескольким требованиям, по каждому из них будет отдельное сообщение. Но результатом работы этого валидатора все равно будет одна строка с сообщением об ошибке. Поэтому в `glue` можно указать, чем склеить все сообщения в одну строку.

#### required

Тут достаточно просто `true`. Если требуется свое сообщение, тогда описываем массив ['message' => '...']. Пример:

```PHP
...
'login' => [
    'validators' => [
        'required' => true,
    ],
],

'mail' => [
    'validators' => [
        'required' => ['message' => 'Укажите email, пожалуйста'],
    ],
],
...
```

Если сообщение не задано явно, будет дефолтное, прописанное в валидаторе.


В этом валидаторе опционально выполняется строгая проверка: строка не состоит только из пробелов, а если валидируем массив, то в нем есть не NULL элементы. Т.е. с одной стороны, такие значения не нарушают требование "обязательного значения в поле", с другой же - бессмысленно принимать невидимые значения.

По умолчанию включен строгий режим проверки, т.к. это более востребовано. Режим переключается через параметр валидатора `strict`. Например:

```
'required' => [
    'strict' => false,
    'message' => 'Хотя бы что-то в поле должно быть написано'
]
```

#### typecast

Валидатор приведения значения к типу. Использует одноименную утилиту `kira\utils\Typecast` и позволяет задать свое сообщение об ошибке, если приведение к типу не удалось. Валидатор придуман для сокращения размеров контракта, тоже самое можно описать через валидатор `filter_var`, но с бОльшим числом параметров.

Обязательный параметр - `type`. Если свое сообщение об ошибке не нужно, то в просто указываем требуемый тип, как единственное значение в описании валидатора. Допустимые типы описаны в константах `kira\validation\validators\Typecast`.

Примеры настройки валидатора:

```php
use kira\validation\validators\Typecast;
...
'userName' => [
    'validators' => [
        'typecast' => Typecast::STRING // Константа в классе валидатора, не в одноменной утилите

        // или

        'typecast' => [
            'type' => Typecast::STRING,
            'message' => 'Имя юзера должно быть задано строкой',
        ],
    ],
]
```

## Непосредственный вызов валидатора

Валидаторы можно вызывать напрямую, хотя это не приветствуется. Тем не менее, вот пример, как с ними можно работать:

```php
$idValidator = (new \kira\validation\validators\ExpectId([
    'message' => 'Неверный ID пользователя';
]));

$userId = \kira\Request::get('userId');

if ($idValidator->validate($userId)) {
    return $idValidator->value;
} else {
    throw new \kira\exceptions\FormException($idValidator->error);
}
```

Важно отметить, что валидатор нигде не хранит результат своей работы, только возвращает его из `validate()`. Если нужно запомнить результат проверки, делайте это на клиентской стороне или просто используйте контракты и модель формы, а не валидаторы напрямую.

*Прим: сообщение об ошибке `AbstractValidator::$error` может хранить подготовленный текст сразу же после создания объекта валидатора. Более того, это сообщение может вообще быть пустым, если так будет настроен валидатор. Поэтому нельзя полагаться на него для получения результата валидации.*
