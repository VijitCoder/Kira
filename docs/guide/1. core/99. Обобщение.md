# Обобщение

Тут собрана информация по классам движка, для которых было лень писать подробное описание :) Так же вы можете сгенерировать API документацию для получения полного описания всех классов и методов движка. См. док *"API документация"*

## Самый главный скрипт :)

Класс `\kira\core\App`

Не смотря на свою важность, он хранит только очень общие методы: переводчик, чтение конфига, получение экземпляров роутера, логера и т.п. Так же в нем размещены константы **VERSION** и **ENGINE_URL** для обозначения движка.

Пара методов для запоминания/получения объекта автозагрузчика Composer нужна роутеру движка. Возможно в конкретном приложении появится и другие поводы обращаться к автозагрузчику.

**App::router()**. Роутер движка может быть заменен частной реализацией, в которой согласно AbstractRouter должна быть своя реализация метода url(). Чтобы в клиентском коде не выяснять, кто - текущий роутер, введена эта функция.

**App::loger()**. В зависимости от настроек и доступности базы, логирование может вестись в БД или файлы. Если таблица окажется недоступна, будем сбрасывать логи в файлы. Чтоб в течение работы приложения не выяснять на каждом логе факт доступности базы, используем этот геттер.

## Контроллер

Класс `\kira\web\Controller`

Примечательны все его публичные методы.

В кратце: класс занимается отрисовкой шаблонов и выдачей результата в браузер, метод `Controller::render()`. Шаблон вставляется в макет, так же можно обойтись без вставки используя `Controller::renderPartial()`.

Непосредственно перед и после отрисовки шаблона с макетом вызываются два доп.метода `Controller::beforeRender()` и `Controller::afterRender()` соответственно. Для отрисовки шаблона без макета нет подобных методов, они не имеют смысла.

Из контроллера можно организовать редирект.

Для передачи отрисованного шаблона в макет используется переменная `$CONTENT`. Непринято писать переменные большими буквами, и здесь это сделано специально во избежание случайных совпадений с уже имеющимися переменными шаблона.

Так же в переменных шаблона нельзя использовать `$_view123`. Эта переменная занята внутренним механизмом отрисовки шаблона.

## Request

Класс `\kira\net\Request`

Запрос клиента. В PECL есть расширение с похожим назначением [httprequest](http://php.net/manual/en/class.httprequest.php) Но допустим, нам так много не нужно :)

Кроме прочих полезных методов, класс содержит кучу однотипных методов для получения типизированнного значения из суперглобальных переменных $_GET, $_POST, $_COOKIE и $_REQUEST. Логика у них одинаковая, реализация оформлена в магическом методе. Удобство этих методов том, что в клиентском коде не придется проверять значение из массива на существование и/или приводить его к конкретному типу данных.

Ниже говорю о $_POST, но это в равной степени относится к остальным суперглобальным переменным.

Для получения значения используется функция `kira\utils\Arrays::getValue()`, что позволяет доставать значение из вложенных массивов, наприимер `Request::post(['deep' => ['nested' => 'key']])` - получение значения с 3-го уровня массива.

В $_POST в качестве **значения параметра** можно передать массив (не путать с вложенным массивом **ключей**). Со значениями-массивами методы приведения к типу не работают, всегда будет `NULL`.

---

Отмечу отдельно:

function __isMobileBrowser()__: _bool_

Проверяем, что запрос пришел с мобильного браузера.

Это не то же самое, что "мобильная версия сайта" (см. `kira\web\Env::isMobile()`). Данный метод можно использовать для *"responsive"* верстки. Например, подключать какие-то особые js-скрипты.

---

Защита от CSRF-атак представлена тремя методами: `createCsrfToken()`, `getCsrfToken()` и `validateCsrfToken()`. Сгенерированный токен сохраняется в cookie `CSRF_TOKEN`. Именно в cookie, а в не сессию, тогда через javascript ее можно без костылей прочитать, что выгодно при отправке формы ajax-ом.

## Response

Класс `\kira\net\Response`

Ответ клиенту. Вынес в отдельный параметр HTTP-код ответа для удобства. Чтобы ответить, придется создать объект класса. Пример:

```php
(new Respose(404))->send('Страница не найдена');
```

Кроме динамических методов, завязанных на код ответа, класс содержит несколько статических методов.

Заметки по методу `Response::redirect()`:

- указание абсолютного URL - требование спецификации HTTP/1.1, <http://php.net/manual/ru/function.header.php>
- Быстрая справка по кодам с редиректом <http://php.net/manual/ru/function.header.php#78470>
- Хитрый редирект создан на основе комментария <http://php.net/manual/ru/function.headers-sent.php#60450>

---

function __download($file)__

По теме полезно почитать [это](http://php.net/manual/ru/function.readfile.php) и [это](http://ru.wikipedia.org/wiki/Chunked_transfer_encoding)

По-хорошему нужно в Content-type передавать реальный MIME файла. Для определения использовать, например, php-расширение "fileinfo". Но современные браузеры прекрасно распознают многие типы файлов и не скачивают их, а открывают. Функция же создана для принудительного скачивания. Поэтому по любому файлу сообщаем "Content-type: application/octet-stream".

**Обязательно объявлять размер!** (реализовано в функции). Иначе отправляется `Transfer-Encoding: chunked`, что приводит к неполной загрузке файла, если в нем обнаруживается CRLF.

## Session

Класс `\kira\net\Session`

Работа с сессией. Открыть, закрыть, прочитать, записать, удалить.

#### Набор методов для flash-сообщений

Флеш-сообщения - это такие сообщения, которые передаются между двумя обращениями юзера к серверу или между несвязанными классами. Как правило, само сообщение выдается в браузер через шаблон, своим особым оформлением привлекая внимание юзера (flash).

Пример: некий сервис проверил, что юзер не подтвердил свое мыло. Пишем ему напоминание в виде флеш-сообщения, которое будет обработано только в коде шаблона.

Проще один раз увидеть :) Вот полный код шаблона, который можно подключать в другие шаблоны для показа flash-сообщений (файл `_flash.htm`).

```PHP
<?php
/**
 * Сообщения юзеру от сервера
 */

use kira\net\Session;

/*
// Тесты
Session::addFlash('errAuth', 'Пример ошибки. <a href="">Пройдите в авторизацию</a>');
Session::addFlash('warnWtf', 'варнинг');
Session::addFlash('infoAccess', 'информационное');
Session::addFlash('warnAnother', '2й варнинг');
Session::addFlash('some', 'Просто сообщение');
*/

$flashes = Session::readFlashes();

if($flashes) {
    ksort($flashes);
    //Есть 4 типа: ошибка, инфо и предупреждение (err, info, warn) и любое другое значение.
    $type = $curType = '';
    foreach ($flashes as $key => $msg) {

        if (preg_match('/^(err|info|warn)/ui', $key, $m)) {
            $curType = $m[1];
        } else {
            $curType = 'msg'; //общее значение. Подойдет любой непустой текст.
        }

        //если меняется тип сообщения
        if ($type != $curType) {
            if ($type) {
                echo '</div>'; //закрываем предыдущий блок
            }
            echo "<div class='user-flash uf-{$curType}'>";
            $type = $curType;
        }

        echo $msg . '<br>';
    }
    echo '</div>'; //закрываем последний блок
}
```

Стили

```CSS
.user-flash {
    padding: 10px;
    margin: 10px 0;
    text-align: left;
    border: 2px solid #e0ce95;
 }
.uf-err  { background-color: rgba(255, 0, 0, .2); }
.uf-info { background-color: rgba(0, 255, 0, .2); }
.uf-warn { background-color: rgba(255, 255, 0, .3); }
.uf-msg  { background-color: rgba(0, 150, 255, .2); } /* нетипизированное сообщение */

```

Раскомментируйте тесты, и подключите его в своем шаблоне. Потом зайдите на страницу и будет магия :) Конечно, в обычной ситуация вызовы `Session::addFlash()` будут выполняться где-то в глубинах кода, а не в том же шаблоне, где и чтение этих сообщений.

## Registry

Класс `\kira\utils\Registry`

Глобальное хранилище приложения во время его выполнения.

Реализация шаблонов проектирования Singleton, Registry + доп.фичи.

Главное отличие от класса `kira\core\App`: здесь хранятся **клиентские по отношению к движку данные**. А данные, от которых движок зависит, или которые он гарантирует клиентскому коду, хранятся в `App`. Поэтому бесполезно тут искать конфиг или логер или что-то подобное. Т.е. объект реестра может вообще быть не востребован в приложении.

Несмотря на то, что класс - "одиночка" (Singleton), разрешена его сериализация/десериализация. Такое допущение сделано в целях сохранения состояния реестра и его восстановления. Можно было заморочиться, как например описано в [этой статье](http://i-novice.net/shablon-proektirovaniya-reestr/). Я решил, что в моей реализации хранение нескольких состояний реестра не требуется на данный момент.

Еще доп. фича: к реестру можно применять array\_\* методы. Пример:

```PHP
$regKeys = App::registry()->array_keys(); // все ключи из хранилища реестра
```

Кстати, нет короткого способа обратиться к реестру. Я не придумал, как это сделать красиво и в то же время - коротко. Есть такие идеи: прям в `index.php` приложения присвоить переменной `$reg = Registry::getInstance()`. Она будет в глобальном scope, используйте где угодно. Другой вариант - завести (опять же глобально) функцию-обертку с вызовом реестра. Пример есть в `bootstrap.php` функция `dd()`. Есть обертка `App::registry()`, но это не значительно короче, разница только в чтении кода. Может так будет удобно.

## Системые функции

`system_functions.php`

Маленький (пока) скрипт в корне движка. Советую заглянуть, может пригодится в разработке.
