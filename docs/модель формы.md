# Модель формы. Валидация форм

Класс `kira\web\From`. Сам по себе не используется, клиентские модели форм должны наследовать от него.

Возможности модели форм в этом движке:

- любая вложенность исходных данных
- валидация массива однородных данных одним правилом
- любое количество валидаторов на конкретное значение. Есть ограничение на количество валидаторов по типу, см. ниже.
- свои сообщения об ошибках от любого валидатора

Пример использования модели формы:

```PHP
$form = new SomeForm;
if ($form->load($_POST)->validate()) {
...
} else {
    $errors = $form->getErrors();
}
```


*Прим: иногда для маленьких форм невыгодно заводить модель. Валидировать значения можно так же через серию методов `kira\net\Request`, см. функции класса `get()`, `post()`, `cookie()`, `request()` и их производные.*

## Структура контракта

Основное понятие - **контракт на поля формы**. Это массив с именами полей и списком валидаторов для их проверки.

**Важно:** служебное слово `validators` занято в описании контракта. Названия полей формы не должны сопадать с этим словом, иначе результат непредсказуем. Зачем оно: механизм валидации поддерживает *многомерные массивы с описанием полей*. Без явного указания через `validators` в многомерном массиве невозможно отличить, где иерархия имени поля, а где - валидаторы.

Формы могут быть любой сложности и вложенности данных. Контракт должен повторять иерархию вложенности данных. Рассмотрим на примере сложной html-формы с большой вложенностью данных:

```html
<form method="POST" action="create">
    <input type="text" value="test" name="inp0">

    <input type="text" value="test1" name="inp1[]">
    <input type="text" value="test2" name="inp1[]">
    <input type="text" value="test3" name="inp1[]">

    <input type="text" value="test4" name="inp2[one]">
    <input type="text" value="test5" name="inp2[two]">

    <input type="text" value="test6" name="inp3[lvl1][lvl11]">
    <input type="text" value="test7" name="inp3[lvl1][lvl12]">
    <input type="text" value="test8" name="inp3[lvl1][lvl12][lvl121]">
    <input type="submit">
</form>
```

Дамп переменной $_POST:

```PHP
array
(
    'inp0' => 'test'
    'inp1' => array
    (
        0 => 'test1'
        1 => 'test2'
        2 => 'test3'
    )
    'inp2' => array
    (
        'one' => 'test4'
        'two' => 'test5'
    )
    'inp3' => array
    (
        'lvl1' => array
        (
            'lvl11' => 'test6'
            'lvl12' => array   // обратите внимание: "test7" отсутствует
            (
                'lvl121' => 'test8'
            )
        )
    )
)
```

Пример контракта на поля формы:

```PHP
class SomeForm extends kira\utils\Form {
    protected $contract = [
        'inp0' => [
            'validators' => [          // здесь три валидатора разных типов
                'required' => true,

                'filter_var' => [
                    'filter'  => FILTER_VALIDATE_REGEXP,
                    'options' => ['regexp' => '~^[a-z0-9-_]+$~i'],
                    'message' => 'Недопустимые символы в логине',
                ],

                'length' => ['min' => 5, 'max' => 30,],
            ],
        ],

        'inp1' => [
            'validators' => [
                'expect_array' => true,     // обязательный флаг для обработки массивов данных
                'filter_var' => [
                    'filter'     => FILTER_CALLBACK,
                    'options'    => ['\kira\utils\Validators', 'normalizeString'],
                ],
            ],
         ]

        'inp2' => [
            'validators' => [
                'expect_array' => true,
                ...
            ],
        ],

        'inp3' => [
            'lvl1' => [
                'lvl11' => [
                    'validators' => ['required' => true,],
                ],
                'lvl12' => [
                    'lvl121' => null,  // принять без валидации
                ],
            ],
        ],
    ];
}
```

Валидаторы могут быть назначены только на конечный узел иерархии, т.е. на данные конкретного поля формы. Валидаторы описываются в отдельном ассоциативном массиве с ключом `validators`. В свою очередь ключи такого массива - конкретные типы валидаторов, значения массива - параметры валидаторов.

Если валидация поля не нужна, пишем `null` в качестве значения.

Для простых форм требуемое описание контракта может казаться излишне сложным. Тем не менее такой подход оправдан, т.к. поддерживается единый интерфейс контракта для форм любой сложности. Один раз разобраться и потом можно читать и править любую модель. Это лучше, чем если бы я ввел еще и "легкую" версию контракта и шарить пришлось бы в двух интерфейсах.

## Валидаторы

**Важно:** валидаторы могут быть разных типов. На одно проверяемое значение нельзя повешать два валидатора одного типа. Это очевидно, т.к. тип задается в ключе массива валидаторов и повторное его использование перепишет предыдущее значение в массиве.

К типовым валидаторам нельзя ничего добавить. Но создать и использовать свои функции валидации конечно можно. Для этого служат тип `filter_var` со значением `'filter'  => FILTER_CALLBACK` и тип `external` (см. ниже).

## expect_array

Особый валидатор, позволяющий применить все остальные валидаторы к проверяемому значению, как к массиву данных.

Контракт на конкретное поле представляет собой массив. Данные из поля так же могут быть массивом. Диллема такая: без явного указания нельзя знать наверняка, ожидается массив данных или единичное значение.

Можно конечно добавить анализатор, но получится такая засада: любой массив будет принят, как ожидаемый. И допустим, корректно провалидировано каждое его значение. Возвращаем его в клиентский код и.. ошибка! Код ожидал тут единственное значение, а мы ему массив отдали. В нормальной ситуации так не будет конечно, код получит что ожидает, но в качестве попытки уронить сайт вполне можно подпихнуть массив вместо одного значения.

Выход: вводим отдельный валидатор (`bool)expect_array`. Несоответствие ожиданиям считаем невалидным значением. Т.е. неверный тип данных может в итоге привести к ошибке остальных валидаторов. Поэтому отмечаем такое значение не валидным без каких-либо проверок, пишем в соообщении об ошибках, в чем суть проблемы.

Очевидно, что при валидации массива не имеет смысла задавать конкретные сообщения об ошибках, т.к. для каждого невалидного значения будет использовано указанное сообщение.

По умолчанию `expect_array` равно `false`, т.е. в каждом поле ожидаем единичное значение, не массив.

На этот валидатор нельзя назначить свое сообщение об ошибке. На остальные - можно.

### filter_var

Описывается по правилам [php::filter_var()](http://php.net/manual/ru/function.filter-var.php), для валидации будет вызвана именно эта функция. Обязательный элемент - `filter`, мое дополнение - `message`. Пример:

```PHP
...
'login' => [
    'validators' => [
        'filter_var' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => [
                'default' => 'uknown',
                'regexp' => '~^[a-z0-9-_]+$~i'
            ],
            'flags' => null, // для этого типа фильтра нет флагов. Но для фильтров, где флаги возможны, описывать тут
            'message' => 'Недопустимые символы в логине',
        ],
    ],
],
...
```

Некоторые фильтры позволяют задать значение по умолчанию через `options['defalut']`. Если оно есть, то в случае неудачи функция возвращает это значение, а не `FALSE`. Основной метод валидации воспримет такую ситуацию, как успешную и запишет полученное значение в проверенные данные. Я думаю, это логично: кодер указал, что принимать по умолчанию. Следовательно он не хочет ошибку валидации.

Некоторые фильтры поддерживают настройку через флаги. Такие значения передавать через ключ `flags` **рядом** с `options` (см. пример в этом разделе). Если фильтр не поддерживает флаги или их использование не требуется, то в контракте их можно вообще не описывать.

### external

Описывается по правилам [php::call_user_func()](http://php.net/manual/ru/function.call-user-func.php). Обязательный элемент - `function`. В `options` можно задать доп.параметры в функцию. Они будут переданы массивом. Пример:

```PHP
...
'password' => [
    'validators' => [
        'external' => [
            'function'   => ['\kira\utils\Validators', 'password'],
            'options'  => [
                'min_len'  => 5,
                'min_comb' => 3,
            ],
        ],
    ],
],
...
```

Некоторые внешние валидаторы можно найти в `\kira\utils\Validators`. Смотрите комментарии к методам.

Можно создавать свои валидаторы для такого типа подключения. Сигнатура функции:

```PHP
/**
 * @param mixed $value   проверяемое значение
 * @param array $options доп.параметры валидатора, если они есть.
 * @return array ['error' => mixed] | ['value' => mixed]
 */
function someFunc(mixed $value, [array $options]): array
```

Функция должна вернуть ассоциативный массив либо с текстом(ми) ошибки либо с валидированным значением.

### required

Тут достаточно просто `true`. Если требуется свое сообщение, тогда и пишем ['message' => 'Требуется заполнить ...']. Пример:

```PHP
...
'login' => [
    'validators' => [
        'required' => true,
    ],
],

'mail' => [
    'validators' => [
        'required' => ['message' => 'Укажите email, пожалуйста'],
    ],
],
...
```

Если сообщение не задано явно, будет типовое.

### length

Для проверки длины строки. Два элемента в массиве - [min, max]. Любой из них можно опустить. Можно задать свое сообщение. Если его нет, будет типовое.

Главное удобство этого валидатора в возможности задать свое сообщение именно на нарушение границ длины строки. Если свое сообщение не требуется, зачастую контроль длины можно совместить с регуляркой в `filter_var` и выдавать что-нибудь общее в качестве сообщения.

### bounds

Для проверки мин/макс значений чисел, включая отрицательные и с плавающей точкой. Так же, как в `length`, две опции [min, max]. Можно задать свое сообщение. Если его нет, будет типовое.

### expect_id

Валидатор проверяет значение, как целое положительное число. Валидатор имеет только одну настройку - `message`. Если указаное любое другое значение/тип в качестве настроек валидатора, оно будет воспринято просто как указание использовать валидатор.

Пример использования:

```php
$contract = [
    'id' => [
        'validators' => [except_id => null] // валидатор будет вызван, сообщение об ошибке - по умолчанию
    ],
    'userId' => [
        'validators' => [except_id => ['message' => 'Неверный id пользователя']]
    ],
    'page' => [
        'validators' => [except_id => ['message' => 'Неверный номер страницы']]
    ],
];
```

#### Сообщения

Любой валидатор может сопровождаться своим сообщением. Так же внешние валидаторы, подключаемые через `external`, могут возвращать свои сообщения. Если сообщение указано в контракте, при валидации прогоняем его через переводчик (см. док *"Локализация сайта"*). Сообщения из внешних валидаторов принимаем без перевода.

Сообщение, заданное в контракте для конкретного валидатора, выше приоритетом и заменит сообщение(я) это валидатора.

Встроенные валидаторы `required`, `length` и `bounds` будут возвращать свои типовые сообщения, если в контракте не задано иное. Например: *"Не заполнено необходимое поле"*, так же пропущенное через переводчик.

#### Непосредственный вызов валидатора

Валидаторы можно вызывать напрямую, хотя это не приветствуется. Тем не менее, вот пример, как с ними можно работать:

```php
$idValidator = (new \kira\validation\validators\ExpectId([
    'message' => 'Неверный ID пользователя';
]));

$userId = \kira\Request::get('userId');

if ($idValidator->validate($userId)) {
    return $idValidator->getValidatedValue();
} else {
    throw new \kira\exceptions\FormException($idValidator->getErrorMessage());
}
```

Магические геттеры:

`AbstractValidator::getValidatedValue()` === `AbstractValidator->value`
`AbstractValidator::getErrorMessage()` === `AbstractValidator->error`

Важно отметить, что валидатор нигде не хранит результат своей работы, только возвращает его из `validate()`. Если нужно запомнить результат проверки, делайте это на клиентской стороне или просто используйте контракты и модель формы, а не валидаторы напрямую.

Прим: метод получения сообщения об ошибке `AbstractValidator::getErrorMessage()` просто возвращает подготовленное сообщение, независимо от процесса или результата проверки. Более того, это сообщение может вообще быть пустым, если так будет настроен валидатор. Поэтому нельзя полагаться на него для получения результата валидации.

## Очередь выполнения валидаторов

Самым первым к данным поля формы применяется `required`, (если он задан), причем независимо от его положения в списке валидаторов. Это позволит остальным валидаторам не ругаться на неправильные значения, когда их просто нет. Остальные валидаторы выполняются в порядке очереди. Т.о. следует использовать, например, проверку длины **после** дезинфицирующих фильтров, поскольку длина строки может измениться.

Если очередной валидатор забраковал значение, последующие валидаторы не вызываются. Однако, внутри валидатора можно выполнить несколько проверок и вернуть несколько ошибок сразу. Отличный пример - валидация пароля:

```PHP
'password' => [
    'validators' => [
        'external' => [
            'function' => ['\kira\utils\Validators', 'password'],
            'options'  => [
                'min_len'  => 5,
                'min_comb' => 3,
            ],
        ],

        'length' => ['max' => 30,],
    ],
],
```

Если проверка пароля внешним валидатором не пройдет, он может вернуть несколько сообщений. При этом последующая проверка максимальной длины уже не выполняется.

## Структура модели формы

После вызова конструктора модели ее уже можно использовать на веб-формах. Это удобно, когда предполагается повторное заполнение формы данными при ошибках валидации. Логика такая: пишем шаблон со вставками данных из модели формы. Контроллер создает экземпляр модели и передает его в шаблон. Все. Не нужно в шаблоне проверять наличие поля через `isset()`. Все поля есть согласно описания контракта. Все данные в них равны `null`.

Чтобы проверить полученные данные, их нужно загрузить в модель. Для этого служит метод

```PHP
function load(array &$data):From
```

Эти данные будут сохранены, как "сырые": передаваемый на загрузку массив никак не изменяется и даже сохранятся элементы, не заявленные в контракте.

Метод возвращает объект текущей модели, что позволяет выполнить вызвов следующего метода по цепочке.

Собственно проверка вызывается методом

```PHP
function validate():bool
```

---

Модель формы хранит три массива, соответствующие иерархии исходных данных:

- Сырые данные. Это все, что было передано в модель. Как есть, без валидации, независимо от полей контракта.
- Проверенные данные. В этот массив попадет только то, что **заявлено в контракте** и прошло валидацию.
Очередной валидатор меняет тут значение только в случае успешной проверки (если конечно предполагается такое изменение). Иначе значение остается таким, каким было получено на вход валидатора. Такой подход позволит комбинировать выдачу юзеру. Можно вернуть текущее значение и указать на ошибку.
- Ошибки. В массив ошибок можно добавлять свои из клиентского кода.

Для получения данных из этих массивов используются соответственно

```PHP
function getRawData([string $key]):mixed
function getValues([string $key]):mixed
function getErrors([string $key]):array
```

Параметр `$key` необязателен. Если не задан - возвращается весь массив. Если задан, возвращается **подмассив первого уровня иерархии данных**. Получить данные с подуровней несложно, но как описать ключ в таком случае? Поэтому только первый уровень.

*Прим: для сборки всех ошибок в строку из многомерного массива может оказаться полезной функция `kira\utils\Arrays::implode_recursive()`. Подробности - в комментарии к функции.*

Проверенные данные хранятся в отдельном массиве.

#### Дополнительные функции модели

```PHP
function addError(array $message):void
```

Добавление своего сообщения в массив ошибок. Ключ в массиве - имя поля, значение - собственно сообщение. В случае многомерного массива описывается полный путь вложений к требуемому полю и потом сообщение.

---

```PHP
function hasErrors():bool
```

Проверка, есть ли какие-то ошибки. Не обязательно ошибки валидации. Такое возможно, учитывая использование метода `addError()`.

---

```PHP
function isValid():bool
```

Получение информации о результате валидации. Очевидно, что вызывать такой метод имеет смысл только после вызова `validate()`.

---

```PHP
function setValue(array $value):void
```

Свое значение в массив **валидированных** данных. Если значение нужно разместить в многоуровневом массиве, пишем всю вложенность ключей и новое значение на нужном уровне. Старое значение будет переписано, если оно есть. Наличие поля не проверяется, что дает больше возможностей для управления массивом итоговых данных.

## Защита от CSRF атаки

В модели формы есть свойство `$csrfField`. В него пишем имя поля формы, в котором будем передавать CSRF-токен. Само значение получаем через методы `Request::createCsrfToken()` или `Request::getCsrfToken()`, см. класс `\kira\net\Request`. Прописываем токен в шаблоне формы в заявленном поле. Все.

Токен проверяется при валидации формы, непосредственно перед валидацией полей. Если токен не пройдет проверку, будет проброшено исключение `FormException` с кодом 400. Именно исключение, а не просто ошибка валидации, т.к. токен не зависит от действий юзера, это скорее сбой приложения, реакция соответствующая. Код передается для удобства, клиентское приложение может по-своему реагировать на такое исключение.

*Прим: код 400 взят по аналогии с HTTP-кодом "400 Bad request".*

Проверка токена возможна только в GET и POST запросах. Если в `$csrfField` пусто, проверка не выполняется.

Токен хранится в cookie *CSRF_TOKEN*. Использование печеньки несколько ослабляет безопасность (если хакер как-то сможет получить доступ к cookies жертвы). Удобство же в том, что можно легко добавить токен в ajax-передачу формы, достаточно только прочитать его из печеньки.

## Исключения

Модель формы или супер-класс валидатора пробрасывает исключение `kira\exceptions\FormException`. В основном все случаи исключения такого типа указывают на неверное использование функционала (ошибка кодера). Один уникальный случай: проверка CSRF-токена. Если проверка не пройдет, будет `FormException` с кодом 400.

## Магический доступ к полям формы

Есть геттер и сеттер для доступа к полям формы. Доступны только поля, перечисленные в контракте, иначе будет исключение. Через магию оперируем с массивом валидированных значений. Если поля формы - многомерный массив, то на вложенные уровни нельзя попасть через магию. Простой пример:

```php
class LoginForm
{
    protected $contract = [
        'login' => [
            'validators' => [...]
        ],
        'password' => [
            'validators' => [...]
        ],
    ];
}

$form = new LoginForm->load(Request::get());
if ($form->validate()) {
    dd($form->login, $form->password); // магический доступ к валидированным значениям
    $form->rememberMe = true;          // будет исключение, такого поля нет в контракте
}
```

## Нерешенные вопросы

Если поле в контракте - необязательное и его нет в проверяемых данных, то его значение будет равно NULL. Т.е. его можно будет получить через `Form::getValues()`, но только NULL. А что, если мне нужно для таких полей задать дефолтные значения, если дял них не передали данные? Пока я не придумал решения, красивого и при этом понятного с клиентской точки зрения.
