# Модель формы. Валидация форм

Класс `kira\web\From`. Сам по себе не используется, клиентские модели форм должны наследовать от него.

Возможности модели форм в этом движке:

- любая вложенность исходных данных
- валидация массива однородных данных одним правилом
- любое количество валидаторов на конкретное значение. Есть ограничение на количество валидаторов по типу, см. ниже.
- свои сообщения об ошибках от любого валидатора

Пример использования модели формы:

```PHP
$form = new SomeForm;
if ($form->load($_POST)->validate()) {
...
} else {
    $errors = $form->getErrors();
}
```


*Прим: иногда для маленьких форм невыгодно заводить модель. Валидировать значения можно так же через серию методов `kira\net\Request`, см. функции класса `get()`, `post()`, `cookie()`, `request()` и их производные.*

## Структура контракта

Основное понятие - **контракт на поля формы**. Это массив с именами полей и списком валидаторов для их проверки.

**Важно:** фразы `expectArray` и `validators` заняты в описании контракта. Названия полей формы не должны сопадать с этими фразами, иначе результат непредсказуем.

Формы могут быть любой сложности и вложенности данных. Контракт должен повторять иерархию вложенности данных. Рассмотрим на примере сложной html-формы с большой вложенностью данных:

```html
<form method="POST" action="create">
    <input type="text" value="test" name="inp0">

    <input type="text" value="test1" name="inp1[]">
    <input type="text" value="test2" name="inp1[]">
    <input type="text" value="test3" name="inp1[]">

    <input type="text" value="test4" name="inp2[one]">
    <input type="text" value="test5" name="inp2[two]">

    <input type="text" value="test6" name="inp3[lvl1][lvl11]">
    <input type="text" value="test7" name="inp3[lvl1][lvl12]">
    <input type="text" value="test8" name="inp3[lvl1][lvl12][lvl121]">
    <input type="submit">
</form>
```

Дамп переменной $_POST:

```PHP
array
(
    'inp0' => 'test'
    'inp1' => array
    (
        0 => 'test1'
        1 => 'test2'
        2 => 'test3'
    )
    'inp2' => array
    (
        'one' => 'test4'
        'two' => 'test5'
    )
    'inp3' => array
    (
        'lvl1' => array
        (
            'lvl11' => 'test6'
            'lvl12' => array   // обратите внимание: "test7" отсутствует
            (
                'lvl121' => 'test8'
            )
        )
    )
)
```

Пример контракта на поля формы:

```PHP
class SomeForm extends kira\utils\Form {
    protected $contract = [
        'inp0' => [
            'validators' => [          // здесь три валидатора разных типов
                'required' => true,

                'filter_var' => [
                    'filter'  => FILTER_VALIDATE_REGEXP,
                    'options' => ['regexp' => '~^[a-z0-9-_]+$~i'],
                    'message' => 'Недопустимые символы в логине',
                ],

                'length' => ['min' => 5, 'max' => 30,],
            ],
        ],

        'inp1' => [
            'expectArray' => true,     // обязательный флаг для обработки массивов данных
            ['validators' => [
                    'filter_var' => [
                    'filter'     => FILTER_CALLBACK,
                    'options'    => ['\kira\utils\Validators', 'normalizeString'],
                ],
            ],
        ]

        'inp2' => [
            'expectArray' => true,
            ['validators' => [...],],
        ]

        'inp3' => [
            'lvl1' => [
                'lvl11' => [
                    'validators' => ['required' => true,],
                ],
                'lvl12' => [
                    'lvl121' => null,  // принять без валидации
                ],
            ],
        ],
    ];
}
```

Валидаторы могут быть назначены только на конечный узел иерархии, т.е. на данные конкретного поля формы. Валидаторы описываются в отдельном ассоциативном массиве с ключом `validators`. В свою очередь ключи такого массива - конкретные типы валидаторов, значения массива - параметры валидаторов.

Если валидация поля не нужна, пишем `null` в качестве значения.

Для простых форм требуемое описание контракта может казаться излишне сложным. Тем не менее такой подход оправдан, т.к. поддерживается единый интерфейс контракта для форм любой сложности. Один раз разобраться и потом можно читать и править любую модель. Это лучше, чем если бы я ввел еще и "легкую" версию контракта и шарить пришлось бы в двух интерфейсах.

## Типы валидаторов

**Важно:** валидаторы могут быть разных типов. На одно проверяемое значение нельзя повешать два валидатора одного типа. Это очевидно, т.к. тип задается в ключе массива валидаторов и повторное его использование перепишет предыдущее значение в массиве.

### filter_var

Описывается по правилам [php::filter_var()](http://php.net/manual/ru/function.filter-var.php), для валидации будет вызвана именно эта функция. Обязательный элемент - `filter`, мое дополнение - `message`. Пример:

```PHP
...
'login' => [
    'validators' => [
        'filter_var' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => ['regexp' => '~^[a-z0-9-_]+$~i'],
            'message' => 'Недопустимые символы в логине',
        ],
    ],
],
...
```

Некоторые фильтры позволяют задать значение по умолчанию через `options['defalut']`. Если оно есть, то в случае неудачи функция возвращает это значение, а не `FALSE`. Основной метод валидации воспримет такую ситуацию, как успешную и запишет полученное значение в проверенные данные. Я думаю, это логично: кодер указал, что принимать по умолчанию. Следовательно он не хочет ошибку валидации.

### external

Описывается по правилам [php::call_user_func()](http://php.net/manual/ru/function.call-user-func.php). Обязательный элемент - `function`. В `options` можно задать доп.параметры в функцию. Они будут переданы массивом. Пример:

```PHP
...
'password' => [
    'validators' => [
        'external' => [
            'function'   => ['\kira\utils\Validators', 'password'],
            'options'  => [
                'min_len'  => 5,
                'min_comb' => 3,
            ],
        ],
    ],
],
...
```

Некоторые внешние валидаторы можно найти в `\kira\utils\Validators`. Смотрите комментарии к методам.

Можно создавать свои валидаторы для такого типа подключения. Сигнатура функции:

```PHP
/**
 * @param mixed $value   проверяемое значение
 * @param array $options доп.параметры валидатора, если они есть.
 * @return array ['error' => mixed] | ['value' => mixed]
 */
function someFunc(mixed $value, [array $options]): array
```

Функция должна вернуть ассоциативный массив либо с текстом(ми) ошибки либо с валидированным значением.

### required

Тут достаточно просто `true`. Если требуется свое сообщение, тогда и пишем ['message' => 'Требуется заполнить ...']. Пример:

```PHP
...
'login' => [
    'validators' => [
        'required' => true,
    ],
],

'mail' => [
    'validators' => [
        'required' => ['message' => 'Укажите email, пожалуйста'],
    ],
],
...
```

Если сообщение не задано явно, будет типовое.

### length

Для проверки длины строки. Два элемента в массиве - [min, max]. Любой из них можно опустить. Можно задать свое сообщение. Если его нет, будет типовое.

Главное удобство этого валидатора в возможности задать свое сообщение именно на нарушение границ длины строки. Если свое сообщение не требуется, зачастую контроль длины можно совместить с регуляркой в `filter_var` и выдавать что-нибудь общее в качестве сообщения.

### bounds

Для проверки мин/макс значений чисел, включая отрицательные и с плавающей точкой. Так же, как в `length`, две опции [min, max]. Можно задать свое сообщение. Если его нет, будет типовое.

---

К типовым валидаторам нельзя ничего добавить. Но создать и использовать свои функции валидации конечно можно. Для этого служат тип `filter_var` со значением `'filter'  => FILTER_CALLBACK` и тип `external`.

#### Сообщения

Любой валидатор может сопровождаться своим сообщением. Так же внешние валидаторы, подключаемые через `external`, могут возвращать свои сообщения. Если сообщение указано в контракте, при валидации прогоняем его через переводчик (см. док *"Локализация сайта"*). Сообщения из внешних валидаторов принимаем без перевода.

Сообщение, заданное в контракте для конкретного валидатора, выше приоритетом и заменит сообщение(я) это валидатора.

Встроенные валидаторы `required`, `length` и `bounds` будут возвращать свои типовые сообщения, если в контракте не задано иное. Например: *"Не заполнено необходимое поле"*, так же через переводчик.
Любой валидатор может сопровождаться своим сообщением. Так же внешние валидаторы, подключаемые через `external`, могут возвращать свои сообщения. Если сообщение указано в контракте, при валидации прогоняем его через переводчик (см. док *"Локализация сайта"*). Сообщения из внешних валидаторов принимаем без перевода.

Сообщение, заданное в контракте для конкретного валидатора, выше приоритетом и заменит сообщение(я) это валидатора.

Встроенные валидаторы `required`, `length` и `bounds` будут возвращать свои типовые сообщения, если в контракте не задано иное. Например: *"Не заполнено необходимое поле"*, так же через переводчик.

## Очередь выполнения валидаторов

Самым первым к данным поля формы применяется `required`, (если он задан), причем независимо от его положения в списке валидаторов. Это позволит остальным валидаторам не ругаться на неправильные значения, когда их просто нет. Остальные валидаторы выполняются в порядке очереди. Т.о. следует использовать, например, проверку длины **после** дезинфицирующих фильтров, поскольку длина строки может измениться.

Если очередной валидатор забраковал значение, последующие валидаторы не вызываются. Однако, внутри валидатора можно выполнить несколько проверок и вернуть несколько ошибок сразу. Отличный пример - валидация пароля:

```PHP
'password' => [
    'validators' => [
        'external' => [
            'function' => ['\kira\utils\Validators', 'password'],
            'options'  => [
                'min_len'  => 5,
                'min_comb' => 3,
            ],
        ],

        'length' => ['max' => 30,],
    ],
],
```

Если проверка пароля внешним валидатором не пройдет, он может вернуть несколько сообщений. При этом последующая проверка максимальной длины уже не выполняется.

## Валидация массива данных

Контракт на конкретное поле представляет собой массив. Данные из поля так же могут быть массивом. Диллема такая: без явного указания нельзя знать наверняка, ожидается массив данных или единичное значение.

Можно конечно добавить анализатор, но получится такая засада: любой массив будет принят, как ожидаемый. И допустим, корректно провалидировано каждое его значение. Возвращаем его в клиентский код и.. ошибка! Код ожидал тут единственное значение, а мы ему массив отдали. В нормальной ситуации так не будет конечно, код получит что ожидает, но в качестве попытки уронить сайт вполне можно подпихнуть массив вместо одного значения.

Выход: вводим отдельный парамер (`bool)expectArray`. Несоответствие ожиданиям считаем невалидным значением. Т.е. неверный тип данных может в итоге привести к ошибке валидаторов. Поэтому отмечаем такое значение не валидным без каких-либо проверок, пишем в соообщении об ошибках, в чем суть проблемы.

**Параметр `expectArray` нужен, только для конечных узлов с заданными валидаторами.** Т.е. не нужно поднимать этот флаг в ветке, просто содержащей подмассивы контракта.

Очевидно, что при валидации массива не имеет смысла задавать конкретные сообщения об ошибках, т.к. для каждого невалидного значения будет использовано указанное сообщение.

## Структура модели формы

После вызова конструктора модели ее уже можно использовать на веб-формах. Это удобно, когда предполагается повторное заполнение формы данными при ошибках валидации. Логика такая: пишем шаблон со вставками данных из модели формы. Контроллер создает экземпляр модели и передает его в шаблон. Все. Не нужно в шаблоне проверять наличие поля через `isset()`. Все поля есть согласно описания контракта. Все данные в них равны `null`.

Чтобы проверить полученные данные, их нужно загрузить в модель. Для этого служит метод

```PHP
function load(array &$data):From
```

Эти данные будут сохранены, как "сырые": передаваемый на загрузку массив никак не изменяется и даже сохранятся элементы, не заявленные в контракте.

Метод возвращает объект текущей модели, что позволяет выполнить вызвов следующего метода по цепочке.

Собственно проверка вызывается методом

```PHP
function validate():bool
```

---

Модель формы хранит три массива, соответствующие иерархии исходных данных:

- Сырые данные. Это все, что было передано в модель. Как есть, без валидации, независимо от полей контракта.
- Проверенные данные. В этот массив попадет только то, что **заявлено в контракте** и прошло валидацию.
Очередной валидатор меняет тут значение только в случае успешной проверки (если конечно предполагается такое изменение). Иначе значение остается таким, каким было получено на вход валидатора. Такой подход позволит комбинировать выдачу юзеру. Можно вернуть текущее значение и указать на ошибку.
- Ошибки. В массив ошибок можно добавлять свои из клиентского кода.

Для получения данных из этих массивов используются соответственно

```PHP
function getRawData([string $key]):mixed
function getValues([string $key]):mixed
function getErrors([string $key]):array
```

Параметр `$key` необязателен. Если не задан - возвращается весь массив. Если задан, возвращается **подмассив первого уровня иерархии данных**. Получить данные с подуровней несложно, но как описать ключ в таком случае? Поэтому только первый уровень.

*Прим: для сборки всех ошибок в строку из многомерного массива может оказаться полезной функция `kira\utils\Arrays::implode_recursive()`. Подробности - в комментарии к функции.*

Проверенные данные хранятся в отдельном массиве.

#### Дополнительные функции модели

```PHP
function addError(array $message):void
```

Добавление своего сообщения в массив ошибок. Ключ в массиве - имя поля, значение - собственно сообщение. В случае многомерного массива описывается полный путь вложений к требуемому полю и потом сообщение.

---

```PHP
function hasErrors():bool
```

Проверка, есть ли какие-то ошибки. Не обязательно ошибки валидации. Такое возможно, учитывая использование метода `addError()`.

---

```PHP
function isValid():bool
```

Получение информации о результате валидации. Очевидно, что вызывать такой метод имеет смысл только после вызова `validate()`.

---

```PHP
function setValue(array $value):void
```

Свое значение в массив **валидированных** данных. Если значение нужно разместить в многоуровневом массиве, пишем всю вложенность ключей и новое значение на нужном уровне. Старое значение будет переписано, если оно есть. Наличие поля не проверяется, что дает больше возможностей для управления массивом итоговых данных.

## Защита от CSRF атаки

В модели формы есть свойство `$csrfField`. В него пишем имя поля формы, в котором будем передавать CSRF-токен. Само значение получаем через методы `Request::createCsrfToken()` или `Request::getCsrfToken()`, см. класс `\kira\net\Request`. Прописываем токен в шаблоне формы в заявленном поле. Все.

Токен проверяется при валидации формы, непосредственно перед валидацией полей. Если токен не пройдет проверку, будет проброшено исключение `FormException` с кодом 400. Именно исключение, а не просто ошибка валидации, т.к. токен не зависит от действий юзера, это скорее сбой приложения, реакция соответствующая. Код передается для удобства, клиентское приложение может по-своему реагировать на такое исключение.

*Прим: код 400 взят по аналогии с HTTP-кодом "400 Bad request".*

Проверка токена возможна только в GET и POST запросах. Если в `$csrfField` пусто, проверка не выполняется.

Токен хранится в cookie *CSRF_TOKEN*. Использование печеньки несколько ослабляет безопасность (если хакер как-то сможет получить доступ к cookies жертвы). Удобство же в том, что можно легко добавить токен в ajax-передачу формы, достаточно только прочитать его из печеньки.

## Исключения

Модель формы или супер-класс валидатора пробрасывает исключение `kira\exceptions\FormException`. В основном все случаи исключения такого типа указывают на неверное использование функционала (ошибка кодера). Один уникальный случай: проверка CSRF-токена. Если проверка не пройдет, будет `FormException` с кодом 400.
