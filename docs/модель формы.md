# Модель формы. Валидация форм

Класс `kira\web\From`. Сам по себе не используется, клиентские модели форм должны наследовать от него.

Возможности модели форм в этом движке:

- любая вложенность исходных данных
- валидация массива однородных данных одним правилом
- любое количество валидаторов на конкретное значение. Есть ограничение на количество валидаторов по типу, см. ниже.
- свои сообщения об ошибках от любого валидатора

Пример использования модели формы:

```PHP
$form = new SomeForm;
if ($form->load($_POST)->validate()) {
...
} else {
    $errors = $form->getErrors();
}
```


*Прим: иногда для маленьких форм невыгодно заводить модель. Валидировать значения можно так же через серию методов `kira\net\Request`, см. функции класса `get()`, `post()`, `cookie()`, `request()` и их производные.*

## Структура контракта

Основное понятие - **контракт на поля формы**. Это массив с именами полей и списком валидаторов для их проверки.

**Важно:** служебное слово `validators` занято в описании контракта. Названия полей формы не должны сопадать с этим словом, иначе результат непредсказуем. Зачем оно: механизм валидации поддерживает *многомерные массивы с описанием полей*. Без явного указания через `validators` в многомерном массиве невозможно отличить, где иерархия имени поля, а где - валидаторы.

Формы могут быть любой сложности и вложенности данных. Контракт должен повторять иерархию вложенности данных. Рассмотрим на примере сложной html-формы с большой вложенностью данных:

```html
<form method="POST" action="create">
    <input type="text" value="test" name="inp0">

    <input type="text" value="test1" name="inp1[]">
    <input type="text" value="test2" name="inp1[]">
    <input type="text" value="test3" name="inp1[]">

    <input type="text" value="test4" name="inp2[one]">
    <input type="text" value="test5" name="inp2[two]">

    <input type="text" value="test6" name="inp3[lvl1][lvl11]">
    <input type="text" value="test7" name="inp3[lvl1][lvl12]">
    <input type="text" value="test8" name="inp3[lvl1][lvl12][lvl121]">
    <input type="submit">
</form>
```

Дамп переменной $_POST:

```PHP
array
(
    'inp0' => 'test'
    'inp1' => array
    (
        0 => 'test1'
        1 => 'test2'
        2 => 'test3'
    )
    'inp2' => array
    (
        'one' => 'test4'
        'two' => 'test5'
    )
    'inp3' => array
    (
        'lvl1' => array
        (
            'lvl11' => 'test6'
            'lvl12' => array   // обратите внимание: "test7" отсутствует
            (
                'lvl121' => 'test8'
            )
        )
    )
)
```

Пример контракта на поля формы:

```PHP
class SomeForm extends kira\utils\Form {
    protected $contract = [
        'inp0' => [
            'validators' => [          // здесь три валидатора
                'required' => true,

                'filter_var' => [
                    'filter'  => FILTER_VALIDATE_REGEXP,
                    'options' => ['regexp' => '~^[a-z0-9-_]+$~i'],
                    'message' => 'Недопустимые символы в логине',
                ],

                'length' => ['min' => 5, 'max' => 30,],
            ],
        ],

        'inp1' => [
            'validators' => [
                'expect_array' => true,     // обязательный флаг для обработки массивов данных
                'filter_var' => [
                    'filter'     => FILTER_CALLBACK,
                    'options'    => ['\kira\utils\Validators', 'normalizeString'],
                ],
            ],
         ]

        'inp2' => [
            'validators' => [
                'expect_array' => true,
                ...
            ],
        ],

        'inp3' => [
            'lvl1' => [
                'lvl11' => [
                    'validators' => ['required' => true,],
                ],
                'lvl12' => [
                    'lvl121' => null,  // принять без валидации
                ],
            ],
        ],
    ];
}
```

Валидаторы могут быть назначены только на конечный узел иерархии, т.е. на данные конкретного поля формы. Исключение составляет массив данных с валидатором `expect_array`, см. ниже.

Валидаторы описываются в отдельном ассоциативном массиве с ключом `validators`. В свою очередь ключи такого массива - конкретные названия валидаторов, значения массива - параметры валидаторов.

Если валидация поля не нужна, пишем `null` в качестве значения.

Для простых форм требуемое описание контракта может казаться излишне сложным. Тем не менее такой подход оправдан, т.к. поддерживается единый интерфейс контракта для форм любой сложности. Один раз разобраться и потом можно читать и править любую модель. Это лучше, чем если бы я ввел еще и "легкую" версию контракта и запоминать пришлось бы два интерфейса.

## Валидаторы

**Важно:** каждый валидатор имеет название. На одно проверяемое значение нельзя повешать два валидатора с одним названием. Это очевидно, т.к. название валидатора задается в ключе массива валидаторов и повторное его использование перепишет предыдущее значение в массиве.

Валидаторы движка нельзя переписать. Но можно создать и использовать свои кастомный функции валидации. Для этого служат валидаторы `external` и `filter_var` со значением `'filter'  => FILTER_CALLBACK`.

### Список валидаторов

[required](#required)
[filter_var](#filter-var)
[external](#external)
[typecast](#typecast)
[limits](#limits)
[expect_id](#expect-id)
[password](#password)
[expect_array](#expect-array)

### required

Тут достаточно просто `true`. Если требуется свое сообщение, тогда описываем массив ['message' => '...']. Пример:

```PHP
...
'login' => [
    'validators' => [
        'required' => true,
    ],
],

'mail' => [
    'validators' => [
        'required' => ['message' => 'Укажите email, пожалуйста'],
    ],
],
...
```

Если сообщение не задано явно, будет дефолтное, прописанное в валидаторе.

### filter_var

Описывается по правилам [php::filter_var()](http://php.net/manual/ru/function.filter-var.php), для валидации будет вызвана именно эта функция. Обязательный элемент - `filter`, мое дополнение - `message`. Пример:

```PHP
...
'login' => [
    'validators' => [
        'filter_var' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => [
                'regexp' => '~^[a-z0-9-_]+$~i'
            ],
            'flags' => null, // для этого типа фильтра нет флагов. Но для фильтров, где флаги возможны, описывать тут
            'message' => 'Недопустимые символы в логине',
        ],
    ],
],
...
```

Некоторые фильтры позволяют задать значение по умолчанию через `options['defalut']`. Если оно есть, то в случае неудачи функция возвращает это значение, а не `FALSE`. Основной метод валидации воспримет такую ситуацию, как успешную и запишет полученное значение в проверенные данные. Я думаю, это логично: кодер указал, что принимать по умолчанию. Следовательно он не хочет ошибку валидации.

Некоторые фильтры поддерживают настройку через флаги. Такие значения передавать через ключ `flags` **рядом** с `options` (см. пример в этом разделе). Если фильтр не поддерживает флаги или их использование не требуется, то в контракте их можно вообще не описывать.

### typecast

Валидатор приведения значения к типу. Использует одноименную утилиту `kira\utils\Typecast` и позволяет задать свое сообщение об ошибке, если приведение к типу не удалось. Валидатор придуман для сокращения размеров контракта, тоже самое можно описать через валидатор `filter_var`, но с бОльшим числом параметров.

Пример настройки валидатора:

```php
use kira\validation\validators\Typecast;
...
'userName' => [
    'validators' => [
        'typecast' => Typecast::STRING // Константа в классе валидатора, не в одноменной утилите

        // или

        'typecast' => [
            'type' => Typecast::STRING,
            'message' => 'Имя юзера должно быть задано строкой',
        ],
    ],
]
```

### limits

Проверка значения на соблюдение заданных пределов. Для числел - диапазон значений, для строк - длина строки.

Главное удобство этого валидатора в возможности задать свое сообщение именно на нарушение границ длины строки или диапазона числа. Если свое сообщение не требуется, контроль длины/диапазона можно совместить с регуляркой в `filter_var` и выдавать что-нибудь общее в качестве сообщения.

Настройки валидатора:

```php
'limits' => [
    'min'     => number,
    'max'     => number,
    'message' => string|array [min => string, max => string],
],
```

Любой из параметров можно пропустить. Значение `NULL` - не проверять границу с этой стороны.

Пример:

```php
'limits' => [
    'min'     => 5.7,
    'max'     => 10,
    'message' => [
        'min' => 'Число не меньше :min', // тут будет использована подстановка значения min = 5.7
        'max' => 'Слишком большое число',
    ],
]
```

**Важно**: если значение ранее не приведено к нужному типу, то сначала оно будет рассматриваться, как строка и будет применена проверка на длину строки. Во избежание недопонимания ставьте перед этим валидатором приведение к типу через `filter_var` или `typecast`, если ожидаете значение-число.

### expect_id

Валидатор проверяет значение, как целое положительное число. Валидатор имеет только одну настройку - `message`. Если сообщение не требуется, можно просто указать `TRUE` вместо настроек валидатора.

Пример использования:

```php
$contract = [
    'id' => [
        'validators' => [except_id => true]
    ],
    'userId' => [
        'validators' => [except_id => ['message' => 'Неверный id пользователя']]
    ],
    'page' => [
        'validators' => [except_id => ['message' => 'Неверный номер страницы']]
    ],
];
```

### password

Проверка пароля на допустимые символы и количество используемых наборов символов в одном пароле. Проще говоря, когда вы от пользователя хотите пароль минимум в 5 символов и с обязательным использованием двух регистров + цифры - это как раз тот самый валидатор.

В пароле разрешены следующие наборы символов (это хардкод валидатора, не настраивается):

- цифры
- буквы в нижнем регистре
- буквы в верхнем регистре
- спецсимволы: _ - ! @ # $ % ^ & ` ~

Буквы в верхнем/нижнем регистре считаются разными наборами при проверке минимальной комбинации символов.

Настройки валидатора (указаны значения по умолчанию):

```
'password' => [
   'min_length' => 0,      // минимальная длина пароля. 0 = любая длина подходит.
   'min_combination' => 1, // минимальная комбинация наборов символов в пароле
   'glue' => ' ',          // чем склеить ошибки валидации. Их может быть несколько, применится php::implode()
]
```

Про ошибки нужно пояснить: если пароль не отвечает нескольким требованиям, по каждому из них будет отдельное сообщение. Но результатом работы этого валидатора все равно будет одна строка с сообщением об ошибке. Поэтому в `glue` можно указать, чем склеить все сообщения в одну строку.

### email

Проверка email адреса на корректность и черные сервера. Настройки:

```php
'email' => [
    'regexp' => '/.+@.+\..+/', // значение по умолчанию
    'black_servers' => array | NULL
]
```

Проверка адреса на корректность выполняется простой регуляркой (см. выше). Почему так просто, см. [тут](http://habrahabr.ru/post/175375/)  Конечно вы можете определить свое регулярное выражение.

Проверка на черный список серверов необязательна. Нет списка - нет проверки.

### external

Валидатор-посредник. Служит для вызова кастомных валидаторов, не зашитых в движке.

Сам валидатор не проводит проверку. Он передает настройки и сообщение в указанный внешний валидатор, забирает из него результат
и возвращает без изменений.

Настройки External:

```php
$options = [
     'class'   => string // FQN класса-валидатора
     'options' => mixed  // Настройки вызываемого валидатора
];
```

Если нужно переопределить сообщение в вызываемом валидаторе, прописывать его надо в `options => [message => string]`.

Пример:

```php
'external' => [
    'class'   => CustomValidator::class,
    'options' => [
        'allowNegative' => true,
        'min'           => -100,
        'message'       => 'Неверное что-то в кастомном валидаторе',
    ],
]
```

Требования к вашему внешнему валидатору:

- наследник `AbstractValidator`, реализация метода `validate()`. Метод должен возвращать `bool`.
- присвоение проверенного значения в `AbstractValidator::$value`. Оно будет передано дальше в цепочке валидаторов.
- ошибку писать в `AbstractValidator::$error`. Оттуда его достанет механизм валидации, если проверка не пройдет.

Так же стоит изучить конструктор `AbstractValidator`. Переопределить его, если не устраивает. Ваш класс должен быть создан с расчетом на то, что один объект валидатора может быть использоваться для проверки нескольких значений. Т.е. нигде не должно залипнуть старое значение или ошибка валидации.

*Прим.: все валидаторы движка наследуют `AbstractValidator`. Их тоже можно изучить вместе с тестами для понимания, как написать свой валидатор. Самые простые валидаторы - `required` и `expect_id`, поддерживающий несколько взаимоисключающих сообщений - `email`.*

### expect_array

Особый валидатор, позволяющий применить все остальные валидаторы к проверяемому значению, как к массиву данных, если в контракте указано, что ждем массив. Если же этого указания нет, то механизм валидации все равно проверит значение, но уже на отличие от массива. Т.о. массивы данных пройдут проверку только там, где они ожидаются.

Зачем такой валидатор: неверный тип данных может привести к непредвиденной ошибке в других валидаторах или в клиентском коде. Поэтому требуется отдельная проверка на тип "массив/не массив".

Очевидно, что при валидации массива не имеет смысла задавать конкретные сообщения об ошибках, т.к. для каждого невалидного значения будет использовано одно и тоже сообщение.

По умолчанию `expect_array` равно `false`, т.е. в каждом поле ожидаем единичное значение, не массив.

Этот валидатор в некотором роде служебный, является дополнительной защитой от попытки поломать сайт и получить какие-нибудь ошибки. Т.е. обычный пользователь не сможет тут нарушить логику сайта, поэтому для данного валидатора нельзя назначить пользовательское сообщение об ошибке. К тому же это технически сложно, т.к. сообщений нужно задать два.

#### Сообщения

Любой валидатор может сопровождаться своим сообщением. Так же кастомные валидаторы, подключаемые через `external`, могут возвращать свои сообщения. Если сообщение указано в контракте, при валидации прогоняем его через переводчик (см. док *"Локализация сайта"*). Сообщения из кастомных валидаторов принимаем без перевода.

Дефолтные сообщения валидаторов так же прогоняются через переводчик.

Сообщение, заданное в контракте для конкретного валидатора, заменяет дефолтное его сообщение.

#### Непосредственный вызов валидатора

Валидаторы можно вызывать напрямую, хотя это не приветствуется. Тем не менее, вот пример, как с ними можно работать:

```php
$idValidator = (new \kira\validation\validators\ExpectId([
    'message' => 'Неверный ID пользователя';
]));

$userId = \kira\Request::get('userId');

if ($idValidator->validate($userId)) {
    return $idValidator->value;
} else {
    throw new \kira\exceptions\FormException($idValidator->error);
}
```

Важно отметить, что валидатор нигде не хранит результат своей работы, только возвращает его из `validate()`. Если нужно запомнить результат проверки, делайте это на клиентской стороне или просто используйте контракты и модель формы, а не валидаторы напрямую.

*Прим: сообщение об ошибке `AbstractValidator::$error` может хранить подготовленный текст сразу же после создания объекта валидатора. Более того, это сообщение может вообще быть пустым, если так будет настроен валидатор. Поэтому нельзя полагаться на него для получения результата валидации.*

## Очередь выполнения валидаторов

Сначала проверяется тип ожидаемого значения, должен ли быть массив или нет. Независимо от положения `expect_array` в списке валидаторов он будет выполнен первым.

Потом к данным поля формы применяется `required`, (если он задан), причем так же независимо от его положения в списке валидаторов. Это позволит остальным валидаторам не ругаться на неправильные значения, когда их просто нет. Остальные валидаторы выполняются в порядке очереди. Т.о. следует использовать, например, проверку длины **после** дезинфицирующих фильтров, поскольку длина строки может измениться.

Если очередной валидатор забраковал значение, последующие валидаторы для поля не вызываются.

## Структура модели формы

После вызова конструктора модели ее уже можно использовать на веб-формах. Это удобно, когда предполагается повторное заполнение формы данными при ошибках валидации. Логика такая: пишем шаблон со вставками данных из модели формы. Контроллер создает экземпляр модели и передает его в шаблон. Все. Не нужно в шаблоне проверять наличие поля через `isset()`. Все поля есть согласно описания контракта. Все данные в них равны `null`.

Чтобы проверить полученные данные, их нужно загрузить в модель. Для этого служит метод

```PHP
function load(array &$data):From
```

Эти данные будут сохранены, как "сырые": передаваемый на загрузку массив никак не изменяется и даже сохранятся элементы, не заявленные в контракте.

Метод возвращает объект текущей модели, что позволяет выполнить вызов следующего метода по цепочке.

Собственно проверка вызывается методом

```PHP
function validate():bool
```

---

Модель формы хранит три массива, соответствующие иерархии исходных данных:

- Сырые данные. Это все, что было передано в модель. Как есть, без валидации, независимо от полей контракта.

- Проверенные данные. В этот массив попадет только то, что **заявлено в контракте** и прошло валидацию.

Очередной валидатор меняет тут значение только в случае успешной проверки (если конечно предполагается такое изменение). Иначе значение остается таким, каким было получено на вход валидатора. Такой подход позволит комбинировать выдачу юзеру. Можно вернуть текущее значение и указать на ошибку.

- Ошибки. В массив ошибок можно добавлять свои из клиентского кода.

Для получения данных из этих массивов используются соответственно:

```PHP
function getRawData([string $key]):mixed
function getValues([string $key]):mixed
function getErrors([string $key]):array
```

Параметр `$key` необязателен. Если не задан - возвращается весь массив. Если задан, возвращается **подмассив первого уровня иерархии данных**. Получить данные с подуровней несложно, но как описать ключ в таком случае? Поэтому только первый уровень.

*Прим: для сборки всех ошибок в строку из многомерного массива может оказаться полезной функция `kira\utils\Arrays::implode_recursive()`. Подробности - в комментарии к функции.*

Проверенные данные хранятся в отдельном массиве.

#### Дополнительные функции модели формы

```PHP
function addError(array $message):void
```

Добавление своего сообщения в массив ошибок. Ключ в массиве - имя поля, значение - собственно сообщение. В случае многомерного массива описывается полный путь вложений к требуемому полю и потом сообщение.

---

```PHP
function hasErrors():bool
```

Проверка, есть ли какие-то ошибки. Не обязательно ошибки валидации. Такое возможно, учитывая использование метода `addError()`.

---

```PHP
function isValid():bool
```

Получение информации о результате валидации. Очевидно, что вызывать такой метод имеет смысл только после вызова `validate()`.

---

```PHP
function setValue(array $value):void
```

Свое значение в массив **валидированных** данных. Если значение нужно разместить в многоуровневом массиве, пишем всю вложенность ключей и новое значение на нужном уровне. Старое значение будет переписано, если оно есть. Наличие поля не проверяется, что дает больше возможностей для управления массивом итоговых данных.

## Защита от CSRF атаки

В модели формы есть свойство `$csrfField`. В него пишем имя поля формы, в котором будем передавать CSRF-токен. Само значение получаем через методы `Request::createCsrfToken()` или `Request::getCsrfToken()`, см. класс `\kira\net\Request`. Прописываем токен в шаблоне формы в заявленном поле. Все.

Токен проверяется при валидации формы, непосредственно перед валидацией полей. Если токен не пройдет проверку, будет проброшено исключение `FormException` с кодом 400. Именно исключение, а не просто ошибка валидации, т.к. токен не зависит от действий юзера, это скорее сбой приложения, реакция соответствующая. Код передается для удобства, клиентское приложение может по-своему реагировать на такое исключение.

*Прим: код 400 взят по аналогии с HTTP-кодом "400 Bad request".*

Проверка токена возможна только в GET и POST запросах. Если в `$csrfField` пусто, проверка не выполняется.

Токен хранится в cookie *CSRF_TOKEN*. Использование печеньки несколько ослабляет безопасность (если хакер как-то сможет получить доступ к cookies жертвы). Удобство же в том, что можно легко добавить токен в ajax-передачу формы, достаточно только прочитать его из печеньки.

## Исключения

Модель формы или супер-класс валидатора пробрасывает исключение `kira\exceptions\FormException`. В основном все случаи исключения такого типа указывают на неверное использование функционала (ошибка кодера). Один уникальный случай: проверка CSRF-токена. Если проверка не пройдет, будет `FormException` с кодом 400.

## Магический доступ к полям формы

Есть геттер и сеттер для доступа к полям формы. Доступны все поля, хранящиеся в `Form::$values`, т.е. все валидированные данные. Если поле не найдено, будет исключение. Если поля формы - многомерный массив, то на вложенные уровни нельзя попасть через магию. Простой пример:

```php
class LoginForm
{
    protected $contract = [
        'login' => [
            'validators' => [...]
        ],
        'password' => [
            'validators' => [...]
        ],
    ];
}

$form = new LoginForm->load(Request::get());
if ($form->validate()) {
    dd($form->login, $form->password); // магический доступ к валидированным значениям
    $form->rememberMe = true;          // будет исключение, такого поля нет в модели формы
}
```

## Нерешенные вопросы

Если поле в контракте - необязательное и его нет в проверяемых данных, то его значение будет равно NULL. Т.е. его можно будет получить через `Form::getValues()`, но только NULL. А что, если мне нужно для таких полей задать дефолтные значения, если дял них не передали данные? Пока я не придумал решения, красивого и при этом понятного с клиентской точки зрения.
