# Утилиты

Каталог [engine/utils/]. Не описываю детально каждый метод. Просто лень :) Есть развернутые комментарии в коде. 

## Arrays 

Класс `\engine\utils\Arrays`
 
Работа с массивами. В это трудно поверить, но при всем богатстве php-методов все еще есть, что свое написать :) В частности, методы работы с многомерными массивами через рекурсию или извлечение конечного значения по многомерному ключу массива. 

## Dumper

Класс `\engine\utils\Dumper`

Дамп переменной. Взял в Yii 1.x и слегка переделал по своему усмотрению. Все публичные методы этой утилиты работают аналогично php::var_dump() и php::print_r(), но возвращают информацию в более приглядном виде.

В движке есть "shortcut"-функция для отладки - `dd()`. Обращается именно в этот класс, но доступна в любом месте сайта, без подключения класса, namespaces и т.д. 

## FS

Класс `\engine\utils\FS`

Файловая система. В основном это обертки PHP-функций, но с перехватом ошибок. Если что-то пойдет не так, функции этого класса возвращают сообщение об ошибке, а не роняют код с E_ERROR. Особого внимания заслуживают функции работы с каталогами..

function __makeDir($path, $mode = 0777)__: _true|string_

Создание каталога. 

По умолчанию, линуксовые команды из PHP скрипта выполняются от имени юзера, запускающего скрипт. Т.е. когда скрипт запускает сервер Apache, юзером числится *www-data*. 

При создании каталогов с назначением прав через [php::mkdir()] (http://php.net/manual/ru/function.mkdir.php) учитывается так же текущее значение `umask`. Об этом можно почитать в [Википедии] (https://ru.wikipedia.org/wiki/Umask) и в мануале PHP по соответствующим функциям. Коротко: что указано в umask, то будет запрещено в правах к каталогу. На практике обычно получаем такие права к каталогу: 755. Это значит, что кроме создателя остальным можно только читать из него.

Сообсно, в чем суть проблемы: во время разработки сайта с такими каталогами неудобно работать, прав не хватает. Даже если создать каталог с полным доступом всем, получим грабли при создании вложенных каталогов! 

Пример. Допустим, есть некий каталог приложения [/www/site/temp/]. В нем для импорта нужно создать такую иерархию [/import/XXX/], где XXX - это timestamp на момент создания. Код:  

```PHP
$path = '/www/site/temp/import/' . time();
mkdir($path);
chmod($path, 0777);
```

В итоге получим права:
```
user@comp:/www/site/temp$ ls -l
drwxr-xr-x 3 www-data www-data   4096 Jun  3 14:10 import

user@comp:/www/site/temp/import$ ls -l
drwxrwxrwx 2 www-data www-data 4096 Jun  3 14:12 1464937950
```

В чем проблема? Нельзя удалить каталог из [import/], т.к. прав недостаточно. Зато свободно можно работать в его подкаталоге. Вообщем, мне это неудобно. Функция 
 
```
function makeDir($path, $mode): bool|string
```

создает все каталоги до заданного и задает всем новым каталогам указанные права.

Кроме прочего, она перехватывает ошибки от PHP функций `mkdir()` и `chmod()` и возвращает их строкой. Без перехвата был бы `E_WARNING`.

---

function __removeDir($path, $fuseLevel = 1)__: _true|string_

Удаление каталога с подкаталогами и файлами.

`$fuseLevel` - максимальный уровень вложенности каталогов используется как предохранитель (чтобы себе в ногу не выстрелить): сначала выясняем, превышает ли заданный уровень реальная вложенность, и возвращаем ошибку, если так. Только потом удаляем, через рекурсию вспомогательной функции.

Сделал суровые условия: удалить можно от 1 до 4 уровней каталогов. Это очень опасная функция, нужно вообще избегать ее использования.

---

function __clearDir($path, $filter = '')__: _true|string_

Очистка каталога от файлов.

Не работает с подкаталогами из соображений безопасности, очистка проводится только в текущем каталоге. Удаляем все файлы или подходящие под заданный фильтр (регулярное выражение). Символические ссылки тоже удаляются, оригиналы файлов при этом не будут затронуты.

*Прим.: для очистки процессу нужен доступ на запись в целевой каталог. Доступ к файлам может вообще отсутствовать.*

## Mailer

Класс `\engine\utils\Mailer`

Простой класс по отправке почты. Способен создать и отправить письмо любой сложности, с вложениями, прикрепленными файлами, разными версиями письма. Но в итоге функционал опирается на функцию `php::mail()`. Мне некогда писать свою низкоуровневую реализацию на сокетах.

Есть несколько RFС по стандарту электронных писем. Однако не все почтовые клиенты им следуют, да и не все сервера. Тема отправки писем имеет множество ньюансов. Если методы этого класса не работают в вашем случае - создавайте свои :) Ну или используйте сторонние библиотеки разной степени глючности и веса.

Полезно почитать

- [php::mail()] (http://php.net/manual/ru/function.mail.php)
- [Как грамотно отправлять почту из скриптов] (https://habrahabr.ru/post/17531/)


## Strings

Класс `\engine\utils\Strings`

Работа со строками. В классе есть:

- клевая функция для генерации пароля по заданным требованиям
- транслитеральные функции (en-ru)
- функция для склонения слова в зависимости от заданного числа
- недостающие функции обработки мультибайтных строк

## Validators

Класс `\engine\utils\Validators`

Некоторые валидаторы форм. На прямую не используются, подробнее о валидации см. в доке *"Модель формы"*
