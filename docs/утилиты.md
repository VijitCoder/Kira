# Утилиты

Каталог [engine/utils/]. Не описываю детально каждый метод. Просто лень :) Тут упомянуты только те методы, по которым комментариев в коде недостаточно.

Для всех классов утилит есть модульные тесты. Можно смотреть для получения примеров.

## Arrays

Класс `\kira\utils\Arrays`

Работа с массивами. В это трудно поверить, но при всем богатстве php-методов все еще есть, что свое написать :) В частности, методы работы с многомерными массивами через рекурсию или извлечение конечного значения по многомерному ключу массива.

В PHP есть [SPL с итераторами](http://php.net/manual/ru/spl.iterators.php). Но как показывает практика, например, [тут](http://php.net/manual/ru/class.recursiveiteratoriterator.php#112713), рекурсивные функции быстрее. Хотя конечно для всех итераторов я тесты не видел.

---

Получение значения из массива по заданной цепочке ключей

function __getValue(array &$arr, $chain)__: _mixed_

В чем смысл. Допустим, есть некий многомерный массив:

```PHP
$data = [
    'path' => [
        'app' => [
            'level1' => '/home',
            'level2' => '/www',
        ],
    ],
 ...
];
```

Нужно получить значение из `level2`. В обычной ситуации это будет:

```PHP
$v = $data['path']['app']['level2'];
```

Но когда мы не можем напрямую описать ключи, используем эту функцию:

```PHP
/**
 * Получение сообщения для конкретного поля формы
 * @param array $messages многомерный массив сообщений по полям формы
 * @param array $key      многомерный массив ключей, указывающий на конкретное поле
 */
function getMessage($messages, $key)
{
    return Arrays::getValue($messages, $key);
}
```

## Dumper

Класс `\kira\utils\Dumper`

Дамп переменной. Взял в Yii 1.x и слегка переделал под себя. Все публичные методы этой утилиты работают аналогично php::var_dump() и php::print_r(), но возвращают информацию в более приглядном виде.

В движке есть "shortcut"-функция для отладки - `dd()`. Обращается именно в этот класс, но доступна в любом месте сайта, без подключения класса, namespaces и т.д.

## FS

Класс `\kira\utils\FS`

Файловая система. В основном это обертки PHP-функций, но с перехватом ошибок. Если что-то пойдет не так, функции этого класса возвращают сообщение об ошибке, а не роняют код с E_ERROR. Особого внимания заслуживают функции работы с каталогами.

---

Создание каталога:

function __makeDir($path, $mode = 0777)__: _true|string_

Как работает: выясняем, сколько каталогов по пути нужно будет создать. Создаем все разом через `php::mkdir()`. Каждому новому каталогу с конца назначаем требуемые права. Почему с конца: если запрещено исполнение, то в каталог нельзя будет попасть после установки прав.

Не используем для вычисления родителя функцию `php::dirname()`, она привносит свои заморочки.

**Какая польза от этого метода**

По умолчанию, линуксовые команды из PHP скрипта выполняются от имени юзера, запускающего скрипт. Т.е. когда скрипт запускает сервер Apache, юзером числится *www-data*.

При создании каталогов с назначением прав через [php::mkdir()](http://php.net/manual/ru/function.mkdir.php) учитывается так же текущее значение `umask`. Об этом можно почитать в [Википедии](https://ru.wikipedia.org/wiki/Umask) и в мануале PHP по соответствующим функциям. Коротко: что указано в umask, то будет запрещено в правах к каталогу. На практике обычно получаем такие права к каталогу: 755. Это значит, что кроме создателя остальным можно только читать из него.

Сообсно, в чем суть проблемы: во время разработки сайта с такими каталогами неудобно работать, прав не хватает. Даже если создать каталог с полным доступом всем, получим грабли при создании вложенных каталогов!

Пример. Допустим, есть временный каталог приложения [/www/site/temp/]. В нем для импорта нужно создать такую иерархию [/www/site/temp/import/XXX/], где XXX - это timestamp на момент создания. Код с использованием нативных php-функций будет таким:

```PHP
$path = '/www/site/temp/import/' . time();
mkdir($path);
chmod($path, 0777);
```

В итоге получим права:

```sh
user@comp:/www/site/temp$ ls -l
drwxr-xr-x 3 www-data www-data   4096 Jun  3 14:10 import

user@comp:/www/site/temp/import$ ls -l
drwxrwxrwx 2 www-data www-data 4096 Jun  3 14:12 1464937950
```

В чем проблема? Нельзя удалить каталог из [import/], т.к. прав недостаточно. Зато свободно можно работать в его подкаталоге. Вообщем, мне это неудобно. Функция

```PHP
function makeDir($path, $mode): bool|string
```

создает все каталоги до заданного и задает всем новым каталогам указанные права.

Кроме прочего, она перехватывает ошибки от PHP функций `mkdir()` и `chmod()` и возвращает их строкой. Без перехвата был бы `E_WARNING`.

---

function __removeDir($path, $fuseLevel = 1)__: _true|string_

Удаление каталога с подкаталогами и файлами.

`$fuseLevel` - максимальный уровень вложенности каталогов используется как предохранитель (чтобы себе в ногу не выстрелить): сначала выясняем, превышает ли заданный уровень реальная вложенность, и возвращаем ошибку, если так. Только потом удаляем, через рекурсию вспомогательной функции.

Сделал суровые условия: удалить можно от 1 до 4 уровней каталогов. Это очень опасная функция, нужно вообще избегать ее использования.

---

function __clearDir($path, $filter = '')__: _true|string_

Очистка каталога от файлов.

Не работает с подкаталогами из соображений безопасности, очистка проводится только в текущем каталоге. Удаляем все файлы или подходящие под заданный фильтр (регулярное выражение). Символические ссылки тоже удаляются, оригиналы файлов при этом не будут затронуты.

*Прим.: для очистки процессу нужен доступ на запись в целевой каталог. Доступ к файлам может вообще отсутствовать.*

## Mailer

Класс `\kira\utils\Mailer`

Простой класс по отправке почты. Способен создать и отправить письмо любой сложности, с вложениями, прикрепленными файлами, разными версиями письма. Но в итоге функционал опирается на функцию `php::mail()`. Мне некогда писать свою низкоуровневую реализацию на сокетах.

Есть несколько RFС по стандарту электронных писем. Однако не все почтовые клиенты им следуют, да и не все сервера.

> Например, чтобы Thunderbird 38.5 увидел имя прикрепленного файла, нужно его указывать после MIME, причем в той же строке. Или после attachment, и опять же в той же строке. Странно, но только так работает.

Вопрос отправки писем имеет множество ньюансов. Если методы этого класса не работают в вашем случае - создавайте свои :) Ну или используйте сторонние библиотеки разной степени глючности и веса.

Полезно почитать

- [php::mail()](http://php.net/manual/ru/function.mail.php)
- [Как грамотно отправлять почту из скриптов](https://habrahabr.ru/post/17531/)
- [RFC 2047 - MIME. Part Three](http://www.faqs.org/rfcs/rfc2047.html): *"Message Header Extensions for Non-ASCII Text"*. Тут изложены требования к заголовкам писем, кодированию текста и разбивке на строки.

#### Сложное письмо с вложениями

function __complex__(_string_ __$from__, _string_ __$to__, _string_ __$subject__, __$body__, _array_ __$files__ = [])): _bool_

<table>
    <tr><td><b>$from</b></td><td>от кого</td></tr>
    <tr><td><b>$to</b></td><td>кому</td></tr>
    <tr><td><b>$subject</b></td><td>тема письма</td></tr>
    <tr><td><b>$body</b></td><td>текст письма. Если массив, тогда [text|html|MIME-type => тест письма]</td></tr>
    <tr><td><b>$files</b></td><td>вложения. Смешанный массив</td></tr>
</table>

**Версии текстов письма**

Параметр `$body`. Можно указать несколько версий текста. Де-факто люди пишут *text* и *html* версии. Порядок включения текстов в письмо соответствует порядку их указания в массиве.

Пример описания версий письма:

```PHP
[
    'text' => ...,
    'html' => ...,
    'text/html; charset=win-1251' => ...  //тоже html, но в другой кодировке
]
```

Для ключей `text|html` будут установлены нужные заголовки Content-Type (кодировка utf-8). Любые другие ключи пропишутся в Content-Type как есть. Такие "другие" версии - эксперимент, не гарантирую их корректную работу со связанным контентом из вложений.

Если тело письма не является массивом, считаем его html-текстом и снабжаем заголовком `Content-Type: text/html; charset=utf-8`.

**Вложения**

Параметр `$files`. Можно вложить файлы. Можно добавить картинки в html-версию и так же их приложить к письму. Пример вложений:

```PHP
[
    0 => '/path/file.zip',
    1 => '/another/path/file.doc',
    '/images/head.png' => 'image/png',
    '/images/logo.jpg' => 'image/jpeg',
    28 => 'images/just_file.jpg',
]
```

Когда ключ числовой, файл будет описан как вложение с `Content-Type: application/octet-stream;`.

Если ключ строковый, тогда он указывает на картинку, значение - ее MIME-тип. Такие файлы будут вложены как данные,связанные с html-текстом письма (multipart/related). Подключить их можно через `src="cid:image_file"` в теге [img].

Замечания:

- встроенные в html картинки можно не передавать, как вложения, если прописывать в теге [img] полный URL к картинке-источнику. При этом почтовый клиент должен запросить их по заданному адресу.

- связи с картинками (multipart/related) оформляются только для версии письма, отмеченной "html". Как такие связи будут работать с другими версиями - я не знаю, официально не поддерживается.

#### Баг

У себя на локалке обнаружил баг при подготовке строк заголовков согласно стандарта **RFC 2047 Part Thr**. В конце кодированного значения **From, To** и **Reply-To** добавляется имя моей машины:

> From: =?utf-8?b?0K7Qt9C10YAgT25lIDx1c2VyX29uZUBtYWlsLnJ1Pg==?=@Z710

Причем это не PHP, т.к. дамп готовых значений ничего лишнего не показывает. Если записать одинаковое значение в адрес отправителя и в тему письма, то этот хвост появляется только у адресов! Эта приписочка очевидно ломает адрес получателя и письмо не доходит. Либо программа `mail` гонит, либо сервис `postfix`, на котором я провожу тесты. Не знаю, как искать причину. Пока отключил кодирование заголовков. На боевом стоит проверить, если бага не будет, оставить функцию включенной.

## Strings

Класс `\kira\utils\Strings`

Работа со строками. В классе есть:

- клевая функция для генерации пароля по заданным требованиям
- транслитеральные функции (en-ru)
- функция для склонения слова в зависимости от заданного числа
- недостающие функции обработки мультибайтных строк

---

Разбиение строки на части заданной длины в буквах:

function __word_chunk($str, $len = 76, $end = "\r\n")__: _string_

Безопасно для мультибайтных строк, т.е. не разделит букву посредине ее кода. Такой проблемой страдают php-функции `chunk_split()` и `wordwrap()` (в случае, когда ей разрешено разбивать слова). Эти функции делят строку по байтам.

При выборе требуемой длины следует вычитать символы конца строки. Функция их добавляет к итоговой длине.
Например, Strings::word_chunk('русский', 3, ' + ') даст 'рус + ски + й'

## Validators

Класс `\kira\utils\Validators`

Некоторые валидаторы форм. На прямую не используются, подробнее о валидации см. в доке *"Модель формы"*
