# Обобщение

Тут собрана документация по классам движка, для которых было лень писать подробное описание :) В упомянутые классы стоит заглянуть и почитать комментарии к коду.

## Самый главный скрипт :)

Класс `\kira\App`

Не смотря на свою важность, он хранит только очень общие методы:

- function __conf($key, $strict)__: _mixed_
Чтение значения из конфигурации приложения, см. *"Базовая конфигурация"*

- function __detectLang()__: _string_
Определение языка в случае мультиязычного приложения,  см. *"Локализация сайта"*

- function __t($key, $ins)__: _string_
Переводчик,  см. *"Локализация сайта"*

- function __end($callback, $msg)__: _void_
Завершение выполнения приложения

- function __router()__: _object_
Получение экземпляра реализации интерфейса IRouter, объект класса роутера. См. *"Роутинг"*

- function __logger()__: _\kira\Log_
Получение экземпляра логера. См. *"Логер"*

- константы **VERSION** и **ENGINE_URL** для обозначения движка.

## Контроллер

Класс `\kira\web\Controller`

Примечательны все его публичные методы.

В кратце: класс занимается отрисовкой шаблонов и выдачей результата в браузер, метод `Controller::render()`. Шаблон вставляется в макет, так же можно обойтись без вставки используя `Controller::renderPartial()`.

Непосредственно перед и после отрисовки шаблона с макетом вызываются два доп.метода `Controller::beforeRender()` и `Controller::afterRender()` соответственно. Для отрисовки шаблона без макета нет подобных методов, они не имеют смысла.

Из контроллера можно организовать редирект.

Для передачи отрисованного шаблона в макет используется переменная `$CONTENT`. Непринято писать переменные большими буквами, и здесь это сделано специально во избежание случайных совпадений с уже имеющимися переменными шаблона.

Так же в переменных шаблона нельзя использовать `$_view123`. Эта переменная занята внутренним механизмом отрисовки шаблона.

## Request

Класс `\kira\net\Request`

Запрос клиента. В PECL есть расширение с похожим назначением [httprequest](http://php.net/manual/en/class.httprequest.php) Но допустим, нам так много не нужно :)

Кроме прочих полезных методов, класс содержит кучу однотипных методов для получения валидированного значения из суперглобальных переменных $_GET, $_POST, $_COOKIE и $_REQUEST.

На примере $_POST:

function __post(string $key)__: _string|null_
function __postAsInt(string $key)__: _int|null_
function __postAsBool(string $key)__: _bool|null_
function __postAsRegexp(string $key, string $pattern)__: _string|null_
function __postAsEnum(string $key, string $expect)__: _string|null_

---

function __isMobileBrowser()__: _bool_

Проверяем, что запрос пришел с мобильного браузера.

Это не то же самое, что "мобильная версия сайта" (см. `Env::isMobile()`). Данный метод можно использовать для *"responsive"* верстки. Например, подключать какие-то особые js-скрипты.

## Response

Класс `\kira\net\Response`

Ответ клиенту.

## Session

Класс `\kira\net\Session`

Работа с сессией. Открыть, закрыть, прочитать, записать, удалить.

#### Набор методов для flash-сообщений

Флеш-сообщения - это такие сообщения, которые передаются между двумя обращениями юзера к серверу или между несвязанными классами. Как правило, само сообщение выдается в браузер через шаблон, своим особым оформлением привлекая внимание юзера (flash).

Пример: некий сервис проверил, что юзер не подтвердил свое мыло. Пишем ему напоминание в виде флеш-сообщения, которое будет обработано только в коде шаблона.

Проще один раз увидеть :) Вот полный код шаблона, который можно подключать в другие шаблоны для показа flash-сообщений (файл `_flash.htm`).

```PHP
<?php
/**
 * Сообщения юзеру от сервера
 */

use kira\net\Session;

/*
// Тесты
Session::addFlash('errAuth', 'Пример ошибки. <a href="">Пройдите в авторизацию</a>');
Session::addFlash('warnWtf', 'варнинг');
Session::addFlash('infoAccess', 'информационное');
Session::addFlash('warnAnother', '2й варнинг');
Session::addFlash('some', 'Просто сообщение');
*/

$flashes = Session::readFlashes();

if($flashes) {
    ksort($flashes);
    //Есть 4 типа: ошибка, инфо и предупреждение (err, info, warn) и любое другое значение.
    $type = $curType = '';
    foreach ($flashes as $key => $msg) {

        if (preg_match('/^(err|info|warn)/ui', $key, $m)) {
            $curType = $m[1];
        } else {
            $curType = 'msg'; //общее значение. Подойдет любой непустой текст.
        }

        //если меняется тип сообщения
        if ($type != $curType) {
            if ($type) {
                echo '</div>'; //закрываем предыдущий блок
            }
            echo "<div class='user-flash uf-{$curType}'>";
            $type = $curType;
        }

        echo $msg . '<br>';
    }
    echo '</div>'; //закрываем последний блок
}
```

Стили

```CSS
.user-flash {
    padding: 10px;
    margin: 10px 0;
    text-align: left;
    border: 2px solid #e0ce95;
 }
.uf-err  { background-color: rgba(255, 0, 0, .2); }
.uf-info { background-color: rgba(0, 255, 0, .2); }
.uf-warn { background-color: rgba(255, 255, 0, .3); }
.uf-msg  { background-color: rgba(0, 150, 255, .2); } /* нетипизированное сообщение */

```

Раскомментируйте тесты, и подключите его в своем шаблоне. Потом зайдите на страницу и будет магия :) Конечно, в обычной ситуация вызовы `Session::addFlash()` будут выполняться где-то в глубинах кода, а не в том же шаблоне, где и чтение этих сообщений.
