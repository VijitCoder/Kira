# Валидация форм

Здесь приведено только общее описание. См. так же документацию к методам в классе `\engine\web\From`.

Для валидации html-формы средствами движка требуется создать модель формы, унаследовав ее от `\engine\web\From`. В модели нужно описать свойство `$filtres` и всё. Это проще показать на примере. Тут приведено полное содержание модели формы регистрации пользователя. Ничего дополнительно не требуется, всю бизнес-логику берет на себя движок.

```PHP
<?php
/**
 * Форма регистрации
 */
namespace app\forms;

class RegistrationForm extends \engine\web\Form
{
    /** @var array фильтры полей html-формы. Каждая запись - описание валидатора */
    protected $filters = [
        'login' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => ['regexp' => '~^[a-z0-9-_]+$~i'],
            'msg' => 'Недопустимые символы',
            'required' => true,
            'max' => 30,
        ],

        'password' => [
            'filter'  => FILTER_CALLBACK,
            'options' => ['\engine\utils\Validators', 'password'],
            'required' => true,
            'max' => 30,
        ],

        'mail' => [
            'filter'  => FILTER_CALLBACK,
            'options' => ['\engine\utils\Validators', 'mail'],
            'required' => true,
            'max' => 50,
        ],

        'firstname' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => ['regexp' => '~^[\sa-zа-яё-]*$~ui'],
            'msg' => 'Недопустимые символы',
            'max' => 50,
        ],

        'secondname' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => ['regexp' => '~^[\sa-zа-яё-]*$~ui'],
            'msg' => 'Недопустимые символы',
            'max' => 50,
        ],

        'sex' => [
            'filter'  =>  FILTER_VALIDATE_REGEXP,
            'options' => ['regexp' => '~^none|male|female$~'],
            'msg' => 'неверно указан пол',
        ],

        'birth_date' => [
            'filter'  => FILTER_CALLBACK,
            'options' => ['\engine\utils\Validators', 'date'],
        ],

        'town' => [
            'filter'  => FILTER_CALLBACK,
            'options' => ['\engine\utils\Validators', 'normalizeString'],
            'max' => 100,
        ],

        'avatar' => null, //никакой валидации, сохранить значение "как есть"
    ];
}
```

`Form::$filters` - это *"контракт"* на поля html-формы. Будут приняты только те поля, что описаны в этом свойстве. 

*Прим.: на самом деле будут приняты любые данные, даже если их нет в контракте. Но используя методы модели формы доступ к "левым" данным будет ограничен.*
 
Каждому полю можно назначить валидатор. Собственно проверка значения выполняется функцией [php::filter_var()](http://php.net/manual/ru/function.filter-var.php), элементы `filter` и `options` соответствуют мануалу. Можно назначить только один валидатор на одно поле. Сложнее пока не требовалось. 

Кроме валидации в контракте можно указать ожидаемую длину значения и его необходимость. Если требуется принять поле вообще без каких-либо проверок, тогда объявляем его имя, в значении пишем `null` (см. *avatar* в примере).

**Важно: валидация ведется до последнего, пользователь получит весь список ошибок сразу.** Хороший пример: проверка пароля. На него можно наложить ограничения по минимальной длине, минимальному набору символов и проверку на допустимые символы. Всё это делает один подключаемый валидатор. В результе пользователь может получить до трех указаний на ошибку в одном сообщении, если умудрится нарушить все ограничения.

### Пример кода

Пример работы с моделью формы. Предполагается, что бразуер передал POST-запрос соответствующей html-формы.
```PHP
    $form  = new RegistrationForm();
    
    if ($form->load($_POST)->validate()) {
        //Порядок. Выполняем нужные действия
        //...
    } else {
        //Непорядок. Сообщаем юзеру об ошибках, например через flash-сообщения.
        Session::newFlash('errors', $form->getErrors());
        //...
    }
```

### Подключаемые валидаторы

Некоторые валидаторы можно найти в `\engine\utils\Validators.php`. По их аналогии можно написать свои. Ваша функция-валидатор должна принимать один строковый параметр и возвращать либо готовую строку либо массив с ошибками. В таком случае можно использовать функцию-валидатор в механизме движка. Интерфейсов нет, могу только рекомендовать смотреть уже готовые валидаторы. 

Явное неудобство - нельзя настраивать такие валидаторы через параметры самих функций. Это ограничение исходит из использования функции [php::filter_var()](http://php.net/manual/ru/function.filter-var.php) с константой `FILTER_CALLBACK`. Обходное решение - прописывать настройки в конфигурации приложения, как сделано, например, с валидатором пароля. 

### Массив ошибок

Логика по ошибкам такая: модель может хранить ошибки валидации и/или ошибки, добавленные в нее из-вне (например из сервисов). Т.е. получается два возможных поставщика сообщений об ошибках. Поэтому, для выяснения успеха валидации есть метод `Form::isValid()`. Он возвращает результат последней проверки методом `Form::validate()`. Для выяснения наличия ошибок в целом есть метод `Form::hasErrors()`.

*Прим.: метод `Form::validate()` сам возвращает результат проверки. Поэтому `Form::isValid()` является синтаксическим сахаром.*

Все ошибки модель хранит в массиве, ключ - имя поля, значение - массив с текстами всех ошибок поля. Зачем массив и почему бы не хранить все ошибки конкретного поля в строке? Чтобы была возможность вывести их с html-тегами. Например, обернуть каждую ошибку в тег параграфа или поставить в конце перенос строки.

В модели есть несколько методов для работы с массивом ошибок, см. комментарии в классе.
