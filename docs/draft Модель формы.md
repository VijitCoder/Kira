# Валидация форм

Здесь приведено только общее описание. См. так же документацию к методам в классе `\engine\web\From`.

Для валидации html-формы средствами движка требуется создать модель формы, унаследовав ее от `\engine\web\From`. В модели нужно описать свойство `$filtres` и всё. Это проще показать на примере. Тут приведено полное содержание модели формы регистрации пользователя. Ничего дополнительно не требуется, всю бизнес-логику берет на себя движок.

```PHP
<?php
/**
 * Форма регистрации
 */
namespace app\forms;

class RegistrationForm extends \engine\web\Form
{
    /** @var array фильтры полей html-формы. Каждая запись - описание валидатора */
    protected $filters = [
        'login' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => ['regexp' => '~^[a-z0-9-_]+$~i'],
            'message' => 'Недопустимые символы',
            'required' => true,
            'max' => 30,
        ],

        'password' => [
            'filter'  => FILTER_CALLBACK,
            'options' => ['\engine\utils\Validators', 'password'],
            'required' => true,
            'max' => 30,
        ],

        'mail' => [
            'filter'  => FILTER_CALLBACK,
            'options' => ['\engine\utils\Validators', 'mail'],
            'required' => true,
            'max' => 50,
        ],

        'firstname' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => ['regexp' => '~^[\sa-zа-яё-]*$~ui'],
            'message' => 'Недопустимые символы',
            'max' => 50,
        ],

        'secondname' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => ['regexp' => '~^[\sa-zа-яё-]*$~ui'],
            'message' => 'Недопустимые символы',
            'max' => 50,
        ],

        'sex' => [
            'filter'  =>  FILTER_VALIDATE_REGEXP,
            'options' => ['regexp' => '~^none|male|female$~'],
            'message' => 'неверно указан пол',
        ],

        'birth_date' => [
            'filter'  => FILTER_CALLBACK,
            'options' => ['\engine\utils\Validators', 'date'],
        ],

        'town' => [
            'filter'  => FILTER_CALLBACK,
            'options' => ['\engine\utils\Validators', 'normalizeString'],
            'max' => 100,
        ],

        'avatar' => null, //никакой валидации, сохранить значение "как есть"
    ];
}
```

`Form::$filters` - это *"контракт"* на поля html-формы. Будут приняты только те поля, что описаны в этом свойстве.

*Прим.: на самом деле будут приняты любые данные, даже если их нет в контракте. Но используя методы модели формы доступ к "левым" данным будет ограничен.*

Каждому полю можно назначить валидатор. Собственно проверка значения выполняется функцией [php::filter_var()](http://php.net/manual/ru/function.filter-var.php), элементы `filter` и `options` соответствуют мануалу. Можно назначить только один валидатор на одно поле. Сложнее пока не требовалось.

Кроме валидации в контракте можно указать ожидаемую длину значения и его необходимость. Если требуется принять поле вообще без каких-либо проверок, тогда объявляем его имя, в значении пишем `null` (см. *avatar* в примере).

**Важно: валидация ведется до последнего, пользователь получит весь список ошибок сразу.** Хороший пример: проверка пароля. На него можно наложить ограничения по минимальной длине, минимальному набору символов и проверку на допустимые символы. Всё это делает один подключаемый валидатор. В результе пользователь может получить до трех указаний на ошибку в одном сообщении, если умудрится нарушить все ограничения.

### Пример кода

Пример работы с моделью формы. Предполагается, что бразуер передал POST-запрос соответствующей html-формы.
```PHP
    $form  = new RegistrationForm();

    if ($form->load($_POST)->validate()) {
        //Порядок. Выполняем нужные действия
        //...
    } else {
        //Непорядок. Сообщаем юзеру об ошибках, например через flash-сообщения.
        Session::newFlash('errors', $form->getErrors());
        //...
    }
```

### Подключаемые валидаторы

Некоторые валидаторы можно найти в `\engine\utils\Validators.php`. По их аналогии можно написать свои. Ваша функция-валидатор должна принимать один строковый параметр и возвращать либо готовую строку либо массив с ошибками. Только в таком случае можно использовать функцию-валидатор в механизме движка. Интерфейсов нет, могу только рекомендовать смотреть уже готовые валидаторы.

Явное неудобство - нельзя настраивать такие валидаторы через параметры самих функций. Это ограничение исходит из использования функции [php::filter_var()](http://php.net/manual/ru/function.filter-var.php) с константой `FILTER_CALLBACK`. Обходное решение - прописывать настройки в конфигурации приложения, как сделано, например, с валидатором пароля.

*Прим: подключаемый валидатор сам должен возвращать ошибки (в массиве). Однако допускается переопределение его сообщений в контракте на поля формы.*

### Массив ошибок

Логика по ошибкам такая: модель может хранить ошибки валидации и/или ошибки, добавленные в нее из-вне (например из сервисов). Т.е. получается два возможных поставщика сообщений об ошибках. Поэтому, для выяснения успеха валидации есть метод `Form::isValid()`. Он возвращает результат последней проверки методом `Form::validate()`. Для выяснения наличия ошибок в целом есть метод `Form::hasErrors()`.

*Прим.: метод `Form::validate()` сам возвращает результат проверки. Поэтому `Form::isValid()` является синтаксическим сахаром.*

Все ошибки модель хранит в массиве, ключ - имя поля, значение - массив с текстами всех ошибок поля. Зачем массив и почему бы не хранить все ошибки конкретного поля в строке? Чтобы была возможность вывести их с html-тегами. Например, обернуть каждую ошибку в тег параграфа или поставить в конце перенос строки. Еще один плюс в пользу массива: можно выдать пользователю только первую ошибку, а не всё, полученное валидацией.

В модели есть несколько методов для работы с массивом ошибок, см. комментарии в классе.

---

**UPD** Переписал логику подключаемых валидаторов. Теперь они принимают первым параметром, как и раньше, проверяемое значение, а вторым - массив доп.параметров, любых требуемых конкретному валидатору.

Возвращать такие методы должны массив: либо ['errors' => ...], либо ['value' => ...] . В общем случае это удобно: можно вернуть пустую строку вместо ошибок, можно вернуть массив в качестве значения. Короче, больше свободы.

Как теперь вызывать такие валидаторы. Два варианта:

```
$filters = [
    'town' => [
        'filter'  => FILTER_CALLBACK,
        'options' => ['\engine\utils\Validators', 'normalizeString'],
        'max' => 100,
    ],
    
    'password' => [
        'filter'   => ['\engine\utils\Validators', 'password'],
        'options'  => [
            'min_len'  => 5,
            'min_comb' => 3,
        ],
        'required' => true,
        'max'      => 30,
    ],
]
```

В первом случае вызов метода будет организован по правилам `filter_var()` и передать доп.параметры не получится. Во втором случае будет вызов метода по правилам `call_user_func()` и то, что записано в `options`, будет передано, как второй параметр вызываемого метода. 

Следовательно описывая свой валидатор, нужно учитывать, как именно планируется его вызывать и тогда возвращать из него соответствующее значение. Разница в том, что вызов через `filter_var()` не требует оборачивать результат функции в массив, но и гибкости в таком результате меньше. Функция может вернуть либо `FALSE` либо валидированное значение.

На вызовы валидаторов через `call_user_func()` я наложил свои требования, поэтому результат должен быть массивом либо ['errors' => ...], либо ['value' => ...].

Сообщения, возвращаемые такими валидаторами, теперь можно перекрыть настройкой `message` в описании фильтра.