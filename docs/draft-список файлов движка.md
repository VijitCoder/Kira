# Список файлов движка

***application/***

каталог приложения (сайта). Название - на свое усмотрение, см. константу *PATH_APP*.

***application/conf/main.php***

конфиг приложения. Обязательно. Файл подключается напрямую в *App.php*, через *require()*. Пример конфига:
```PHP
<?php
//config/main.php
return array_merge(
    [
        'domain' => DEBUG ? 'waredom.loc' : 'waredom.ru',
        'indexPage' => 'http://' . (DEBUG ? 'waredom.loc' : 'waredom.ru') . '/guest/',

        'minPass' => 5, //минимальная длина пароля
        'minComb' => 3, //минимальная комбинация наборов символов в пароле
    ],
    require __DIR__ . '/secret.php' //конфиг с конфиденциальной информацией
);
```

***application/i18n/XX.php***

обязательно при использовании возможностей движка по локализации сайта. Файлы **xx.php** - языковые пакеты. Подробнее о локализации см. разделе "Локализация сайта"


Примеры имен и расположение классов приложения:

    application/
        controller/
            MainController.php
        model/
            UserModel.php
            MySuperModel.php
        service/
            UserService.php
        somepath/
            ScriptOneSomepath.php
        Оrphane_one.php
        Dummyscript.php

Автозагрузчик найдет скрипты по хвостам, от последней заглавной буквы. В случае размещения скрипта в корне `application/` только первая буква имени должна быть заглавной. Это необходимое соглашение об именовании. Загрузчик пытается подключать только php-файлы, разумеется.

Наличие файла не проверяется т.к. дисковые операции дорогие по времени. Если скрипт не будет найден, получите **FATAL_ERROR** от PHP.Имхо, лучше один раз правильно организовать файлы и каталоги, чем на каждый запрос браузера проверять, есть ли нужные файлы красиво ругаться на их отсутствие.На боевом отключается вывод ошибок (константа *DEBUG = false*), так что там юзер получит пустую страницу. Настроенный лог/оповещение прилетит к админу на мыло и "*спасет отца русской демократии*" при таком казусе :)

Стоит так же отметить, что если используете роутер движка, тогда наличие `controller/` обязательно, т.к. роутер ищет файлы (в отличие от автозагрузчика) и ищет их в указанном каталоге. Подробнее см. в разделе "Роутинг"

***core/***

Ядро движка. Классов немного, пути к их скриптам жестко прописаны в автозагрузчике. Отличительных букв в именах классов нет, просто не используйте такие же имена в своих классах.

    Наследовать от ядерных классов необязательно, но рекомендуется.

***.htaccess***

Уже ставшие классическим, условия
```
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php [L,QSA]
```
невыгодны. Они проверяют **каждый запрос** в стиле "*если не файл и не каталог, то..*". Выяснение этого "если" - это проверка физического существования файла/каталога. Дисковые операции - это долго, причем тут неоправданно.

Рекомендую использовать такой:
```
RewriteEngine On
RewriteBase /
#Если запрос не совпадает с перечисленным - отправлять его в index.php
RewriteCond %{REQUEST_URI} !^/(index\.php|images|files|view/assets|robots\.txt|sitemap\.xml)
RewriteRule .* index.php [L,QSA]
```

Еще один плюс такого правила - запрещено прямое обращение к скриптам (в отличие от "классики"), все они пойдут через *index.php*. Не забудьте перенести **favicon.ico** в `images/` или добавить его в условие.

Так же можно настроить страницу с 404-й, `ErrorDocument 404 /some/handler.php?er=404` чтобы и сайт и Apache реагировали одинаково.

В каталогах статики рекомендую настраивать права доступа к файлам *0666*, запрещая их исполнение. Так же не помешает настройка web-сервера на запрет выполнения файлов статики, как скриптов. Для этого в каталоге статики ложите свой *.htaccess*:

```
php_flag engine 0
AddType "text/html" .php .cgi .pl .fcgi .fpl .phtml .shtml .php2 .php3 .php4 .php5 .asp .jsp
```

Будет работать, пока хакеры не перепищут этот файл :) И проверьте запрет доступа к этому файлу через web. Обычно конфигурация сервера защищает .ht-файлы от чтения.

Я предлагаю такой вариант для простых случаев, когда у вас только apache-сервер порт слушает. Если же статикой рулит *nginx* с проксированием остальных запросов в *apache*, то мне еще у вас учиться, а не рекомендации давать :)