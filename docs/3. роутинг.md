# Роутинг

В движке есть роутер, который при желании можно заменить на свой. Нужно в конфиге прописать FQN имя класса роутера: 

```PHP
'router' => [ 
    'class' => <FQN имя класса роутера>
 ]
```    

Для роутера есть интерфейс `\engine\IRouter`. Дальше - полная свобода.

Любой роутер должен работать в двух направлениях:
 
- вычисление нужного контроллера/действия по URL и вызов действия; 
- получение относительного URL по заданным контроллеру/действию и параметрам. 

## Роутер движка 

Класс `\engine\net\Router`
  
### Конфигурация

```PHP
'router' => [
    // 'class' => string,
     
    '404_handler'   => string,
    'log_redirects' => bool | false,
    'routes'        => array,
],
```

`class` - не используется для роутера движка. Параметр нужен для указания своего роутера. Должен содержать FQN имя класса нового роутера.

**Важно**: далее описаны настройки для роутера движка. Для иной реализации роутера они могут отличаться.

`404_handler` - FQN контроллера + метод, отвечающий при 404-й от роутера. Контроллер может нарисовать страницу с ошибкой в стиле сайта. Если настройки нет, тогда роутер ограничится только отправкой заголовка и простым сообщением. См. так же док *"Перехват HTTP-ошибок"*.

Примеры настройки:

```PHP
'404_handler' => 'app\controllers\MainController->error' // основной контроллер, метод error()
'404_handler' => 'app\controllers\ErrorController'       // отдельный контроллер, метод по умолчанию.
```

`log_redirects` - нужно ли логировать редиректы роутера. По умолчанию - отключено. Такое логирование полезно для анализа неправильных URL-ов сайта, имеющих конечные слеши. Роутер движка всегда убирает конечные слеши, об этом рассказано в конце этой статьи. В логе сообщение получит тип *"router redirect"*. Подробнее о работе логера см. док *"Логер"*

`routes` - карта маршрутов. Пример:

```PHP
...
'router' => [
    '404_handler' => 'app\controllers\ErrorContoller',
    
    'routes' => [
        //модуль юзера
        'app\modules\user\controllers' => [
            'registration' => 'RegistrationContoller',
            'login'   => 'LoginContoller',
            'logout'  => 'LoginContoller/out',
            'recover' => 'LoginContoller/recover',
            'profile' => 'ProfileContoller',
        ],
    
        //Основная зона контроллеров
        'app\controllers' => [
            'news'          =>  'NewsContoller',
            'news/<id:\d+>' => 'NewsContoller/item'
            
            ...
            
            //Общие правила. Должны быть самыми последними вообще
            '<controller:[a-z]+>' => '<controller>',
            '<controller:[a-z]+>/<action:[a-z]+>' => '<controller>/<action>',
        ]
    ],
],
...
```  

Идея описания маршрутов взята в Yii 1.x, с дополнениями. Старшие ключи массива - это пространства имен, где расположены контроллеры, указанные в подмассивах. Не пишем обратный слеш в конце. Каждый подмассив содержит описания роутов. Слева - правило, справа - controller/action. Может быть только контроллер, тогда будет взято действие по умолчанию. 

Исключаем путаницу в понятиях: слева - правило, справа - контроллер/метод, обе части вместе (левую и правую) называем роутом. По тексту так и пишем: "роут", "слева ИЛИ правило...", "справа...". Кстати, в коде роутера аналогичные переменные, `$route`, `$left` и `$right`.

Обратите внимание на имена контроллеров. Роутер ничего не убирает и не приписывает к ним. Так сделано в связи с полной сводобой именования классов (см. док  *"Базовая конфигурация > Автозагрузка"*). Т.о. если считаете допустимым, не используйте суффикс *"Controller"* в названиях ваших контроллеров. 

Ведущие слеши в обеих частях роута писать **не надо**. Это ни на что не влияет, они обрезаются перед парсингом.
 
### Поиск контроллера/действия для URL

Левая часть роута - прочти готовое regexp-выражение. В угловых скобках указываются ***именованные подстановки*** в формате `<var:regexp>`. Их можно использовать для описания правой части роута и/или для передачи в параметры соответствующего метода. 

Ограничение на имя подстановки (var): \[A-Za-z0-9_\]+

В остальном синтаксис левой части роута в точности соответствует синтаксису PCRE регулярных выражений, кроме указания модификаторов (разделители тоже писать не надо). После парсинга, правило принимает вид `'~^...pattern...$~Uiu'` и по нему проверяется полученный запрос. 

**Пример 1**

```PHP
'news/<id:\d{1,5}>' => 'NewsController/item',
```

Роут соответствует методу `NewsController::item()`, который *может принимать* один параметр $id. В любом случае указанный параметр дублируется в $_GET. Если в $_GET уже есть элемент с таким именем, его значение приоритетнее. Возможны две реализации метода:

```PHP
class NewsController extends \engine\Controller 
{
    public function item()
    {
        $id = $_GET['id']; //валидировано роутом
        ...
    }
}
```

или

```PHP
class NewsController extends \engine\Controller
{
    /**
     * Страница одной новости.
     * @param int $id валидировано роутом
     */
    public function item($id) 
    { 
        ... 
    }
}
```

**Пример 2**

```PHP
'user/<action:[a-z]+>' => 'UserController/<action>',
```

В данном случае роут подойдет для многих URL, типа: 

```
/user/login   -> UserController::login()
/user/profile -> UserController::profile()
/User/logOut  -> UserController::logOut()
```

**Важно**. Обращайте внимание на регистр букв в роутах. Если описывается статичная часть - регистр не важен. Но если это имя подстановки, тогда соблюдайте регистр букв. Это относится и к первому примеру в той же степени ($id в нижнем регистре). 

**Пример 3**

```PHP
'article/<id:\d{1,5}>[a-z_]+(/page/<page:\d+>)?' => 'StoryController'
```

Этот пример примечателен свободой URL-а, который подойдет для регулярки:

```
article/23_doll_house
article/6_ten_fear_stories/page/3
article/89_orphan/3 - а вот этот уже не подойдет, пропущен /page
```

Такому роуту должен соответствовать контроллер c заданным методом по умолчанию. Один из примеров реализации:

```PHP
class StoryController extends \engine\Controller
{
    protected $defaultAction = 'item';
    
    /**
     * Страница одной статьи. С пагинацией.
     * @param int $id валидировано роутом
     */
    public function item($id) 
    {
        $page = engine\net\Request::GET('page'); //если есть, то валидировано роутом
        ...
    }
}
```

**Важно! Роутер удаляет конечный слеш**. Поэтому никак не получится задать адрес типа `http://site.com/folder/`. Единственный адрес с конечным слешем - это корень сайта. Но там слеш имеет иной смысл: он указывает именно на корневой каталог (прямая аналогия с root-каталогом в Linux). Не я придумал, это общепринятая логика. Напоминаю, вы всегда можете создать свой роутер или переопределить методы этой реализации.

#### Простые ошибки

Описали роут, а он не работает:

- 404 = в роуте использован обратный слеш вместо прямого. Нужно использовать '/'
- 404 = справа несоблюдение регистра, например контроллер с маленькой буквы, а на деле - с большой.
- 404 = роут правильный, но не в том пространстве имен

### Получение URL по заданным параметрам

Роутер способен собрать относительный URL по имеющейся карте роутов. При необходимости получения абсолютного URL-а домен дописывайте отдельно.

function __url(array $route, array $params = [])__: _string_

где `$route` - массив `['пространство имен', 'контроллер/действие']` и вторым параметром необязательный ассоциативный массив `$params` для подстановок в роут. Функция вернет URL с ведущим слешем или пробросит ошибку.

Если роут подходит по описанию `'контроллер/действие'`, но для обеспечения его подстановок недостаточно данных в `$params`, значит это не тот роут и поиск продолжается.

Если в `$params` указано больше, чем есть подстановок в роуте, все лишнее пойдет, как набор GET-параметров в URL. 

**Пример 1**

```PHP
'routes' => [
    'app\modules\user\controllers' => [
        'user/<action:\w+>/<userId:\d+>' => 'User/<action>',
        'user/<action:\w+>/<id:\d+>'     => 'User/<action>',
        'user/login'                     => 'User/login',
    ]
]
```

Вызов где-то в клиентском коде:

```PHP
$ns = 'app\modules\user\controllers';
$profileUrl = engine\Router::url([$ns, 'User/profile'], ['id' => 43, 'show' => 'subscriptions']);
$loginUrl = engine\Router::url([$ns, 'User/login'], ['return' => '/новости/43/addcomment']); // это конечно не хардкодом :)
```

Первое правило подходит по описанию контроллера, но не сработает, потому что для него не обеспечена подстановка `userId`. Второй и третий роут вернут такие URL-ы:

```
/user/profile/43?show=subscriptions
/user/login?return=%2F%D0%BD%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8%2F43%2Faddcomment
```

Тут продемонстрированы: выбор правильного роута, обеспечение требуемых подстановок, сборка GET-параметров и их кодирование.

 **Пример 2**, на совпадение имени подстановки и параметра.

```php
'routes' => [
    'app\controllers' => [
        'story/<action:\w+>/<id:\d+>' => 'Story/<action>',
    ]
]
```

Вызов

```PHP
$ns = 'app\controllers';
$profileUrl = engine\Router::url([$ns, 'Story/fun'], ['id' => 43, 'action' => 'print', 'v1' => null]);
```

Роут сработает, но у него тоже есть `action`, как и в передаваемых параметрах. Конфликт? Не-а :) Результат будет таким:

```
/story/fun/43?action=print&v1
```

В этом же примере так же показано, как задать GET-параметр *без значения*. 

**Замечание:** приведенные URL-ы не оптимальны, они только для демонстрации возможностей роутера.

### Доп. информация

При получении запроса роутер следит за хвостовым слешем и редиректит на URL без него:

```
http://site.com/some/page/ -> http://site.com/some/page
http://site.com/give/it/?id=123 -> http://site.com/give/it?id=123

http://site.com/ -> не меняется. Тут слеш - это адрес главной страницы.
```

При желании такие редиректы можно логировать (см. описание конфига роутера в этой статье).

Неанглийские слова в URL кодируются функцией [php::urlencode()](http://php.net/manual/ru/function.urlencode.php). Домен на русском остается без изменений, т.к. это за пределами роутера.
