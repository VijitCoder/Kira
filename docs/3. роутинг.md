# Роутинг

### Прежде всего
Роутер можно заменить на свой. Нужно в конфиге прописать FQN имя класса роутера: 
```PHP
    'router' => <FQN имя класса роутера> 
```    
Для роутера есть интерфейс **IRouter**. Дальше - полная свобода.

### Роутер движка 

Теперь о роутере, встроенном в движок. Он работает в двух направлениях:
 
  - вычисление нужного контроллера/действия по URL и вызов действия; 
  - получение относительного URL по заданным контроллеру/действию и параметрам. 
  
Пример карты роутов (главный конфиг приложения):
```PHP
...
routes => [
    //модуль юзера
    APP_NS_PREFIX . 'modules\user\controllers\\' => [
        'registration' => 'RegistrationContoller',
        'login'   => 'LoginContoller',
        'logout'  => 'LoginContoller/out',
        'recover' => 'LoginContoller/recover',
        'profile' => 'ProfileContoller',
    ],

    //Основная зона контроллеров
    APP_NS_PREFIX . 'controllers\\' => [
        'news'          =>  'NewsContoller',
        'news/<id:\d+>' => 'NewsContoller/item'
        
        ...
        
        //Общие правила. Должны быть самыми последними вообще
        '<controller:[a-z]+>' => '<controller>',
        '<controller:[a-z]+>/<action:[a-z]+>' => '<controller>/<action>',
    ]
],

'errorHandler' => APP_NS_PREFIX . 'controllers\Error',
...
```  

Идея описания маршрутов взята в Yii 1.x, с дополнениями. Старшие ключи массива - это пространства имен, где расположены контроллеры, указанные в подмассивах. Каждый подмассив содержит описания роутов. Слева - правило, справа - controller/action. Может быть только контроллер, тогда будет взято действие по умолчанию. 

Исключаем путаницу в понятиях: обе части вместе (левую и правую) называем роутом. По тексту так и пишем: "роут", "слева ИЛИ правило...", "справа...". Кстати, в коде роутера аналогичные переменные, `$route`, `$left` и `$right`.

Обратите внимание на имена контроллеров. Роутер ничего не убирает и не приписывает к ним. Так сделано в связи с полной сводобой именования классов (см. док  *"Базовая конфигураци", Автозагрузка*). Если считаете допустимым, не используйте суффикс *"Controller"* в названиях ваших контроллеров. 
 
### Поиск контроллера/действия для URL

Левая часть роута - прочти готовое regexp-выражение. В угловых скобках указываются ***именованные подстановки*** в формате `<var:regexp>`. Их можно использовать для описания правой части роута и/или для передачи в параметры соответствующего метода. 

Ограничение на имя подстановки (var): \[A-Za-z0-9_\]+

В остальном синтаксис левой части роута в точности соответствует синтаксису PCRE регулярных выражений, кроме указания модификторов (разделители тоже писать не надо). После парсинга, правило принимает вид `'~^...pattern...$~Uiu'` и по нему проверяется полученный запрос. 

**Пример 1**
```PHP
'news/<id:\d{1,5}>' => 'NewsController/item',
```
Роут соответствует методу `NewsController::item()`, который *может принимать* один параметр $id. В любом случае указанный параметр дублируется в $_GET. Если в $_GET уже есть элемент с таким именем, его значение приоритетнее. Возможны две реализации метода:
```PHP
class NewsController extends \core\Controller 
{
    public function item()
    {
        $id = $_GET['id']; //валидировано роутом
        ...
    }
}
```
или
```PHP
class NewsController extends \core\Controller
{
    /**
     * Страница одной новости.
     * @param int $id валидировано роутом
     */
    public function item($id) 
    { 
        ... 
    }
}
```

**Пример 2**
```PHP
'user/<action:[a-z]+>' => 'UserController/<action>',
```
В данном случае роут подойдет для многих URL, типа: 
```
/user/login   -> UserController::login()
/user/profile -> UserController::profile()
/User/logOut  -> UserController::logOut()
```

**Важно!** Обращайте внимание на регистр букв в роутах. Если описывается статичная часть - регистр не важен. Но если это имя подстановки, тогда соблюдайте регистр букв. Это относится и к первому примеру в той же степени ($id в нижнем регистре). 

**Пример 3**
```PHP
'article/<id:\d{1,5}>[a-z_]+(/page/<page:\d+>)?' => 'StoryController'
```
Этот пример примечателен свободой URL-а, который подойдет для регулярки:
```
article/23_doll_house
article/6_ten_fear_stories/page/3
article/89_orphan/3 - а вот этот уже не подойдет, пропущен /page
```
Такому роуту должен соответствовать контроллер c заданным методом по умолчанию. Пример реализации:
```PHP
class StoryController extends \core\Controller
{
    protected $defaultAction = 'item';
    
    /**
     * Страница одной статьи. С пагинацией.
     * @param int $id валидировано роутом
     */
    public function item($id) 
    {
        $page = utils\VarRequest::get('page'); //если есть, то валидировано роутом
        ...
    }
}
```


## Получение URL по заданным параметрам

Роутер способен собрать относительный URL по имеющейся карте роутов. При необходимости получения абсолютного URL-а домен дописывайте отдельно.
```
public static function url(array $route, array $params = []);
```
где `$route` - массив `['пространство имен', 'контроллер/действие']` и вторым параметром необязательный ассоциативный массив `$params` для подстановок в роут. Функция вернет URL с ведущим слешем или пробросит ошибку.

Если роут подходит по описанию `'контроллер/действие'`, но для обеспечения его подстановок недостаточно данных в `$params`, значит это не тот роут и поиск продолжается.

Если в `$params` указано больше, чем есть подстановок в роуте, все лишнее пойдет как набор GET-параметров в URL. 

**Пример 1**
```PHP
routes => [
    APP_NS_PREFIX . 'modules\user\controllers\\' => [
        'user/<action:\w+>/<userId:\d+>' => 'User/<action>',
        'user/<action:\w+>/<id:\d+>'     => 'User/<action>',
        'user/login'                     => 'User/login',
    ]
]
```
Вызов где-то в клиентском коде:
```PHP
$ns = APP_NS_PREFIX . 'modules\user\controllers\\';
$profileUrl = core\Router::url([$ns, 'User/profile'], ['id' => 43, 'edit' => 'subscriptions']);
$loginUrl = core\Router::url([$ns, 'User/login'], ['return' => '/новости/43/addcomment']); //это конечно не хардкодом :)
```
Первое правило подходит по описанию контроллера, но не сработает, потому что для него не обеспечена подстановка `userId`. Второй и третий роут вернут такие URL-ы:
```
/user/profile/43?edit=subscriptions
/user/login?return=%2F%D0%BD%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8%2F43%2Faddcomment
```
Тут подемонстрированы: выбор правильного роута, обеспечение требуемых подстановок, сборка GET-параметров и их кодирование.

 **Пример 2**, на совпадение имени подстановки и параметра.
```php
routes => [
    APP_NS_PREFIX . 'controllers\\' => [
        'story/<action:\w+>/<id:\d+>' => 'Story/<action>',
    ]
]
```
Вызов
```PHP
$ns = APP_NS_PREFIX . 'controllers\\';
$profileUrl = core\Router::url([$ns, 'Story/fun'], ['id' => 43, 'action' => 'print', 'v1' => null]);
```
Роут сработает, но у него тоже есть `action`, как и в передаваемых параметрах. Конфликт? Не-а :) Результат будет таким:
```
/story/fun/43?action=print&v1
```
В этом же примере показано, как задать GET-параметр *без значения*. 

**Замечание:** приведенные URL-ы не оптимальны, они только для демонстрации возможностей роутера.

## Доп. информация

При получении запроса роутер следит за хвостовым слешем и редиректит на URL без него:
```
    http://site.com/some/page/ -> http://site.com/some/page
    http://site.com/give/it/?id=123 -> http://site.com/give/it?id=123
    
    http://site.com/ -> не меняется. Тут слеш - это адрес главной страницы.
```

Ведущие слеши в обеих частях роута писать **не надо**. Это ни на что не влияет, они обрезаются перед парсингом.

Неанглийские слова в URL кодируются функцией [php::urlencode()](http://php.net/manual/ru/function.urlencode.php). Домен на русском остается без изменений, т.к. это за пределами роутера.

Роутеру в конфиге нужна настройка `errorHandler` (см. док *"Базовая конфигурация"*). В ней указывается контроллер/действие (с пространством имен), который будет отвечать браузеру при 404 ошибке. Если настройки нет, тогда роутер ограничится только отправкой заголовка '404 Not found'. Ловить код ошибки в методе можно функцией [php::http_response_code()](http://php.net/manual/ru/function.http-response-code.php)

<small><p>Offtopic: пустая страница с 404 заголовком - сомнительная выгода. Я думаю, что web-сервер не возьмет на себя генерацию страницы, если PHP отправит только заголовок 404. Полагаю, сервер отвечает своей страницей, только если он сам ресурс не нашел. Короче, рекомендую завести свой метод для отрисовки 404-й и объявить его в <i>errorHandler</i>, хотя бы для роутера.</p></small>

