# Роутинг

### Прежде всего

Роутер можно заменить на свой. Нужно в конфиге прописать FQN имя класса роутера: 

```PHP
    'router' => <FQN имя класса роутера> 
```    

Для роутера есть интерфейс `engine\IRouter`. Дальше - полная свобода.

### Роутер движка 

Класс `engine\net\Router`

Он работает в двух направлениях:
 
  - вычисление нужного контроллера/действия по URL и вызов действия; 
  - получение относительного URL по заданным контроллеру/действию и параметрам. 
  
Пример карты роутов (главный конфиг приложения):
```PHP
...
routes => [
    //модуль юзера
    'app\modules\user\controllers' => [
        'registration' => 'RegistrationContoller',
        'login'   => 'LoginContoller',
        'logout'  => 'LoginContoller/out',
        'recover' => 'LoginContoller/recover',
        'profile' => 'ProfileContoller',
    ],

    //Основная зона контроллеров
    'app\controllers' => [
        'news'          =>  'NewsContoller',
        'news/<id:\d+>' => 'NewsContoller/item'
        
        ...
        
        //Общие правила. Должны быть самыми последними вообще
        '<controller:[a-z]+>' => '<controller>',
        '<controller:[a-z]+>/<action:[a-z]+>' => '<controller>/<action>',
    ]
],

'errorHandler' => 'app\controllers\Error',
...
```  

Идея описания маршрутов взята в Yii 1.x, с дополнениями. Старшие ключи массива - это пространства имен, где расположены контроллеры, указанные в подмассивах. Не пишем обратный слеш в конце. Каждый подмассив содержит описания роутов. Слева - правило, справа - controller/action. Может быть только контроллер, тогда будет взято действие по умолчанию. 

Исключаем путаницу в понятиях: обе части вместе (левую и правую) называем роутом. По тексту так и пишем: "роут", "слева ИЛИ правило...", "справа...". Кстати, в коде роутера аналогичные переменные, `$route`, `$left` и `$right`.

Обратите внимание на имена контроллеров. Роутер ничего не убирает и не приписывает к ним. Так сделано в связи с полной сводобой именования классов (см. док  *"Базовая конфигураци", Автозагрузка*). Если считаете допустимым, не используйте суффикс *"Controller"* в названиях ваших контроллеров. 
 
### Поиск контроллера/действия для URL

Левая часть роута - прочти готовое regexp-выражение. В угловых скобках указываются ***именованные подстановки*** в формате `<var:regexp>`. Их можно использовать для описания правой части роута и/или для передачи в параметры соответствующего метода. 

Ограничение на имя подстановки (var): \[A-Za-z0-9_\]+

В остальном синтаксис левой части роута в точности соответствует синтаксису PCRE регулярных выражений, кроме указания модификторов (разделители тоже писать не надо). После парсинга, правило принимает вид `'~^...pattern...$~Uiu'` и по нему проверяется полученный запрос. 

**Пример 1**
```PHP
'news/<id:\d{1,5}>' => 'NewsController/item',
```
Роут соответствует методу `NewsController::item()`, который *может принимать* один параметр $id. В любом случае указанный параметр дублируется в $_GET. Если в $_GET уже есть элемент с таким именем, его значение приоритетнее. Возможны две реализации метода:
```PHP
class NewsController extends \engine\Controller 
{
    public function item()
    {
        $id = $_GET['id']; //валидировано роутом
        ...
    }
}
```
или
```PHP
class NewsController extends \engine\Controller
{
    /**
     * Страница одной новости.
     * @param int $id валидировано роутом
     */
    public function item($id) 
    { 
        ... 
    }
}
```

**Пример 2**
```PHP
'user/<action:[a-z]+>' => 'UserController/<action>',
```
В данном случае роут подойдет для многих URL, типа: 
```
/user/login   -> UserController::login()
/user/profile -> UserController::profile()
/User/logOut  -> UserController::logOut()
```

**Важно!** Обращайте внимание на регистр букв в роутах. Если описывается статичная часть - регистр не важен. Но если это имя подстановки, тогда соблюдайте регистр букв. Это относится и к первому примеру в той же степени ($id в нижнем регистре). 

**Пример 3**
```PHP
'article/<id:\d{1,5}>[a-z_]+(/page/<page:\d+>)?' => 'StoryController'
```
Этот пример примечателен свободой URL-а, который подойдет для регулярки:
```
article/23_doll_house
article/6_ten_fear_stories/page/3
article/89_orphan/3 - а вот этот уже не подойдет, пропущен /page
```
Такому роуту должен соответствовать контроллер c заданным методом по умолчанию. Пример реализации:
```PHP
class StoryController extends \engine\Controller
{
    protected $defaultAction = 'item';
    
    /**
     * Страница одной статьи. С пагинацией.
     * @param int $id валидировано роутом
     */
    public function item($id) 
    {
        $page = engine\net\Request::GET('page'); //если есть, то валидировано роутом
        ...
    }
}
```

**Важно! Роутер удаляет конечный слеш**. Поэтому никак не получится задать адрес типа `http://site.com/folder/`. Единственный адрес с конечным слешем - это корень сайта. Но там слеш имеет иной смысл: он указывает именно на корневой каталог (прямая аналогия с root-каталогом в Linux). Не я придумал, это общепринятая логика. Напоминаю, вы всегда можете создать свой роутер или переопределить методы этой реализации.

## Получение URL по заданным параметрам

Роутер способен собрать относительный URL по имеющейся карте роутов. При необходимости получения абсолютного URL-а домен дописывайте отдельно.
```
public static function url(array $route, array $params = []);
```
где `$route` - массив `['пространство имен', 'контроллер/действие']` и вторым параметром необязательный ассоциативный массив `$params` для подстановок в роут. Функция вернет URL с ведущим слешем или пробросит ошибку.

Если роут подходит по описанию `'контроллер/действие'`, но для обеспечения его подстановок недостаточно данных в `$params`, значит это не тот роут и поиск продолжается.

Если в `$params` указано больше, чем есть подстановок в роуте, все лишнее пойдет как набор GET-параметров в URL. 

**Пример 1**
```PHP
routes => [
    'app\modules\user\controllers' => [
        'user/<action:\w+>/<userId:\d+>' => 'User/<action>',
        'user/<action:\w+>/<id:\d+>'     => 'User/<action>',
        'user/login'                     => 'User/login',
    ]
]
```
Вызов где-то в клиентском коде:
```PHP
$ns = 'app\modules\user\controllers';
$profileUrl = engine\Router::url([$ns, 'User/profile'], ['id' => 43, 'edit' => 'subscriptions']);
$loginUrl = engine\Router::url([$ns, 'User/login'], ['return' => '/новости/43/addcomment']); //это конечно не хардкодом :)
```
Первое правило подходит по описанию контроллера, но не сработает, потому что для него не обеспечена подстановка `userId`. Второй и третий роут вернут такие URL-ы:
```
/user/profile/43?edit=subscriptions
/user/login?return=%2F%D0%BD%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8%2F43%2Faddcomment
```
Тут подемонстрированы: выбор правильного роута, обеспечение требуемых подстановок, сборка GET-параметров и их кодирование.

 **Пример 2**, на совпадение имени подстановки и параметра.
```php
routes => [
    'app\controllers' => [
        'story/<action:\w+>/<id:\d+>' => 'Story/<action>',
    ]
]
```
Вызов
```PHP
$ns = 'app\controllers';
$profileUrl = engine\Router::url([$ns, 'Story/fun'], ['id' => 43, 'action' => 'print', 'v1' => null]);
```
Роут сработает, но у него тоже есть `action`, как и в передаваемых параметрах. Конфликт? Не-а :) Результат будет таким:
```
/story/fun/43?action=print&v1
```
В этом же примере показано, как задать GET-параметр *без значения*. 

**Замечание:** приведенные URL-ы не оптимальны, они только для демонстрации возможностей роутера.

## Доп. информация

При получении запроса роутер следит за хвостовым слешем и редиректит на URL без него:
```
    http://site.com/some/page/ -> http://site.com/some/page
    http://site.com/give/it/?id=123 -> http://site.com/give/it?id=123
    
    http://site.com/ -> не меняется. Тут слеш - это адрес главной страницы.
```

Ведущие слеши в обеих частях роута писать **не надо**. Это ни на что не влияет, они обрезаются перед парсингом.

Неанглийские слова в URL кодируются функцией [php::urlencode()](http://php.net/manual/ru/function.urlencode.php). Домен на русском остается без изменений, т.к. это за пределами роутера.

#### Конфиг 'errorHandler'

Роутер будет сбрасывать любые http-статусы от 400 и выше в `errorHandler`. В этой настройке указывается контроллер и действие, которые будут отвечать браузеру при ошибках (синтаксис описания см. в доке *"Базовая конфигурация"*).
 
Используя роутер движка в сочетании с заданным `errorHandler` можно организовать централизованную выдачу страниц с ошибками в стиле сайта. Ловить код ошибки в хендлере можно функцией [php::http_response_code()](http://php.net/manual/ru/function.http-response-code.php)
 
- когда роутер не сможет найти соответствие для запрошенного URL, установит код http-статуса "404" и вызовет `errorHandler`. 

- у веб-сервера могут быть указаны скрипты, которые будут собирать страницу при ошибках. В частности Apache позволяет выдавать свои страницы для 401, 403, 404 и 500 кода (см. директиву *ErrorDocument*). Такие ошибки от веб-сервера так же попадут в `errorHandler`.

**Важно!** Чтобы ни было прописано у сервера для ошибок, запрос получат те контроллер/действие, которые указаны в конфиге `errorHandler`. Это из-за правила mod_rewrite в главном .htaccess, если оно у вас есть конечно. Любой запрос пойдет через *index.php > router > errorHandler*.

Если настройки нет, тогда роутер ограничится только отправкой заголовка с кодом ошибки.  
 
