# Базовая конфигурация

## Константы

Если не указано иное, считать константу с типом *string*.

**ROOT_PATH** - физический путь от корня тома (диска) к корневому каталогу сайта. Завершающий слеш. Кроссплатформа, все слеши приводятся в прямым.

**APP_NS_PREFIX** - префикс пространства имен приложения. Используется в автозагрузчике. Все классы приложения, должны быть в его подпространстве. Это [требование стандарта PSR-4] (http://www.php-fig.org/psr/psr-4/ru/) к автозагрузчику классов.

**APP_PATH** - физический каталог со скриптами приложения (корень). Кроме прочего, используется автозагрузчиком классов.

*Константы APP_NS_PREFIX и APP_PATH в сочетании дают гибкое управление приложением. Например, нужно переключиться на другую версию, она в соседнем каталоге. Переписываем APP_PATH. А если запускаем принципиально иное приложение, можно пространство имен вести от другого корня и переписать APP_NS_PREFIX.*

**VIEWS_PATH** - физический путь к шаблонам приложения. Они могут быть где угодно, для этого и введена константа.

**ASSETS_URL**  - относительный URL к css/js приложения. Путь к статике светится в браузере, поэтому ее нужно разместить, не компроментируя иерархию приложения.

**MAIN_CONFIG** - путь к файлу основноЙ конфигурации приложения.

**DEBUG** ( *boolean* ) - флаг отладки.

## Автозагрузка классов и правила именования

Как было сказано выше, автозагрузчик написан почти по стандарту PSR-4. Коротко требования такие: каждый класс должен быть в объявленном пространстве имен. Пространство имен должно соответствовать иерархии каталогов. Все пространства имен приложения должны иметь один корень (префикс), обявленный в константе **APP_NS_PREFIX**. Префикс `'core/'`  занят движком. 

В именовании учитывается соблюдение регистра. Нет требований к самим именам каталогов и классов. Это плюс :) Еще один плюс в теоретической возможности подключения сторонних библиотек, огранизованных в своих пространствах имен со своими загрузчиками. А минус в том, что манипуляции с пространствами имен занимают лишее время.

Автозагрузчик работает FQN именем класса, т.е. полное пространство имен + имя класса. Если префикс в FQN совпадает с **APP_NS_PREFIX**, тогда читает базовый каталог из константы **APP_PATH**, от имени класса отбрасывает префикс, остальное превращает в путь + имя скрипта и пытается его подключить (стандарт PSR-4). Если префикс не совпал, значит база = корень сайта, загрузчик ищет согласно полному описанию пространства имен (не стандарт).

В случае отсутствия файла автозагрузчик просто прекращает работу. Управление передается следующему загрузчику, зарегистрированному функцией *spl_autoload_register()*.

Отдельно подключается скрипт движка `core/Interfaces.php`. Просто все интерфейсы собраны в один файл, поэтому автозагрузчик их не найдет.

Теоретически допустимо хранить несколько классов в одном скрипте, но автозагрузчик их не найдет. Т.е. работать последующие классы будут, только если имя первого отвечает требованиям выше и он уже загружен. Во избежание казусов рекомендуется хранить один класс = один файл.

Хотя нет жестких требований к именованию классов, рекомендую дописывать в конце их положение в слоях приложения: *UserModel, AuthService, StringHelper* и т.д. Это не повлияет на процесс загрузки, но удобно при чтении кода программистом. Исключение можно сделать для контроллеров, т.к. с их именами будет работать только роутер.

## Конфиг приложения

Путь к основному конфигурационному файлу приложения задается в константе **MAIN_CONFIG**. Сам файл конфигурации - php-скрипт, возвращающий ассоциативный массив. Пример конфига:
```PHP
return array_merge(
    [
        'indexHandler' => APP_NS_PREFIX . 'controllers\MainController->welcome',
        'errorHandler' => APP_NS_PREFIX . 'controllers\ErrorController',
        
        //'router'     => APP_NS_PREFIX . 'CustomRouter',
        'routes' => require __DIR__ . '/routes.php',
        
        'minPass' => 5, 
        'minComb' => 3,
        
        'db' => [
            'dsn'      => 'mysql:dbname=base0; host=127.0.0.1; charset=UTF8',
            'user'     => 'guest',
            'password' => '',
            'options' => [
                PDO::ATTR_TIMEOUT => 10,                         
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,     
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
            ],
        ],

    ],
    
    require __DIR__ . '/env.php' //сливаемся с конфигом среды окружения (конфиг конкретного сервера)
);
```

Движку требуется наличие нескольких обязательных параметров. Так же существует несколько рекомендуемых параметров.
***indexHandler***  - **обязательный параметр**. Контроллер приложения по умолчанию. Полностью определённое имя класса (FQN), от корневого пространства имен. Так же нужно указать метод, если он отличается от дефолтного. См. пример выше.

***routes*** - обязательная настройка, если используете роутер движка. Массив с роутами. Подробнее см. в "Роутинг". 

***errorHandler*** - рекомендуемая настройка. В ней указывается контроллер (с пространством имен) + метод, обрабатывающий ответы с HTTP кодами 401-404, 500. В реализации метода можно использовать [*http_response_code()*] (http://php.net/manual/ru/function.http-response-code.php) для определения кода ошибки.

Примеры настройки:
`'errorHandler' => APP_NS_PREFIX . 'controllers\MainController->error'` - основной контроллер, метод error()
`'errorHandler' => APP_NS_PREFIX . 'controllers\ErrorController'` - отдельный контроллер, метод по умолчанию.

***router*** - необязательный параметр. Если пишете свой роутер, укажите путь к нему (пространство имен + имя класса). 

Замечание: *следует помнить, что требуемые скрипты должны находится в каталоге приложения, иначе автозагрузчик их не найдет.*

***db*** - условно-обязательная настройка. Ассоциативный массив. Требуется, только если приложение работает с базами данных через PDO, используя при этом функционал движка. Проще говоря, движок здесь ищет строку подключения и ключи к БД.
