# Перехват ошибок

Класс `\kira\Handlers`. В нем описан перехватчик для исключений, не пойманных ранее, а так же обработчики PHP-ошибок.

## Исключения

Движок кидается несколькими собственными исключениями, см. каталог [exceptions/]. Так же могут быть проброшены исключения PHP SPL.

В движке назначен перехватчик для любых исключений, не пойманных ранее. Так же движком отдельно перехватываются и обрабатываются `\PDOException` (см. док *"DB"*).

**Если исключение не ловит код приложения**, то поведение перехватчика зависит от окружения. А именно: в режиме отладки (`KIRA_DEBUG = true`) все ошибки выдаются в *output* как есть, логи не пишутся; c отключенной отладкой юзеру будет выдана html-заглушка с сообщением типа *"Ошибка, зайдите позже"*. Перехватчик так же попытается логировать ошибку, если это не было сделано ранее. Необходимость логирования определяется по факту, указано ли предыдущее исключение.

Поясню на примере, реализованном в движке. Когда на *production* возникает сбой подключения к базе, в классе *DBConnection* ловим *PDOException*. Пишем ошибку в лог и пробрасываем дальше **свое DbException с указанием предыдущего исключения**. Если код приложения его не поймает, конечный перехватчик выдаст заглушку юзеру. Видя, что это не единственное исключение в цепочке, он не будет писать ошибку в лог.

Проще говоря: на проде все полезное делаем непосредственно там, где возникло исключение, на деве - передаем ситуацию разработчику как есть.

## Ошибки PHP

На самом деле реальной необходимости в своих обработчиках нет, PHP сам неплохо информирует об ошибках. Но я сделал свое оформление и свое логирование в файл. Мне так больше нравится, чем оранжево-черная таблица PHP.

Обработчик ошибок назначен в `autoloader.php` через функцию [set_error_handler()](http://php.net/manual/ru/function.set-error-handler.php). Согласно мануала, назначенный перехватчик вызывается независимо от настройки `error_reporting`. Поэтому проверяем, требуется ли сообщать о полученной ошибке. Если да - рисуем ответ, скидываем сообщение в лог `KIRA_TEMP_PATH/kira_php_error.log`.

*Константа **KIRA_TEMP_PATH** задана в `index.php`. Сам каталог должен существовать и разрешать права на запись для web-сервера.*

Обычно бывает так: на локалке/деве всё включено - будут валиться сообщения в браузер. На проде все отключено - логируем.

Опять же по мануалу, если этот обработчик не прервет выполнение вызвав `exit()`, то программа продолжится. Если вернет FALSE - ошибку получит стандартный обработчик и мы увидим еще и его сообщение. Поэтому мой перехватчик работает так: обработал ошибку; если код соответствует какому-то *_ERROR - выход из приложения, потому что ошибка критическая; иначе, возвращает TRUE, чтоб стандартный обработчик не дублировал сообщение в своем стиле.

По константам кодов см. <http://php.net/manual/ru/errorfunc.constants.php>

Ликбез на [Хабре](https://habrahabr.ru/post/134499/)

---

Есть проблема: мой обработчик не ловит ошибки типа E_ERROR | E_PARSE | E_COMPILE_ERROR. Выход из ситуации - ловить их в самом завершении программы. Для этого в *autoloader.php* назначена еще одна своя функция через [register_shutdown_function()](http://php.net/manual/ru/function.register-shutdown-function.php).

Логика следующая: возникла фатальная ошибка, PHP нарисовал сообщение, отправил в браузер и завершает работу. Тут запускается моя *shutdown*-функция. В ней кроме прочего проверяем, была ли ошибка и какой у нее код. Если совпадает с ожидаемым кодом, вызываем мой обоработчик ошибок. Но проблема тут в том, что PHP **уже ответил браузеру сообщением** и мое красиво оформленное сообщение полетит следом. Фигня получается.

Поэтому используем буферизацию вывода. Она включается прямо перед назначением *shutdown*-функции, а отправка буфера происходит в самой функции. Теперь при фатальных ошибках внутри *shutdown*-функции **сбрасывается буфер с сообщением PHP**, вызывается мой обработчик, который сообщает тоже самое, но в моем оформлении.

Минусы:
- *shutdown*-функция работает всегда, даже если ошибок нет;
- буферизация вывода возможно будет мешать в каком-то хитро придуманном коде. Не уверен.

Отключить все это дело легко: закоментировать в `autoloader.php` назначеннную *shutdown*-функцию и буферизацию.

#### Ошибки в консоли

При использовании движка в консоли (например, через `Convisor`), исключения и ошибки PHP приводятся в относительно читабельный вид, только без раскраски и тегов, разумеется. Подробнее о работе движка в консоли см. в доке *"Консоль"*

## Ситуация с PHP 7

Вот [хорошая статья (en)](https://trowski.com/2015/06/24/throwable-exceptions-and-errors-in-php7/) по поводу превращения `FATAL ERROR` и `RECOVERABLE ERROR` в исключения класса `Error`. В двух словах, в некоторых случаях PHP теперь способно не уронить приложение, а пробосить исключение типа `Error` или его потомков.

Я решил не вносить путаницу в обработчики. Если летит исключение, его ловит `exceptionHandler`, если ошибка - `errorHandler`. Т.о. в некоторых случаях вы можете увидеть непойманное вашим кодом **исключение** вместо ошибки. Но поскольку оформление у них одинаковое, я думаю, визуально проблемы не должно быть.

А вот где будет проблема, так это в логировании. Т.е. на боевом сайте ошибки не выдаются в браузер, для исключения есть отдельная "user-friendly" страница. При этом пишутся в логи. И тут есть разница: исключения попадают в лог сайта, если он у вас включен, а ошибки PHP складываются в обычный текстовик. Т.е. может случиться так, что вы не узнаете о проблеме в коде просто потому, что она логируется не туда. В принципе, набором неких костылей можно передавать сообщение и данные из `exceptionHandler` в `errorHandler`. И костыли получатся плохо читабельные. Нужно ли это реализовывать? Пока оставил этот вопрос открытым.
