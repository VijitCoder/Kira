# Перехват ошибок

Класс `\kira\Handlers`. В нем описан перехватчик для исключений, не пойманных ранее, а так же обработчики PHP-ошибок.

Они назначены в `bootstrap.php` движка, вызываются внутренним механизмом PHP и не ожидают прямого обращения из кода приложения.

Различаются типы запросов: консоль, ajax или запрос обычной html-страницы. Сообщения оформляются по-разному. Объем полезной информации зависит от режима KIRA_DEBUG.

## Исключения

Движок кидается несколькими собственными исключениями, см. каталог [exceptions/]. Так же могут быть проброшены исключения PHP SPL.

В движке назначен перехватчик для любых исключений, не пойманных ранее. Так же движком отдельно перехватываются и обрабатываются `\PDOException` (см. док *"DB"*).

**Если исключение не ловит код приложения**, то поведение перехватчика зависит от окружения. А именно: в режиме отладки (`KIRA_DEBUG = true`) все ошибки выдаются в *output* как есть, логи не пишутся; c отключенной отладкой юзеру будет выдана html-заглушка с сообщением типа *"Ошибка, зайдите позже"*. Перехватчик так же попытается логировать ошибку, если это не было сделано ранее. Необходимость логирования определяется по факту, указано ли предыдущее исключение.

Поясню на примере, реализованном в движке. Когда на *production* возникает сбой подключения к базе, в классе *DBConnection* ловим *PDOException*. Пишем ошибку в лог и пробрасываем дальше **свое DbException с указанием предыдущего исключения**. Если код приложения его не поймает, конечный перехватчик выдаст заглушку юзеру. Видя, что это не единственное исключение в цепочке, он не будет писать ошибку в лог.

Проще говоря: на проде все полезное делаем непосредственно там, где возникло исключение, на деве - передаем ситуацию разработчику как есть.

Понятие *"output"* растяжимое, это учтено: в консоль пойдет раскрашенное сообщение, на ajax-запрос вернется json-объект, на обычный запрос - html-страница.

## Ошибки PHP

На самом деле реальной необходимости в своих обработчиках нет, PHP сам неплохо информирует об ошибках. Но я сделал свое оформление и свое логирование в файл. Мне так больше нравится, чем оранжево-черная таблица PHP на любые типы запросов.

Обработчик ошибок назначен через функцию [set_error_handler()](http://php.net/manual/ru/function.set-error-handler.php). Согласно мануала, назначенный перехватчик вызывается независимо от настройки `error_reporting`. Поэтому проверяем, требуется ли сообщать о полученной ошибке. Если да - рисуем полноценный ответ, иначе скидываем сообщение в лог `KIRA_TEMP_PATH/kira_php_error.log` и в ответе возвращаем дежурное неинформативное сообщение.

*Константа **KIRA_TEMP_PATH** задана в `index.php`. Сам каталог должен существовать и разрешать права на запись для web-сервера.*

Обычно бывает так: на локалке/деве всё включено - будут валиться сообщения в браузер. На проде все отключено - логируем, дежурный мессадж в браузер.

Опять же по мануалу, если этот обработчик не прервет выполнение вызвав `exit()`, то программа продолжится. Если вернет FALSE - ошибку получит стандартный обработчик и мы увидим еще и его сообщение. Поэтому мой перехватчик работает так: обработал ошибку; если код соответствует какому-то *_ERROR - выход из приложения, потому что ошибка критическая; иначе, возвращает TRUE, чтоб стандартный обработчик не дублировал сообщение в своем стиле.

По константам кодов см. <http://php.net/manual/ru/errorfunc.constants.php>

Ликбез на [Хабре](https://habrahabr.ru/post/134499/)

---

Есть проблема: мой обработчик не ловит ошибки типа E_ERROR | E_PARSE | E_COMPILE_ERROR. Выход из ситуации - ловить их в самом завершении программы. Для этого в *autoloader.php* назначена еще одна своя функция через [register_shutdown_function()](http://php.net/manual/ru/function.register-shutdown-function.php).

Логика следующая: возникла фатальная ошибка, PHP нарисовал сообщение, отправил в браузер и завершает работу. Тут запускается моя *shutdown*-функция. В ней кроме прочего проверяем, была ли ошибка и какой у нее код. Если совпадает с ожидаемым кодом, вызываем мой обоработчик ошибок. Но проблема тут в том, что PHP **уже ответил браузеру сообщением** и мое красиво оформленное сообщение полетит следом. Фигня получается.

Поэтому используем буферизацию вывода. Она включается прямо перед назначением *shutdown*-функции, а отправка буфера происходит в самой функции. Теперь при фатальных ошибках внутри *shutdown*-функции **сбрасывается буфер с сообщением PHP**, вызывается мой обработчик, который сообщает тоже самое, но в моем оформлении.

Минусы:
- *shutdown*-функция работает всегда, даже если ошибок нет;
- буферизация вывода возможно будет мешать в каком-то хитро придуманном коде. Не уверен.

Отключить все это дело легко: закоментировать в `autoloader.php` назначеннную *shutdown*-функцию и буферизацию.

#### Ошибки в консоли

При использовании движка в консоли (например, через `Convisor`), исключения и ошибки PHP приводятся в относительно читабельный вид, только без раскраски и тегов, разумеется. Подробнее о работе движка в консоли см. в доке *"Консоль"*

## Ситуация с PHP 7

Вот [хорошая статья (en)](https://trowski.com/2015/06/24/throwable-exceptions-and-errors-in-php7/) по поводу превращения `FATAL ERROR` и `RECOVERABLE ERROR` в исключения класса `Error`. В двух словах, в некоторых случаях PHP теперь способно не уронить приложение, а пробосить исключение типа `Error` или его потомков.

Я решил не вносить путаницу в обработчики. Если летит исключение, его ловит `exceptionHandler`, если ошибка - `errorHandler`. Т.о. в некоторых случаях вы можете увидеть непойманное вашим кодом **исключение** вместо ошибки. Но поскольку оформление у них одинаковое, я думаю, визуально проблемы не должно быть.

А вот где будет проблема, так это в логировании. Т.е. на боевом сайте ошибки не выдаются в браузер, для исключения есть отдельная "user-friendly" страница. При этом пишутся в логи. И тут есть разница: исключения попадают в лог сайта, если он у вас включен, а ошибки PHP складываются в обычный текстовик. Т.е. может случиться так, что вы не узнаете о проблеме в коде просто потому, что она логируется не туда. В принципе, набором неких костылей можно передавать сообщение и данные из `exceptionHandler` в `errorHandler`. И костыли получатся плохо читабельные. Нужно ли это реализовывать? Пока оставил этот вопрос открытым.

Почему вообще пишем инфу в разные места? Ну это очевидно :) Ошибки PHP куда серьезнее, нужно максимально просто их сохранить и закруглиться. А если писать их, как и лог, в базу, не факт, что это будет просто и быстро.

[UPD] Разобравшись в ситуации, я пришел к выводу, что по сути в PHP 7.0 мне нужно только логировать по-разному пойманные исключения. Тип `Exception` - через логер, тип `Error` - в файл php-ных ошибок. Более того, как заявлено в указанной выше статье, если не поймать исключение типа `Error`, то оно, как и раньше, обернется `E_FATAL_ERROR`:

> An uncaught exception will also continue to be a fatal error in PHP 7.

Я попробовал изобрести решение, но не хочу писать в разные логи их перехватчика исключений, не нравится такое решение.
Другой вариант: исключение типа `Error` из перехватчика исключений пробрасывать дальше. И да, оно-таки работает, но не так, как хотелось бы: к сообщению об ошибке добивается стек вызова, все в одном параметре.

Короче, разработчики придумали этот тип не для осложнения мне жизни, а чтобы дать возможность клиентскому коду разруливать часть фатальных ошибок на уровне исключений. Например, вызывать `final` секцию. Акцент тут на "клиентский код". Я решил не переть против прогресса. Если ваш клиентский код не расположен работать с новым типом исключений, но тем не менее вы используете PHP >= 7.0, тогда получите обработку движка, как она запланирована: `Error` будет пойман через перехватчиком **исключений** с попыткой логирования через логер.

Вопрос закрыт.
