# Перехват ошибок

Класс `\engine\Handlers`. В нем описан перехватчик для исключений, не пойманных ранее, а так же обработчики PHP-ошибок. 

## Исключения

В движке назначен перехватчик для любых исключений, не пойманных ранее. Так же движком перехватываются и особо обрабатываются `PDOException` (см. док *"DB"*). Поведение перехватчиков зависит от окружения. А именно..

**Если исключение не ловит код приложения**, то в режиме отладки (`DEBUG = true`) все ошибки выдаются в *output* как есть, логи не пишутся; c отключенной отладкой юзеру будет выдана html-заглушка с сообщением типа *"Ошибка, зайдите позже"*. Это делает конечный перехватчик. Он же попытается логировать ошибку, если это не было сделано ранее. Необходимость логирования определяется по факту, указано ли предыдущее исключение. 

Поясню на примере, реализованном в движке. Когда на *production* возникает сбой подключения к базе, в классе *DBConnection* ловим *PDOException*. Пишем ошибку в лог и пробрасываем дальше **обычное Exception с указанием предыдущего исключения**. Если код приложения его не поймает, конечный перехватчик выдаст заглушку юзеру. Видя, что это не единственное исключение в цепочке, он не будет писать ошибку в лог.

Проще говоря: на проде все полезное делаем непосредственно там, где возникло исключение, на деве - передаем ситуацию разработчику как есть.

## Ошибки PHP

На самом деле реальной необходимости в своих обработчиках нет, PHP сам неплохо информирует об ошибках. Но я сделал свое оформление и свое логирование в файл. Мне так больше нравится, чем оранжево-черная таблица PHP. 

Обработчик ошибок назначен в `autoloader.php` через функцию [set_error_handler()] (http://php.net/manual/ru/function.set-error-handler.php). Ловит все типы ошибок, но выдает в бразуер только то, что задано через `error_reporting`. Иначе пишет сообщение в `TEMP_PATH/kira_php_error.log`, константа **TEMP_PATH** задана в `index.php`. Сам каталог должен существовать и разрешать права на запись для web-сервера.

Есть проблема: мой обработчик не ловит ошибки типа E_ERROR | E_PARSE | E_COMPILE_ERROR. Выход из ситуации - ловить их в самом завершении программы. Для этого в *autoloader.php* назначена еще одна своя функция через [register_shutdown_function()] (http://php.net/manual/ru/function.register-shutdown-function.php). 

Логика следующая: возникла фатальная ошибка, PHP нарисовал сообщение, отправил в браузер и завершает работу. Тут запускается моя *shutdown*-функция. В ней кроме прочего проверяем, была ли ошибка и какой у нее код. Если совпадает с ожидаемым кодом, вызываем мой обоработчик ошибок. Но проблема тут в том, что PHP **уже ответил браузеру сообщением** и мое красиво оформленное сообщение полетит следом. Фигня получается.

Поэтому используем буферизацию вывода. Она включается прямо перед назначением *shutdown*-функции, а отправка буфера происходит в самой функции. Теперь при фатальных ошибках внутри *shutdown*-функции **сбрасывается буфер с сообщением PHP**, вызывается мой обработчик, который сообщает тоже самое, но в моем оформлении.

Минусы:
- *shutdown*-функция работает всегда, даже если ошибок нет;
- буферизация вывода возможно будет мешать в каком-то хитро придуманном коде. Не уверен.

Отключить все это дело легко: закоментировать в `autoloader.php` назначеннную *shutdown*-функцию и буферизацию. 
