# DB

ORM нет никакой. Мне не нравятся конструкторы запросов. Я считаю неправильным такой подход: писать sql-запрос конструктором (иногда значительно больше, чем прямым текстом), но при этом не задумываться, какой реальный sql-запрос за ним стоИт и сколько времени он стОит. Максимальную скорость и эффективность можно получить, только описывая запросы на языке СУБД. И читаются они легче констуктора (ну если про MySQL говорить :))

В движке реализован класс `Db\Model`, в котором описана работа с базой данных и несколько методов общего применения. DB-модели приложения должны наследовать ее. При этом модель-наследник может не отражать в себе какую-то конкретную таблицу базы данных. Возможно это кому-то покажется слишком "низкоуровневым" кодингом запросов, но код в понимании проще, имхо.

Минус отсутствия ORM - сменишь БД-сервер, например MySQL на PostgresQL, придется переписывать весь слой моделей. Но! Сколько вы знаете случаев смены БД-сервера под рабочим сайтом? Вот и я о том же :)

## Конфигурация

Конфигураций БД может быть несколько, описываются в настройках приложения. По умолчанию ключ *"db"*, другие конфиги можно описать произвольными ключами и указывать их в конструкторе `db\Model`. Рекомендую придерживаться соглашения: ключи конфигов базы данных имеют префикс *"db_"*. 

Шаблон конфигурации БД:
```php
 'db' => [
    'dsn' => string,
    'user' => string,
    'password' => string,
    'options' => array | []
    'set_timezone' => bool | TRUE
 ] 
```

Обычно конфигурация c конфиденциальной информацией описывается в отдельном файле и не контролируется СКВ. По умолчанию мастер приложения (**TODO** ссылка на док или собственно мастер приложения) создает конфиг в `env.php`.

Почти все параметры соответствуют параметрам конструктора класса [PDO] (http://php.net/manual/en/pdo.construct.php).

Про *"options"* можно почитать в [PDO::setAttribute()] (http://php.net/manual/ru/pdo.setattribute.php). 

*Прим.: несмотря на то, что ключи в PDO Options представляют собой **числовые** константы, массив настроек, описанный в `env.php`, успешно сливается c главным конфигом. Обеспечено особым методом движка, и об этом заботиться не нужно.* 

#### Часовой пояс в MySQL-сессии

Если поднят флаг *'set_timezone'*, после установки соединения отправляется запрос на установку часового пояса сессии в соответствии с поясом, заданном для PHP-скриптов. Это гарантирует работу БД и PHP в одном времени. По теме часовых поясов в MySQL хорошо расписано на stackoverflow.com: [Should MySQL have its timezone set to UTC?] (http://stackoverflow.com/questions/19023978/should-mysql-have-its-timezone-set-to-utc/19075291#19075291)

Собственно часовой пояс для php-скриптов может быть задан в *php.ini (date.timezone)* или через вызов в скипте:
 
```PHP
date_default_timezone_set('Asia/Novosibirsk');
```

Я предлагаю размещать такой вызвов начале *index.php*. См. так же [часовые пояса] (http://php.net/manual/en/timezones.php) по версии PHP. Теоретически, эти названия должны совпадать с каким-то стандартом и возможно PHP и MySQL используют одни и теже имена поясов.

Как бы там ни было, в sql-запросе используется числовое представление пояса, т.к. не всегда на MySQL-сервер загружена таблица с названиями часовых поясов. Т.е. запрос выглядит так:

```MySQL
SET SESSON time_zone = "+06:00";    
```

*Прим.: числовое значение получается через `php::date('P')`, т.е. название пояса по версии PHP корректно преобразуется в числовое значение перед запросом.*

## Использование 

Работа с MySQL (а по умолчанию работаем именно с ней) идет через PDO. У движка есть обертки для подключения, подготовки и отправки запросов на сервер с последующим разбором ответа. Собственно, только под MySQL все и запилено :) 

Все запросы в конечном счете выполняются через `db\Model::query()`. В методе вызваются PDO-функции подготовки, выполнения и разбора ответа. Практика показывает, что на такую последовательность приходится 99% всех запросов в базу. Если вам нужно особенное поведение - получите соединение через `db\Model::getConnection()` и описывайте остальное в своей модели, используя нативные методы класса php::PDO.

---

Подробности использования класса `db\Model` см. в комментариях к его публичным методам.

---

#### Примеры работы с классом db\Model

**#1. Простой запрос**
```PHP
$data = (new UserModel)->query('SELECT * FROM Users ORDER BY id');
```

**#2. Запрос с подстановками и сложной параметризацией метода**
```PHP
// class app\models\UserModel 

$uid = net\Request::GET_int('uid');
$sql = 'SELECT login, mail, `status`, salt FROM Users WHERE id = ?';
$row = $this->query(['sql' => $sql, 'params' => [$uid], 'one_row' => true]);
```

*Прим.: поддерживаеются так же именованные подстановки. В таком случае в 'params' передаем ассоциативный массив. См. полезный метод `db\Model::valueSet()`*

**#3. Служебные манипуляции, без выделения модели-наследника**
```PHP
(new db\Model)->query(['sql' => 'TRUNCATE kira_log', 'guess' => false]);
```

**#4. Оформление транзакции через нативные функции PDO**
Добавляем нового юзера. Есть куча данных по нему, нужно писать в две таблицы, Users и UserProfiles. 
```PHP
$fieds = [... куча данных по юзеру ...];

$model = new UsersModel;
$con = $model->getConnection();
$con->beginTransaction();

if ($result = $model->addUser($fields)) {
    $fields['id'] = $result;
    $result = (new ProfileModel)->addProfile($fields);
}

if ($result) {
    $con->commit();
} else {
    $con->rollback();
}
```

## Обработка ошибок

Ошибки запросов и подключения к БД пишутся в лог (см. док *"Логер"*). Если определено логирование в базу, тогда ошибки запросов пишутся в нее, ошибки подключения - в любом случае в файлы. Если в атрибутах подключения запрещены исключения, тогда логирования не будет. Про настройку тут [PDO::ATTR_ERRMODE] (http://php.net/manual/ru/pdo.setattribute.php).
