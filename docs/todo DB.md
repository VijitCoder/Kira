# DB

Движок точно работает с MySQL-сервером. Настройки в конфиге именно для него. Не гарантирую полную поддержку других СУБД.

ORM нет никакой. Пока нет :)

Мне не нравятся конструкторы запросов. Я считаю неправильным такой подход: писать sql-запрос конструктором (иногда значительно больше, чем прямым текстом), но при этом не задумываться, какой реальный sql-запрос за ним стоИт и сколько времени он стОит. Максимальную скорость и эффективность можно получить, только описывая запросы на языке СУБД. И читаются они легче констуктора (ну если про MySQL говорить :))

В движке реализован класс `Db\Model`, в котором описана работа с базой данных и несколько методов общего применения. DB-модели приложения должны наследовать ее. При этом модель-наследник может не отражать в себе какую-то конкретную таблицу базы данных. Возможно это кому-то покажется слишком "низкоуровневым" кодингом запросов, но код в понимании проще, имхо.

Минус отсутствия ORM - сменишь БД-сервер, например MySQL на PostgresQL, придется переписывать весь слой моделей. Но! Сколько вы знаете случаев смены БД-сервера под рабочим сайтом? Вот и я о том же :)

## Конфигурация

Конфигураций БД может быть несколько, описываются в настройках приложения. По умолчанию ключ *"db"*, другие конфиги можно описать произвольными ключами и указывать их в конструкторе `db\Model`. Рекомендую придерживаться соглашения: ключи конфигов базы данных имеют префикс *"db_"*. 

Шаблон конфигурации БД:
```php
 'db' => [
    'dsn'            => string,
    'user'           => string,
    'password'       => string,
    'options'        => array | []
    'mysql_timezone' => string | '+00:00'
 ] 
```

Обычно конфигурация c конфиденциальной информацией описывается в отдельном файле и не контролируется СКВ. По умолчанию мастер приложения (**TODO** ссылка на док или собственно мастер приложения) создает конфиг в `env.php`.

Почти все параметры соответствуют параметрам конструктора класса [PDO] (http://php.net/manual/en/pdo.construct.php).

Про *"options"* можно почитать в [PDO::setAttribute()] (http://php.net/manual/ru/pdo.setattribute.php). 

*Прим.: несмотря на то, что ключи в PDO Options представляют собой **числовые** константы, массив настроек, описанный в `env.php`, успешно сливается c главным конфигом. Обеспечено особым методом движка, и об этом заботиться не нужно.* 

#### Часовой пояс в MySQL-сессии

Полезные ссылки
waredom.ru: [Время в MySQL] (http://waredom.ru/36#mysql)
stackoverflow.com: [How do I get the current time zone of MySQL?] (http://stackoverflow.com/a/2934271/5497749)
stackoverflow.com: [Should MySQL have its timezone set to UTC?] (http://stackoverflow.com/a/19075291/5497749)

Если у вас есть доступ к MySQL-серверу, лучше сразу задать на нем требуемый часовой пояс. Потому что через PHP это будет дополнительный запрос при каждом соединении с базой:

```MySQL
SET time_zone = $conf['mysql_timezone']
```

Если в настройке `mysql_timezone` пустая строка, запрос не будет отправлен. Если настройки нет вообще, по умолчанию ее значение '+00:00' (GMT).

*Прим: префикс "mysql_" означает, что в случае, когда часовой пояс задается названием, он должен быть из списка поясов известных MySQL, таблица `mysql`.`time_zone`. Для примера, в PHP названия поясов могут быть другими.*
                         
Коротко, в чем смысл: часовой пояс для MySQL важен только для функций типа `now()`, `unix_timestamp()` и т.п. При записи даты/времени в поле типа DATE, DATETIME часовой пояс не пишется. Запись в поле TIMESTAMP сохраняется внутри MySQL в UTC не зависимо от часового пояса. 
 
Что это дает: если вы хотите сохранить время с учетом часового пояса, то удобнее всего хранить его в нулевом поясе и при чтении переводить в нужный пояс. Т.е. вы всегда знаете, какое именно время у записи, независимо от перехода на летнее время, переезд базы на другой сервер или изменение настройки пояса на текущем сервере. Т.е. такой подход избавит вас от вероятных проблем в будущем. 

Конечно если вы несогласны, тогда укажите в настройке приложения желаемый часовой пояс. Формат значения должен быть понятен MySQL-серверу.

Примечания:

Часовой пояс для php-скриптов может быть задан в *php.ini (date.timezone)* или через вызов в скипте:
 
```PHP
date_default_timezone_set('Asia/Novosibirsk');
```

Числовое значение пояса (даже с учетом летнего времени) можно получить через `php::date('P')`.

## Использование 

Работа с MySQL (а по умолчанию работаем именно с ней) идет через PDO. У движка есть обертки для подключения, подготовки и отправки запросов на сервер с последующим разбором ответа. Собственно, только под MySQL все и запилено :) 

Все запросы в конечном счете выполняются через `db\Model::query()`. В методе вызваются PDO-функции подготовки, выполнения и разбора ответа. Практика показывает, что на такую последовательность приходится 99% всех запросов в базу. Если вам нужно особенное поведение - получите соединение через `db\Model::getConnection()` и описывайте остальное в своей модели, используя нативные методы класса php::PDO.

---

Подробности использования класса `db\Model` см. в комментариях к его публичным методам.

---

#### Примеры работы с классом db\Model

**#1. Простой запрос**
```PHP
$data = (new UserModel)->query('SELECT * FROM Users ORDER BY id');
```

**#2. Запрос с подстановками и сложной параметризацией метода**
```PHP
// class app\models\UserModel 

$uid = net\Request::GET_int('uid');
$sql = 'SELECT login, mail, `status`, salt FROM Users WHERE id = ?';
$row = $this->query(['sql' => $sql, 'params' => [$uid], 'one_row' => true]);
```

*Прим.: поддерживаеются так же именованные подстановки. В таком случае в 'params' передаем ассоциативный массив. См. полезный метод `db\Model::valueSet()`*

**#3. Служебные манипуляции, без выделения модели-наследника**
```PHP
(new db\Model)->query(['sql' => 'TRUNCATE kira_log', 'read' => false]);
```

**#4. Оформление транзакции через нативные функции PDO**
Добавляем нового юзера. Есть куча данных по нему, нужно писать в две таблицы, Users и UserProfiles. 
```PHP
$fieds = [... куча данных по юзеру ...];

$model = new UsersModel;
$con = $model->getConnection();
$con->beginTransaction();

if ($result = $model->addUser($fields)) {
    $fields['id'] = $result;
    $result = (new ProfileModel)->addProfile($fields);
}

if ($result) {
    $con->commit();
} else {
    $con->rollback();
}
```

## Обработка ошибок

Ошибки запросов и подключения к БД пишутся в лог (см. док *"Логер"*). Если определено логирование в базу, тогда ошибки запросов пишутся в нее, ошибки подключения - в любом случае в файлы. Если в атрибутах подключения запрещены исключения, тогда логирования не будет. Про настройку тут [PDO::ATTR_ERRMODE] (http://php.net/manual/ru/pdo.setattribute.php).
