# DB

Конфигураций БД может быть несколько, описываются в настройках. По умолчанию ключ *"db"*, другие конфиги можно описать произвольными ключами и указывать их в конструкторе `DBConnection`. Рекомендую придерживаться соглашения: ключи конфигов базы данных имеют префикс *"db_"*.

Шаблон конфигурации БД:
```php
     'db' => [
        'dsn' => string,
        'user' => string,
        'password' => string,
        'options' => array  //может отсутствовать
     ] 
```

Все параметры соответствуют параметрам конструктора класса [PDO] (http://php.net/manual/en/pdo.construct.php)

Про *"options"* можно почитать в [PDO::setAttribute()] (http://php.net/manual/ru/pdo.setattribute.php)

ORM нет никакой. Мне не нравятся конструкторы запросов и те "шланги", кто готов писать в разы больше кода конструктором, но не задумываться, какой sql-запрос за ним стоИт и сколько времени он стОит. В моем движке есть суперкласс DbModel, в котором реализована работа с базой данных и несколько методов общего применения. Все остальные запросы можно и нужно писать руками, в моделях-наследниках. При этом модель может не отражать в себе какую-то конкретную таблицу БД. Возможно это кому-то покажется слишком "низкоуровневым" кодингом запросов, зато так работает быстрее и в понимании проще.

Минус отсутствия ORM - сменишь БД-сервер, например MySQL на Oracle или MSSQL, придется переписывать весь слой моделей. НО! Сколько вы знаете случаев смены БД-сервера под рабочим сайтом? Вот и я о том же :)

Разумеется, работа с MySQL (а по умолчанию работаем именно с ней) идет через PDO. У движка есть обертки для подключения, подготовки и отправки ваших запросов на MySQL сервер с последующим разбором ответа. И все это сосредоточено всего в двух методах:

*DbModel::connect()*
    подключение к базе
    Возвращает PDO объект подключения к БД

*DbModel::query(array $ops)*
```PHP
    $ops = [
        'q' => null,              //текст запроса
        'p' => array(),           //параметры для вставки в запрос
        'fs' => PDO::FETCH_ASSOC, //разбор ответа (в случае SELECT-запроса)
        'one' => false,           //ожидаем один ряд или все (вложенность массива меньше)
    ];
```
Возвращает ряд/ряды при SELECT или количество затронутых рядов при других CrUD-запросах.

Все sql-запросы через query(). В методе вызваются PDO-функции подготовки, выполнения и разбора ответа. Практика показывает, что на такую последовательность приходится 99% всех запросов в базу. Если вам нужно особенное поведение - получите соединение через connect() и описывайте остальное в своей модели.

Ошибки запросов и подключений к БД пишутся в лог, см. док *"Логер"*. Если определено логирование в базу, тогда ошибки запросов пишутся в нее, ошибки подключений - в любом случае в файлы. Если в атрибутах подключения запрещены исключения, тогда логирования не будет. Про настройку тут [PDO::ATTR_ERRMODE] (http://php.net/manual/ru/pdo.setattribute.php).
