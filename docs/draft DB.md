# DB

ORM нет никакой. Мне не нравятся конструкторы запросов и те "шланги", кто готов писать в разы больше кода конструктором, но не задумываться, какой sql-запрос за ним стоИт и сколько времени он стОит. В моем движке есть суперкласс DbModel, в котором реализована работа с базой данных и несколько методов общего применения. Все остальные запросы можно и нужно писать руками, в моделях-наследниках. При этом модель может не отражать в себе какую-то конкретную таблицу БД. Возможно это кому-то покажется слишком "низкоуровневым" кодингом запросов, зато так работает быстрее и в понимании проще.

Минус отсутствия ORM - сменишь БД-сервер, например MySQL на Oracle или MSSQL, придется переписывать весь слой моделей. НО! Сколько вы знаете случаев смены БД-сервера под рабочим сайтом? Вот и я о том же :)

Разумеется, работа с MySQL (а по умолчанию работаем именно с ней) идет через PDO. У движка есть обертки для подключения, подготовки и отправки ваших запросов на MySQL сервер с последующим разбором ответа. И все это сосредоточено всего в двух методах:

*DbModel::connect()*
    подключение к базе
    Возвращает PDO объект подключения к БД

*DbModel::query(array $ops)*
```PHP
    $ops = [
        'q' => null,              //текст запроса
        'p' => array(),           //параметры для вставки в запрос
        'fs' => PDO::FETCH_ASSOC, //разбор ответа (в случае SELECT-запроса)
        'one' => false,           //ожидаем один ряд или все (вложенность массива меньше)
    ];
```
Возвращает ряд/ряды при SELECT или количество затронутых рядов при других CrUD-запросах.

Все sql-запросы через query(). В методе вызваются PDO-функции подготовки, выполнения и разбора ответа. Практика показывает, что на такую последовательность приходится 99% всех запросов в базу. Если вам нужно особенное поведение - получите соединение через connect() и описывайте остальное в своей модели.
