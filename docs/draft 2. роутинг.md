# Роутинг

### Прежде всего
Роутер можно заменить на свой. Нужно в конфиге прописать в параметр: 
```PHP
    'router' => <FQN имя класса роутера> 
```    
Для роутера есть интерфейс **IRouter**. Дальше - полная свобода.

### Роутер движка 

Теперь о роутере, встроенном в движок. Он работает в двух направлениях:
 
  - вычисление нужного контроллера/действия по URL и вызов действия; 
  - получение относительного URL по заданным контроллеру/действию и параметрам. 
  
Пример карты роутов (главный конфиг приложения):
```PHP
...
routes => [
    //модуль юзера
    APP_NS_PREFIX . 'modules\user\controllers\\' => [
        'registration' => 'RegistrationContoller',
        'login'   => 'LoginContoller',
        'logout'  => 'LoginContoller/out',
        'recover' => 'LoginContoller/recover',
        'profile' => 'ProfileContoller',
    ],

    //Основная зона контроллеров
    APP_NS_PREFIX . 'controllers\\' => [
        'news'          =>  'NewsContoller',
        'news/<id:\d+>' => 'NewsContoller/item'
        
        ...
        
        //Общие правила. Должны быть самыми последними вообще
        '<controller:[a-z]+>' => '<controller>',
        '<controller:[a-z]+>/<action:[a-z]+>' => '<controller>/<action>',
    ]
],

'errorHandler' => APP_NS_PREFIX . 'controllers\Error',
...
```  

Идея описания маршрутов взята в Yii 1.x, с дополнениями. Старшие ключи массива - это пространства имен, где расположены контроллеры, указанные в подмассивах. Каждый подмассив содержит описания роутов. Слева - правило, справа - controller/action. Может быть только контроллер, тогда будет взято действие по умолчанию. 

Исключаем путаницу в понятиях: обе части вместе (левую и правую) называем роутом. По тексту так и пишем: "роут", "слева ИЛИ правило...", "справа...". Кстати, в коде роутера аналогичные переменные, `$route`, `$left` и `$right`.

Обратите внимание на имена контроллеров. Роутер ничего не убирает и не приписывает к ним. Так сделано в связи с полной сводобой именования классов (см. док  *"Базовая конфигураци", Автозагрузка*). Если считаете допустимым, не используйте суффикс *"Controller"* в названиях ваших контроллеров. 
 
### Поиск контроллера/действия для URL

Левая часть роута - прочти готовое regexp-выражение. В угловых скобках указываются ***именованные подстановки*** в формате `<var:regexp>`. Их можно использовать для описания правой части роута и/или для передачи в параметры соответствующего метода. 

Ограничение на имя подстановки (var): \[A-Za-z0-9_\]+

В остальном синтаксис левой части роута в точности соответствует синтаксису PCRE регулярных выражений, кроме указания модификторов (разделители тоже писать не надо). После парсинга, правило принимает вид `'~^...pattern...$~Uiu'` и по нему проверяется полученный запрос. 

**Пример 1**
```PHP
'news/<id:\d{1-5}>' => 'NewsController/item',
```
Роут соответствует методу `NewsController::item()`, который *может принимать* один параметр $id. В любом случае указанный параметр дублируется в $_GET. Т.о. возможны две реализации метода:
```PHP
class NewsController extends \core\Controller 
{
    public function item()
    {
        $id = $_GET['id']; //валидировано роутом
        ...
    }
}
```
или
```PHP
class NewsController extends \core\Controller
{
    /**
     * Страница одной новости.
     * @param int $id валидировано роутом
     */
    public function item($id) 
    { 
        ... 
    }
}
```

**Пример 2**
```PHP
'user/<action:[a-z]+>' => 'UserController/<action>',
```
В данном случае роут подойдет для многих URL, типа: 
```
/user/login   -> UserController::login()
/user/profile -> UserController::profile()
/User/logOut  -> UserController::logOut()
```

**Важно!** Обращайте внимание на регистр букв в роутах. Если описывается статичная часть - регистр не важен. Но если это имя подстановки, тогда соблюдайте регистр букв. Это относится и к первому примеру в той же степени ($id в нижнем регистре). 

**Пример 3**
```PHP
'article/<id:\d{1,5}>[a-z_]+(/page/<page:\d+>)?' => 'StoryController'
```
Этот пример примечателен свободой URL-а, который подойдет для регулярки:
```
article/23_doll_house
article/6_ten_fear_stories/page/3
article/89_orphan/3 - а вот этот уже не подойдет, пропущен /page
```
Такому роуту должен соответствовать контроллер c заданным методом по умолчанию. Пример реализации:
```PHP
class StoryController extends \core\Controller
{
    protected $defaultAction = 'item';
    
    /**
     * Страница одной статьи. С пагинацией.
     * @param int $id валидировано роутом
     */
    public function item($id) 
    {
        $page = utils\VarRequest::get('page'); //если есть, то валидировано роутом
        ...
    }
}
```

#### Доп. информация

При получении запроса роутер следит за хвостовым слешем и редиректит на URL без него:
```
    http://site.com/some/page/ -> http://site.com/some/page
    http://site.com/give/it/?id=123 -> http://site.com/give/it?id=123
    
    http://site.com/ -> не меняется. Тут слеш - это адрес главной страницы.
```

Роутеру в конфиге нужна настройка `errorHandler` (см. док *"Базовая конфигурация"*). В ней указывается контроллер/действие (с пространством имен), который будет отвечать браузеру при 404 ошибке. Если настройки нет, тогда роутер ограничится только отправкой заголовка '404 Not found'. 

<small><p>Offtopic: пустая страница с 404 заголовком - сомнительная выгода. Я думаю, что web-сервер не возьмет на себя генерацию страницы, если PHP отправит 404. Полагаю, сервер отвечает своей 404 только если он сам ресурс не нашел. Короче, рекомендую завести свой метод для отрисовки 404-й и объявить его в <i>errorHandler</i>, хотя бы для роутера.</p></small>

Ведущие слеши в обеих частях роута писать **не надо**. Это ни на что не влияет, они обрезаются перед парсингом.

## Получение URL по заданным параметрам

Роутер способен собрать относительный URL по имеющейся карте роутов. При необходимости получения абсолютного URL-а домен дописывайте отдельно.
```
public static function url(array $route, array $params = []);
```
где `$route` - массив `['пространство имен', 'контроллер/действие']` и вторым параметром необязательный ассоциативный массив `$params` для подстановок в роут. 

Если в параметрах указано больше, чем есть подстановок в роуте, все лишнее пойдет как набор GET-параметров в URL. 

Если роут подходит по описанию контроллер/действие, но в для обеспечения его подстановок недостаточно данных в $params, значит это не тот роут.

Роуты для примеров:
```PHP
routes => [
    APP_NS_PREFIX . 'modules\user\controllers\\' => [
        'user/<action:\w+>/<userId:\d+>' => 'User/<action>',
        'user/<action:\w+>/<id:\d+>'     => 'User/<action>',
        'user/login'                     => 'User/login',
    ]
]
```

**Пример 1** (вызов где-то в клиентском коде)
```PHP
$ns = APP_NS_PREFIX . 'modules\user\controllers\\';
$profileUrl = core\Router::url([$ns, 'User/profile'], ['id' => 43, 'edit' => 'subscriptions']);
$loginUrl = core\Router::url([$ns, 'User/login'], ['return' => '/новости/43/addcomment']); //это конечно не хардкодом :)
```
В результате первое правило не сработает, потому что для него не обеспечена подстановка `userId`. Второй и третий роут вернут такие URL-ы:
```
/user/profile/43?edit=subscriptions
/user/login?return=%2F%D0%BD%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8%2F43%2Faddcomment
```
Тут подемонстрированы: выбор правильного роута, обеспечение требуемых подстановок, сборка GET-параметров и их кодирование.

 **Пример 2**, на совпадение имени подстановки и параметра:
```PHP
$profileUrl = core\Router::url([$ns, 'User/profile'], ['id' => 43, 'action' => 'show', 'friends' => null]);
```
Сработает второй роут, но у него тоже есть `action`, как и в передаваемых параметрах. Конфликт? Не-а :) Результат будет таким:
```
/user/profile/43?action=show&friends
```
В этом же примере показано, как задать GET-параметр *без значения*. 

**Замечание:** приведенные URL-ы не оптимальны, они только для демонстрации возможностей роутера.
