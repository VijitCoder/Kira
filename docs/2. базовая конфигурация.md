# Базовая конфигурация

## Константы

Если не указано иное, считать константу с типом *string*.

**ROOT_PATH** - физический путь от корня тома (диска) к корневому каталогу сайта. Завершающий слеш. Кроссплатформа, все слеши приводятся в прямым.

**APP_NS_PREFIX** - префикс пространства имен приложения. Используется в автозагрузчике. Все классы приложения, должны быть в его подпространстве. Это [требование стандарта PSR-4] (http://www.php-fig.org/psr/psr-4/ru/) к автозагрузчику классов.

**APP_PATH** - физический каталог со скриптами приложения (корень). Кроме прочего, используется автозагрузчиком классов.

*Константы APP_NS_PREFIX и APP_PATH в сочетании дают гибкое управление приложением. Например, нужно переключиться на другую версию, она в соседнем каталоге. Переписываем APP_PATH. А если запускаем принципиально иное приложение, можно пространство имен вести от другого корня и переписать APP_NS_PREFIX.*

**VIEWS_PATH** - физический путь к шаблонам приложения. Они могут быть где угодно, для этого и введена константа.

**MAIN_CONFIG** - путь к файлу основноЙ конфигурации приложения.

**DEBUG** ( *boolean* ) - флаг отладки.

## Автозагрузка классов и правила именования

Как было сказано выше, автозагрузчик написан почти по стандарту PSR-4. Коротко требования такие: каждый класс должен быть в объявленном пространстве имен. Пространство имен должно соответствовать иерархии каталогов. Все пространства имен приложения должны иметь один корень (префикс), обявленный в константе **APP_NS_PREFIX**. Префикс `'engine/'`  занят движком. 

В именовании учитывается соблюдение регистра. Нет требований к самим именам каталогов и классов. Это плюс :) Еще один плюс в теоретической возможности подключения сторонних библиотек, огранизованных в своих пространствах имен со своими загрузчиками. А минус в том, что манипуляции с пространствами имен занимают лишее время.

Автозагрузчик работает FQN именем класса, т.е. полное пространство имен + имя класса. Если префикс в FQN совпадает с **APP_NS_PREFIX**, тогда читает базовый каталог из константы **APP_PATH**, от имени класса отбрасывает префикс, остальное превращает в путь + имя скрипта и пытается его подключить (стандарт PSR-4). Если префикс не совпал, значит база = корень сайта, загрузчик ищет согласно полному описанию пространства имен (не стандарт).

В случае отсутствия файла автозагрузчик просто прекращает работу. Управление передается следующему загрузчику, зарегистрированному функцией *spl_autoload_register()*.

Отдельно подключается скрипт движка `engine/Interfaces.php`. Просто все интерфейсы собраны в один файл, поэтому автозагрузчик их не найдет.

Теоретически допустимо хранить несколько классов в одном скрипте, но автозагрузчик их не найдет. Т.е. работать последующие классы будут, только если имя первого отвечает требованиям выше и он уже загружен. Во избежание казусов рекомендуется хранить один класс = один файл.

Хотя нет жестких требований к именованию классов, рекомендую дописывать в конце их положение в слоях приложения: *UserModel, AuthService, StringHelper* и т.д. Это не повлияет на процесс загрузки, но удобно при чтении кода программистом. Исключение можно сделать для контроллеров, т.к. с их именами будет работать только роутер.

## Конфиг приложения

Путь к основному конфигурационному файлу приложения задается в константе **MAIN_CONFIG**. Сам файл конфигурации - php-скрипт, возвращающий ассоциативный массив. 

**В именах ключей нельзя использовать точку**. Почему - рассказано ниже, см. *"Чтение конфига"*. 

Пример конфига:
```PHP
return array_merge(
    [
        'indexHandler' => APP_NS_PREFIX . 'controllers\MainController->welcome',
        'errorHandler' => APP_NS_PREFIX . 'controllers\ErrorController',
        
        //'router'     => APP_NS_PREFIX . 'CustomRouter',
        'routes' => require __DIR__ . '/routes.php',
        
        'validators'   => [
            'password' => [
                'minLen' => 5, 
                'minComb' => 3,
            ],
        ],
        
        'db' => [
            'dsn'      => 'mysql:dbname=base0; host=127.0.0.1; charset=UTF8',
            'user'     => 'guest',
            'password' => '',
            'options' => [
                PDO::ATTR_TIMEOUT => 10,                         
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,     
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
            ],
        ],

    ],
    
    require __DIR__ . '/env.php' //сливаемся с конфигом среды окружения (конфиг конкретного сервера)
);
```

Движку требуется несколько обязательных настроек (aka параметров). Так же существует несколько рекомендуемых параметров.
***indexHandler***  - **обязательная настройка**. Контроллер приложения по умолчанию. Полностью определённое имя класса (FQN), от корневого пространства имен. Так же нужно указать метод, если он отличается от дефолтного. См. пример выше.

***routes*** - **обязательная настройка**, если используете роутер движка. Массив с роутами. Подробнее см. док *"Роутинг"*. 

***errorHandler*** - рекомендуемая настройка при использовании роутера движка. В ней указывается контроллер (с пространством имен) + метод, обрабатывающий ответы с HTTP кодами от 400 и выше. Подробнее см. док *"Роутинг > Конфиг errorHandler"*. 

Примеры настройки:
`'errorHandler' => APP_NS_PREFIX . 'controllers\MainController->error'` - основной контроллер, метод error()
`'errorHandler' => APP_NS_PREFIX . 'controllers\ErrorController'` - отдельный контроллер, метод по умолчанию.

***router*** - необязательный параметр. Если пишете свой роутер, укажите путь к нему (пространство имен + имя класса). 

**Замечание:** следует помнить, что требуемые хендлеры должны находится в каталоге приложения, иначе автозагрузчик их не найдет.

***db*** - условно-обязательная настройка. Ассоциативный массив. Требуется, только если приложение работает с базами данных через PDO, используя при этом функционал движка. Проще говоря, движок здесь ищет строку подключения и ключи к БД.

### Чтение конфига

Статичный метод 
```PHP
engine\App::conf(string $key, bool $strict = true)
```

Ключ конфига указываем в первом параметре. Через точку можно указать вложенные конфиги, например `App::conf('validators.password')`. Функция вернет значение по конечному ключу, в данном примере - массив из двух элементов *"min\*"*. В чем выгода указывать конечные ключи? Функция проверяет всю цепочку настроек на существование, не придется делать это в клиентском коде. 

Второй параметр, `$strict`, управляет реакцией на отстутствие настройки. Если он равен `true`, будет проброшено исключение. Если отсутствие настройки некритично для приложения, тогда вторым параметром передаем `false` и функция вернет `NULL`.

Очевидно, что использовать точку в именах ключей конфига нельзя, функция расценит ее, как разделитель и попытается найти вложенный массив по заданному имени. 
