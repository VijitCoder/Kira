# Базовая конфигурация

## Константы

Все константы, используемые движком, объявлены в `index.php` (при использовании мастера приложения). Если не указано иное, считать константу с типом *string*.

**ROOT_PATH** - физический путь от корня тома (диска) к корневому каталогу сайта. Завершающий слеш. Кроссплатформа, все слеши приводятся в прямым.

**APP_NAMESPACE** - корень пространства имен приложения. Используется в автозагрузчике. Все классы приложения должны быть в его подпространстве. Это [требование стандарта PSR-4] (http://www.php-fig.org/psr/psr-4/ru/) к автозагрузчику классов.

**APP_PATH** - физический каталог со скриптами приложения (корень). Кроме прочего, используется автозагрузчиком классов.

*Константы APP_NAMESPACE и APP_PATH в основном нужны движку и в сочетании дают гибкое управление приложением. Например, нужно переключиться на другую версию, она в соседнем каталоге. Переписываем APP_PATH. А если запускаем принципиально иное приложение, можно пространство имен вести от другого корня и переписать APP_NAMESPACE.*

**VIEWS_PATH** - физический путь к шаблонам приложения. Они могут быть где угодно, для этого и введена константа.

**MAIN_CONFIG** - путь к файлу основноЙ конфигурации приложения.

**DEBUG** ( *boolean* ) - флаг отладки.

## Автозагрузка классов и правила именования

Как было сказано выше, автозагрузчик написан почти по стандарту PSR-4. Требования: каждый класс должен быть в объявленном пространстве имен. Пространство имен должно соответствовать иерархии каталогов. Все пространства имен **приложения** должны иметь один корень, объявленный в константе **APP_NAMESPACE**. Имя `'engine/'`  занято движком.

Не стал вводить карту классов (namespace <-> реальный каталог), хотя стандартом разрешается. Я считаю, выгоды от нее меньше, чем проблем при чтении кода.

В именовании учитывается соблюдение регистра. Нет требований к самим именам каталогов и классов. Это плюс :) Еще один плюс в теоретической возможности подключения сторонних библиотек, организованных в своих пространствах имен со своими загрузчиками. А минус в том, что манипуляции с пространствами имен занимают лишее время.

Автозагрузчик работает с FQN именем класса, т.е. полное пространство имен + имя класса. Если корень в FQN совпадает с **APP_NAMESPACE**, тогда загрузчик читает базовый каталог из константы **APP_PATH**, от имени класса отбрасывает корень, остальное превращает в путь + имя скрипта и пытается его подключить (стандарт PSR-4).

Проще на примере:

```PHP
define('APP_NAMESPACE', 'app');
define('APP_PATH', ROOT_PATH . 'application/');
...

// грузим класс \app\controllers\Welcome
// файл будем искать ROOT_PATH + /application/controllers/Welcome.php
```

Если корень пространства имен не совпал, значит базовый каталог - корень сайта, загрузчик ищет согласно полному описанию пространства имен (не стандарт PSR-4).

В случае отсутствия скрипта с классом автозагрузчик просто прекращает работу. Управление передается следующему загрузчику, зарегистрированному функцией *spl_autoload_register()*.

Отдельно подключается скрипт с интерфейсами `engine/Interfaces.php`. Просто все интерфейсы собраны в один файл, поэтому автозагрузчик их не найдет.

Теоретически допустимо хранить несколько классов в одном скрипте, но автозагрузчик их не найдет. Т.е. работать последующие классы будут, только если имя первого в скрипте класса отвечает требованиям выше и он уже загружен. Во избежание казусов рекомендуется хранить один класс = один файл.

Хотя нет жестких требований к именованию классов, рекомендую дописывать в конце их положение в слоях приложения: *UserModel, AuthService, StringHelper* и т.д. Это не повлияет на процесс загрузки, но удобно при чтении кода программистом. Исключение можно сделать для контроллеров, т.к. с их именами в коде будет работать только роутер.

## Конфигурация приложения

Путь к основному конфигурационному файлу приложения задается в константе **MAIN_CONFIG**. Сам файл конфигурации - php-скрипт, возвращающий ассоциативный массив.

**В именах ключей нельзя использовать точку**. Почему - рассказано ниже, см. *"Чтение конфига"*.

Пример конфига:
```PHP
$main = [
    'indexHandler' => 'app\controllers\MainController->welcome',

    'router' => [
        '404_handler'   => 'app\controllers\ErrorController',
        'routes'        => require 'routes.php',
    ],

    'db' => [
        // прим.: строка подключения, юзер и пароль задаются в env.php
        'options' => [
            PDO::ATTR_TIMEOUT => 10,
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
        ],
    ],

    'domain' => 'site.com',

    'admin_mail'   => 'admin@site.com',
    'noreply_mail' => 'noreply@site.com',

    'timezone' => 'Asia/Novosibirsk',
];

$env = require 'env.php'; // конфиг среды окружения (== конфиг конкретного сервера)

return engine\utils\Arrays::merge_recursive($main, $env, true);

```

Движку требуется несколько обязательных настроек (параметров). Так же существует несколько рекомендуемых параметров.

***indexHandler***  - **обязательная настройка**. Контроллер приложения по умолчанию. Полностью определённое имя класса (FQN), от корневого пространства имен. Так же нужно указать метод, если он отличается от дефолтного. См. пример выше.

***router*** - **обязательная настройка**. Подробнее см. док *"Роутинг > Конфигурация"*.

***db*** - условно-обязательная настройка. Требуется, только если приложение работает с базами данных через PDO, используя при этом функционал движка. Проще говоря, движок здесь ищет строку подключения и ключи к БД. Подробнее в доке "*DB*"

***log*** - необязательная настройка логера. Без нее логер будет работать с настройками по умолчанию, см. док *"Логер"*

***domain*** - необязательно. Если `Env::domain()` не найдет имя домена в $_SERVER['HTTP_HOST'], попытается прочитать его в этой настройке. На имя домена завязаны некоторые другие функции класса `\engine\Env`, см. док *"Среда окружения сайта"*.

***admin_mail*** - ящик админа, условно-обязательная настройка. Как минимум, логер шлет сообщения на мыло админу.

***noreply_mail*** - необязательная настройка. Адрес отправителя для автоматических писателей, типа логера.

***timezone*** - необязательная настройка. Часовой пояс сайта для PHP функций даты/времени. Значение должно быть строкой, понятной PHP, полный список поясов [здесь] (http://php.net/manual/en/timezones.php). Если не задана, считается UTC.

*Прим: До PHP 7.0 нужно было явно задавать часовой пояс, если используются функции даты/времени. Это можно было сделать через вызов [date_default_timezone_set()](http://php.net/manual/en/function.date-default-timezone-set.php) или задать пояс в php.ini. В 7й версии требование стало необязательным, по умолчанию считается UTC.*


##### Часовые пояса и конфигурация приложения

В полном конфиге приложения вы встретите три(!) настройки часовых поясов:

- *timezone* - основной пояс сайта, как сказано выше.
- *log.php_timezone* - пояс для записей лога. Он может отличаться от времени сайта, подробнее в доке *"Логер"*.
- *db.mysql_timezone* - пояс MySQL-сессии. Подробнее в доке *"DB"*

### Чтение конфигурации

Статичный метод
```PHP
\engine\App::conf(string $key, bool $strict = true)
```

Ключ конфига указываем в первом параметре. Через точку можно указать вложенные конфиги, например `App::conf('db.options')`. Функция вернет значение по конечному ключу, в данном примере - массив PDO-параметров. В чем выгода указывать конечные ключи? Функция проверяет всю цепочку настроек на существование, не придется делать это в клиентском коде.

Очевидно, что использовать точку в именах ключей конфига нельзя, функция расценит ее, как разделитель и попытается найти вложенный массив по заданному имени.

Второй параметр, `$strict`, управляет реакцией на отстутствие настройки. Если он равен `true`, будет проброшено исключение. Если отсутствие настройки некритично для приложения, тогда вторым параметром передаем `false` и функция вернет `NULL`.
