# Перехват HTTP-ошибок

*Под http-ошибками я подразумеваю ситуацию, когда сервер отвечает заголовком с кодом: 401, 403, 404, 500.*

Нужно понимать, что обработка http-ошибок - это не часть движка, поскольку в зависимости от настроек веб-сервера, такие ошибки могут вообще не проходить обработку php-скриптами. Данная статья - это пример реализации обработчика **в конкретном приложении**.

Используя роутер движка в сочетании с заданным `errorHandler` можно организовать централизованную выдачу страниц с ошибками в стиле сайта. Картина немного запутанная. 
 
- когда роутер движка не сможет найти соответствие для запрошенного URL, установит код http-статуса "404" и вызовет `errorHandler`. 

- у веб-сервера могут быть указаны скрипты, которые будут собирать страницу при ошибках. В частности Apache позволяет выдавать свои страницы для 401, 403, 404 и 500 кода (см. директиву *ErrorDocument*). Такие ошибки от веб-сервера так же попадут в `errorHandler`.

- не уверен, но возможно веб-сервер позволит ловить еще и *"400 Bad request"*.
  
## По шагам

1) Используем роутер движка. Можно и свой конечно, но тогда нужно позаботиться о том, чтобы вызывался `errorHandler`, когда роут не найден или в запросе получен код ошибки >= 400.

2) Конфигурация приложения:

```PHP
    // FQN контроллера + метод, отвечающий при 404 от роутера. Туда же можно направить web-сервер с его
    // ошибками 401-404, 500
    'errorHandler' => 'app\controllers\ErrorController',
```
 
3) Создаем требуемый контроллер:

```PHP
namespace app\controllers;

use engine\App,
    engine\Env,
    engine\net\Request,
    engine\net\Response;

/**
 * Контроллер ошибок http-протокола (401-404, 500)
 */
class ErrorController extends \engine\web\Controller
{
    /**
     * Возвращаем юзеру страницу с описанием ошибки.
     *
     * Отсюда заголовки не шлем! Этим занимается либо web-сервер, у которого текущий метод прописан
     * обработчиком 40x ошибок, либо клиентский код. Т.о. тут только рисуем страницу и выполняем 
     * фоновую работу (логирование, уведомление на мыло).
     */
    public function index()
    {
        $code = http_response_code();
        $log = App::log();
        $data = [
            'domain' => Env::domainName(),
            'index'  => Env::indexPage(),
        ];
        switch ($code) {
            case 401:
                $this->title = '401 Для доступа к запрашиваемому ресурсу требуется аутентификация';
                break;
            case 403:
                $this->title = '403 В доступе отказано';
                $log->addTyped('403 В доступе отказано', $log::HTTP_ERROR);
                break;
            case 404:
                $this->title = '404 Страница не найдена';
                $data['request'] = Request::absoluteURL();
                $log->addTyped('404 Страница не найдена', $log::HTTP_ERROR);
                break;
            case 500:
                $this->title = '500 Внутренняя ошибка сервера';
                $log->add([
                    'message' => '500 Внутренняя ошибка сервера', 
                    'type' => $log::HTTP_ERROR, 
                    'notify' => true]);
                break;
            default:
                $msg = "Ошибка. $code " . Response::textOf($code);
                echo $msg;
                $log->addTyped($msg, $log::HTTP_ERROR);
                return;
        }

        $this->render('errors/' . $code, $data);
    }
}
```

4) В каталоге шаблонов заводим подкаталог [views/errors/], складываем в нем свои страницы на каждую перехватываемую ошибку.

5) Настраиваем Apache

```Apache
# Тут пишем любой адрес, см. пояснение ниже.
ErrorDocument 401 /ErrorController
ErrorDocument 403 /ErrorController
ErrorDocument 404 /ErrorController
ErrorDocument 500 /ErrorController

RewriteEngine On
RewriteBase /
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php [L,QSA]
```

Адрес в `ErrorDocument` будет проигнорирован: согласно описанному правилу `mod_rewrite`, запрос пойдет через индекс в роутер, а тот в свою очередь увидев **код ошибки** (адрес при этом игнорируется), передаст управление в `ErrorHandler`, заданный в конфиге. Т.е. любой запрос с заданными кодами пойдет через *index.php > Router > errorHandler*.

В правиле можно сделать так, чтобы запросы к `ErrorController` не передавались в `index.php`. Но тогда целевой контроллер должен быть независим от движка, полностью автономный скрипт. Это неудобно.

---

Итак, *"мухи отдельно, котлеты отдельно"*: 404 - забота движка, т.к. именно его роутер знает, найдена страница или нет. Другие ошибки - забота веб-сервера, но он может делегировать их оформление PHP-скрипту. В нашем случае, они придут через роутер в  контроллер, заданный в конфиге приложения.

Запутано. Пока лучше не придумал.
