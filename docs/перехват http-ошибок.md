# Перехват HTTP-ошибок

*Под http-ошибками я подразумеваю ситуацию, когда сервер отвечает заголовком с кодом: 401, 403, 404, 500.*

Если роутер движка не найдет маршрут, он вернет 404-й заголовок. При этом, если в конфигурации приложения задан контроллер для обработки такой ошибки, роутер вызовет его. Пример конфига: 

```PHP
'router' => [
    // FQN контроллера + метод, отвечающий при 404 от роутера. 
    '404_handler' => 'app\controllers\ErrorController',
    ...
]
```

Все просто.

Теперь что касательно веб-сервера. Рассматриваю только *Apache* и его директиву `ErrorDocument`. Пример настройки .htaccess:

```Apache
ErrorDocument 401 /ErrorController
ErrorDocument 403 /ErrorController
#  ErrorDocument 404 /ErrorController бесмысленно при заданом ниже правиле
ErrorDocument 500 /ErrorController

RewriteEngine On
RewriteBase /
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php [L,QSA]

```

Допустим, возникла ошибка *"401 Unauthorized"*. Сервер передаст 401-й заголовок и обратится по URL-у */ErrorController*. Этот адрес будет указан в заголовке REDIRECT_URL, отраженном в `$_SERVER['REDIRECT_URL']`. Роутер это увидит и попытается найти требуемый маршрут к ErrorController. 

Опять же, все просто.

А теперь исключительная ситуация: указанный маршрут не найдет роутером. По-хорошему, роутер вернет 404-ю. Но это бы сбивало столку, т.к. на деле имеем 401-ю и коряво заданный *ErrorDocument* (или неописанный под него маршрут). Поэтому в роутере заложен предохранитель для программиста: при таком раскладе роутер выдаст реальный код ошибки и сообщение, но без отрисовки, потому что он не нашел, какому контроллеру передать запрос.

**Замечание**: согласно [интернетов](http://stackoverflow.com/a/6483945/5497749), `$_SERVER['REDIRECT_URL']` таки отличается от `$_SERVER['REQUEST_URI']`. В первом случае не добавляется строка запроса (то, что после знака "?" в адресе). Она идет в отдельном ключе, `REDIRECT_QUERY_STRING`. Роутер это игнорирует и работает только с `REDIRECT_URL`.

---

Итак, *"мухи отдельно, котлеты отдельно"*: 404 - забота движка, т.к. именно роутер знает, найдена страница или нет. Другие ошибки - забота веб-сервера, но он может делегировать **их оформление** PHP-скрипту. В нашем случае, через адрес указанный в конфиге .htaccess::ErrorDocument запрос придет в контроллер, назначенный этому адресу в роутах приложения.

---

На последок, пример реализации контроллера, который может обрабатывать все эти ошибки в одном месте:
```PHP
namespace app\controllers;

use engine\App,
    engine\Env,
    engine\net\Request,
    engine\net\Response;

/**
 * Контроллер ошибок http-протокола (401-404, 500)
 */
class ErrorController extends \engine\web\Controller
{
    /**
     * Возвращаем юзеру страницу с описанием ошибки.
     *
     * Отсюда заголовки не шлем! Этим занимается либо web-сервер, у которого текущий метод прописан
     * обработчиком 40x ошибок, либо клиентский код. Т.о. тут только рисуем страницу и выполняем 
     * фоновую работу (логирование, уведомление на мыло).
     */
    public function index()
    {
        $code = http_response_code();
        $log = App::log();
        $data = [
            'domain' => Env::domainName(),
            'index'  => Env::indexPage(),
        ];
        switch ($code) {
            case 401:
                $this->title = '401 Для доступа к запрашиваемому ресурсу требуется аутентификация';
                break;
            case 403:
                $this->title = '403 В доступе отказано';
                $log->addTyped('403 В доступе отказано', $log::HTTP_ERROR);
                break;
            case 404:
                $this->title = '404 Страница не найдена';
                $data['request'] = Request::absoluteURL();
                $log->addTyped('404 Страница не найдена', $log::HTTP_ERROR);
                break;
            case 500:
                $this->title = '500 Внутренняя ошибка сервера';
                $log->add([
                    'message' => '500 Внутренняя ошибка сервера', 
                    'type' => $log::HTTP_ERROR, 
                    'notify' => true]);
                break;
            default:
                $msg = "Ошибка. $code " . Response::textOf($code);
                echo $msg;
                $log->addTyped($msg, $log::HTTP_ERROR);
                return;
        }

        $this->render('errors/' . $code, $data);
    }
}
```

В каталоге шаблонов заводим подкаталог [views/errors/], складываем в нем свои страницы на каждую перехватываемую ошибку: `404.htm`, `403.htm` и т.д.
