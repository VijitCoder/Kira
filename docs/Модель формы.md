# Модель формы. Валидация форм

Суперкласс `engine\web\From`

Возможности модели форм в этом движке:

- любая вложенность исходных данных
- валидация массива однородных данных одним правилом
- любое количество валидаторов на конкретное значение. Есть ограничение на количество валидаторов по типу, см. ниже.
- свои сообщения об ошибках от любого валидатора

Пример использования модели формы:
 
```PHP
    $form = new SomeForm;
    if ($form->load($_POST)->validate()) {
    ...
    } else {
        $errors = $form->getErrors();
    }
```

## Структура контракта

Основное понятие - **контракт на поля формы**. Это массив с именами полей и списком валидаторов для их проверки.

Формы могут быть любой сложности и вложенности данных. Контракт должен повторять иерархию вложенности данных. Рассмотрим на примере сложной html-формы с большой вложенностью данных:

```html
<form method="POST" action="create">
    <input type="text" value="test" name="inp0">

    <input type="text" value="test1" name="inp1[]">
    <input type="text" value="test2" name="inp1[]">
    <input type="text" value="test3" name="inp1[]">

    <input type="text" value="test4" name="inp2[one]">
    <input type="text" value="test5" name="inp2[two]">

    <input type="text" value="test6" name="inp3[lvl1][lvl11]">
    <input type="text" value="test7" name="inp3[lvl1][lvl12]">
    <input type="text" value="test8" name="inp3[lvl1][lvl12][lvl121]">
    <input type="submit">
</form>
```

Дамп переменной $_POST:

```PHP
array
(
    'inp0' => 'test'
    'inp1' => array
    (
        0 => 'test1'
        1 => 'test2'
        2 => 'test3'
    )
    'inp2' => array
    (
        'one' => 'test4'
        'two' => 'test5'
    )
    'inp3' => array
    (
        'lvl1' => array
        (
            'lvl11' => 'test6'
            'lvl12' => array   // обратите внимание: "test7" отсутствует
            (
                'lvl121' => 'test8'
            )
        )
    )
)
```

Пример контракта на поля формы:

```PHP
class SomeForm extends engine\utils\Form {
    protected $contract = [
        'inp0' => [
            'validators' => [          // здесь три валидатора разных типов
                'required' => true,
                
                'filter_var' => [
                    'filter'  => FILTER_VALIDATE_REGEXP,
                    'options' => ['regexp' => '~^[a-z0-9-_]+$~i'],
                    'message' => 'Недопустимые символы в логине',
                ],
                
                'length' => ['min' => 5, 'max' => 30,],
            ],
        ], 
        
        'inp1' => [
            'expectArray' => true,     // обязательный флаг для обработки массивов данных
            ['validators' => [
                    'filter_var' => [
                    'filter'     => FILTER_CALLBACK,
                    'options'    => ['\engine\utils\Validators', 'normalizeString'],
                ],
            ],
        ]
        
        'inp2' => [
            'expectArray' => true,
            ['validators' => [...],],
        ]
        
        'inp3' => [
            'lvl1' => [
                'lvl11' => [
                    'validators' => ['required' => true,],
                ],
                'lvl12' => [
                    'lvl121' => null,  // принять без валидации
                ],
            ],
        ],
    ];
}
```

Валидаторы могут быть назначены только на конечный узел иерархии, т.е. на данные конкретного поля формы. Валидаторы описываются в отдельном ассоциативном массиве с ключом `validators`. В свою очередь ключи такого массива - конкретные типы валидаторов, значения массива - параметры валидаторов.

Если валидация поля не нужна, пишем `null` в качестве значения.

## Типы валидаторов

**Важно:** валидаторы могут быть разных типов. На одно проверяемое значение нельзя повешать два валидатора одного типа. Это очевидно, т.к. тип задается в ключе массива валидаторов и повторное его использование перепишет предыдущее значение в массиве.

### filter_var

Описывается по правилам [php::filter_var()](http://php.net/manual/ru/function.filter-var.php), для валидации будет вызвана именно эта функция. Обязательный элемент - `filter`, мое дополнение - `message`. Пример:

```PHP
...
'login' => [
    'validators' => [
        'filter_var' => [
            'filter'  => FILTER_VALIDATE_REGEXP,
            'options' => ['regexp' => '~^[a-z0-9-_]+$~i'],
            'message' => 'Недопустимые символы в логине',
        ],
    ],
],
...
```

Некоторые фильтры позволяют задать значение по умолчанию через `options['defalut']`. Если оно есть, то в случае неудачи функция возвращает это значение, а не `FALSE`. Основной метод валидации воспримет такую ситуацию, как успешную и запишет полученное значение в проверенные данные. Я думаю, это логично: кодер указал, что принимать по умолчанию. Следовательно он не хочет ошибку валидации.

### external

Описывается по правилам [php::call_user_func()] (http://php.net/manual/ru/function.call-user-func.php). Обязательный элемент - `function`. В `options` можно задать доп.параметры в функцию. Они будут переданы массивом. Пример:

```PHP
...
'password' => [
    'validators' => [
        'external' => [
            'function'   => ['\engine\utils\Validators', 'password'],
            'options'  => [
                'min_len'  => 5,
                'min_comb' => 3,
            ],
        ],
    ],
],
...
```

Некоторые внешние валидаторы можно найти в `\engine\utils\Validators`. Смотрите комментарии к методам.

Можно создавать свои валидаторы для такого типа подключения. Сигнатура функции:

```PHP
/**
 * @param mixed $value   проверяемое значение
 * @param array $options доп.параметры валидатора, если они есть.
 * @return array ['errors' => mixed] | ['value' => mixed]
 */
function someFunc(mixed $value, [array $options]): array
```

Функция должна вернуть ассоциативный массив либо с текстом(ми) ошибки либо с валидированным значением.

### required

Тут достаточно просто `true`. Если требуется свое сообщение, тогда и пишем ['message' => 'Требуется заполнить ...']. Пример:

```PHP
...
'login' => [
    'validators' => [
        'required' => true,
    ],
],

'mail' => [
    'validators' => [
        'required' => ['message' => 'Укажите email, пожалуйста'],
    ],
],
...
```

Если сообщение не задано явно, будет типовое.

### length

Для проверки длины строки. Два элемента в массиве - [min, max]. Любой из них можно опустить. Можно задать свое сообщение. Если его нет, будет типовое.

### bounds

Для проверки мин/макс значений чисел, включая отрицательные и с плавающей точкой. Так же, как в `length`, две опции [min, max]. Можно задать свое сообщение. Если его нет, будет типовое.

---

Самым первым к данным поля формы применяется `required`, (если он задан), причем независимо от его положения в списке валидаторов. Это позволит остальным валидаторам не ругаться на неправильные значения, когда их просто нет. Остальные валидаторы выполняются в порядке очереди. Т.о. следует использовать, например, проверку длины **после** дезинфицирующих фильтров, поскольку длина строки может измениться.

К типовым валидаторам нельзя ничего добавить. Но создать и использовать свои функции валидации конечно можно. Для этого служат тип `filter_var` со значением `'filter'  => FILTER_CALLBACK` и тип `external`.

## Сообщения

Любой валидатор может сопровождаться своим сообщением. Так же внешние валидаторы, подключаемые через `external`, могут возвращать свои сообщения. Если сообщение указано в контракте, при валидации прогоняем его через переводчик (см. док *"Локализация сайта"*). Сообщения из внешних валидаторов принимаем без перевода.

Сообщение, заданное в контракте для конкретного валидатора, выше приоритетом и заменит сообщение(я) это валидатора.

Встроенные валидаторы `required`, `length` и `bounds` будут возвращать свои типовые сообщения, если в контракте не задано иное. Например: *"Не заполнено необходимое поле"*, так же через переводчик.

## Валидация массива данных

Контракт на конкретное поле представляет собой массив. Данные из поля так же могут быть массивом. Диллема такая: без явного указания нельзя знать наверняка, ожидается массив данных или единичное значение. 

Можно конечно добавить анализатор, но получится такая засада: любой массив будет принят, как ожидаемый. И допустим, корректно провалидировано каждое его значение. Возвращаем его в клиентский код и.. ошибка! Код ожидал тут единственное значение, а мы ему массив отдали. В нормальной ситуации так не будет конечно, код получит что ожидает, но в качестве попытки уронить сайт вполне можно подпихнуть массив вместо одного значения.

Выход: вводим отдельный парамер (`bool)expectArray`. Если флаг задан, любое значение рассматривается как массив. Если не задан (пропущен), то массив значений может привести к ошибке валидаторов. Поэтому отмечаем такое значение не валидным без каких-либо проверок, пишем в соообщении об ошибках, в чем суть проблемы.

**Параметр `expectArray` нужен, только для конечных узлов с заданными валидаторами.** Т.е. не нужно поднимать этот флаг в ветке, просто содержащей подмассивы контракта.

Очевидно, что при валидации массива не имеет смысла задавать конкретные сообщения об ошибках, т.к. для каждого невалидного значения будет использовано указанное сообщение.

## Структура модели формы

После вызова конструктора модели ее уже можно использовать на веб-формах. Это удобно, когда есть предполагается повторное заполнение формы данными при ошибках валидации. Логика такая: пишем шаблон со вставками данных из модели формы. Контроллер создает экземпляр модели и передает его в шаблон. Все. Не нужно в шаблоне проверять наличие поля через `isset()`. Все поля есть согласно описания контракта. Все данные в них равны `null`.
 
Чтобы проверить полученные данные, их нужно загрузить в модель. Для этого служит метод 
```PHP
function load(array &$data):From
```
Метод возвращает объект текущей модели, что позволяет выполнить вызвов следующего метода по цепочке.

Собственно проверка вызывается методом 
```PHP
function validate():bool
```

---

Модель формы хранит три массива, соответствующие иерархии исходных данных: 

- Сырые данные. Это все, что было передано в модель. Как есть, без валидации, независимо от полей контракта.
- Проверенные данные. В этот массив попадет только то, что **заявлено в контракте** и прошло валидацию.
- Ошибки. В массив ошибок можно добавлять свои из клиентского кода.

Для получения данных из этих массивов используются соответственно
 
```PHP
function getRawdata([string $key]):mixed
function getValues([string $key]):mixed
function getErrors([string $key]):array
```
 
Параметр `$key` необязателен. Если не задан - возвращается весь массив. Если задан, возвращается **подмассив первого уровня иерархии данных**. Получить данные с подуровней несложно, но как описать ключ в таком случае? Поэтому только первый уровень.

#### Дополнительные функции модели
  
```PHP
function addError(array $message):void
```

Добавление своего сообщения в массив ошибок. Ключ в массиве - имя поля, значение - собственно сообщение. В случае многомерного массива описывается полный путь вложений к требуемому полю и потом сообщение.

---

```PHP
function hasErrors():bool
```

Проверка, есть ли какие-то ошибки. Не обязательно ошибки валидации. Такое возможно, учитывая использование метода `addError()`.

---

```PHP
function isValid():bool
```

Получение информации о результате валидации. Очевидно, что вызывать такой метод имеет смысл только после вызова `validate()`.

---

```PHP
function setValue(array $value):void
```

Свое значение в массив **валидированных** данных. Если значение нужно разместить в многоуровневом массиве, пишем всю вложенность ключей и новое значение на нужном уровне. Старое значение будет переписано, если оно есть. Наличие поля не проверяется, что дает больше возможностей для управления массивом итоговых данных.
