# Перехват ошибок

Класс `engine\Handlers`. В нем описан перехватчик для исключений, не пойманных ранее, а так же обработчики PHP-ошибок. Вот о них нужны подробности.

На самом деле реальной необходимости в своих обработчиках нет, PHP сам неплохо информирует об ошибках. Но я сделал свое оформление + логирование. Мне так больше нравится, чем оранжево-черная таблица PHP. 

Обработчик ошибок назначен в *autoloader.php* через функцию [set_error_handler()] (http://php.net/manual/ru/function.set-error-handler.php) Проблема в том, что он не ловит ошибки типа E_ERROR | E_PARSE | E_COMPILE_ERROR. Выход из ситуации - ловить их в самом завершении программы. Для этого в *autoloader.php* назначена еще одна своя функция через [register_shutdown_function] (http://php.net/manual/ru/function.register-shutdown-function.php). 

Логика следующая: фатальная ошибка, PHP нарисовал сообщение, отправил в браузер и завершает работу. Тут запускается моя *shutdown*-функция. В ней кроме прочего проверяем, была ли ошибка и какой нее код. Если совпадает с ожидаемым кодом, вызываем мой обоработчик ошибок. Но проблема тут в том, что PHP **уже ответил браузеру сообщением** и мое красиво оформленное сообщение полетит следом. Фигня получается.

Поэтому используем буферизацию вывода. Она включается прямо перед назначением *shutdown*-функции, а отправка буфера происходит в самой функции. Теперь при фатальных ошибках внутри *shutdown*-функции **сбрасывается буфер с сообщением PHP**, вызывается мой обработчик, который сообщает тоже самое, но в моем оформлении. В теории все должно работать.

Минусы:
- *shutdown*-функция работает всегда, даже если ошибок нет;
- сброс буфера при фатальной ошибке стирает все то, что было нарисано до нее.
 
Отключить все это дело легко: закоментировать в *autoloader.php* назначеннные обработчики и буферизацию. 

У меня пока несколько вариантов по отлову фатальных ошибок:

1. вообще забить на такие ошибки. PHP ругнется, и мы узнаем об этом, если **есть вывод в браузер или stdout**. Если вывода нет, получим черный ящик. Вот для таких случаев полезно собственное логирование, которое можно организовать в shutdown-функции. Ситуация без выдачи ответа возможна при работе скрипта в *cron* или когда имеем REST-сервис без обратной связи. Да, я видел и такое :)

2. не колдовать с буферизацией и позволить PHP выдавать стандартные сообщения. При этом самостоятельно писать дополнительный лог в *shutdown*-функции. Не очень красиво учитывая, что другие ошибки все же идут через движок.

3. или описанный выше вариант. Пока тестирую именно его.

Кстати, лог пишется в `TEMP_PATH/kira_php_error.log`, константа задана в *index.php*. Сам каталог должен существовать и разрешать права на запись для web-сервера. Подробнее см. в доке *"Организация файлов"*. 
