# Перехват ошибок

Класс `engine\Handlers`. В нем описан перехватчик для исключений, не пойманных ранее, а так же обработчики PHP-ошибок. 

## Исключения

В движке назначен перехватчик для любых исключений, не пойманных ранее. Так же отдельно перехватываются и обрабатываются *PDOException*. Поведение перехватчиков зависит от окружения. 

**Если исключение не ловит код приложения, то:** в режиме отладки (`DEBUG = true`) все ошибки выдаются в *output* как есть, логи не пишутся; c отключенной отладкой юзеру будет выдана html-заглушка с сообщением типа *"Ошибка, зайдите позже"*. Это делает конечный перехватчик. Он же попытается логировать ошибку, если это не было сделано ранее. Необходимость логирования определяется по факту, указано ли предыдущее исключение. 

Поясню на примере, реализованном в движке. Когда на *production* возникает сбой подключения к базе, в классе *DBConnection* ловим *PDOException*. Пишем ошибку в лог и пробрасываем дальше **обычное Exception с указанием предыдущего исключения**. Если код приложения его не поймает, конечный перехватчик выдаст заглушку юзеру. Видя, что это не единственное исключение в цепочке, он не будет писать ошибку в лог.

Проще говоря: на проде все полезное делаем непосредственно там, где возникло исключение, на деве - передаем ситуацию разработчику как есть.

## Ошибки PHP

На самом деле реальной необходимости в своих обработчиках нет, PHP сам неплохо информирует об ошибках. Но я сделал свое оформление и свое логирование в файл. Мне так больше нравится, чем оранжево-черная таблица PHP. 

Обработчик ошибок назначен в *autoloader.php* через функцию [set_error_handler()] (http://php.net/manual/ru/function.set-error-handler.php) Проблема в том, что он не ловит ошибки типа E_ERROR | E_PARSE | E_COMPILE_ERROR. Выход из ситуации - ловить их в самом завершении программы. Для этого в *autoloader.php* назначена еще одна своя функция через [register_shutdown_function()] (http://php.net/manual/ru/function.register-shutdown-function.php). 

Логика следующая: фатальная ошибка, PHP нарисовал сообщение, отправил в браузер и завершает работу. Тут запускается моя *shutdown*-функция. В ней кроме прочего проверяем, была ли ошибка и какой нее код. Если совпадает с ожидаемым кодом, вызываем мой обоработчик ошибок. Но проблема тут в том, что PHP **уже ответил браузеру сообщением** и мое красиво оформленное сообщение полетит следом. Фигня получается.

Поэтому используем буферизацию вывода. Она включается прямо перед назначением *shutdown*-функции, а отправка буфера происходит в самой функции. Теперь при фатальных ошибках внутри *shutdown*-функции **сбрасывается буфер с сообщением PHP**, вызывается мой обработчик, который сообщает тоже самое, но в моем оформлении. В теории все должно работать.

Минусы:
- *shutdown*-функция работает всегда, даже если ошибок нет;
- сброс буфера при фатальной ошибке стирает все то, что было нарисано до нее.
 
Отключить все это дело легко: закоментировать в *autoloader.php* назначеннные обработчики и буферизацию. 

**TODO** [УДАЛИТЬ]
У меня пока несколько вариантов по отлову фатальных ошибок:

1. вообще забить на такие ошибки. PHP ругнется, и мы узнаем об этом, если **есть вывод в браузер или stdout**. Если вывода нет, получим черный ящик. Вот для таких случаев полезно собственное логирование, которое можно организовать в shutdown-функции. Ситуация без выдачи ответа возможна при работе скрипта в *cron* или когда имеем REST-сервис без обратной связи. Да, я видел и такое :)

2. не колдовать с буферизацией и позволить PHP выдавать стандартные сообщения. При этом самостоятельно писать дополнительный лог в *shutdown*-функции. Не очень красиво учитывая, что другие ошибки все же идут через движок.

3. или описанный выше вариант. Пока тестирую именно его.

[/УДАЛИТЬ]

Кстати, лог пишется в `TEMP_PATH/kira_php_error.log`, константа **TEMP_PATH** задана в *index.php*. Сам каталог должен существовать и разрешать права на запись для web-сервера. Подробнее см. в доке *"Организация файлов"*. 
