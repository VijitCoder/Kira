# Логер

Класс `engine\Log`

Логер предназначен для записи критической информации (ошибок) на больших отрезках времени. Реально он нужен для записи ошибок на *production*. 

*Пример #1: движок сам логирует ошибку подключения к базе и ошибки sql-запросов. Во время разработки такие ошибки в основном отлавливаются. А вот когда на проде сбоит сервер БД - узнать об этом можно через логи этого класса.*

*Пример #2: логирование 404, 403 ошибок HTTP. Реализация зависит от приложения, но сама по себе информация полезна. Да, я знаю, про логи веб-сервера и их парсеры :) Я не настаиваю.*

## Конфигурация

Конфиг логера (подмассив в конфиге приложения):
```PHP
    'log' => [
        'switch_on'    => true,       // включить логирование
        'store'        => \engine\Log::[STORE_IN_DB | STORE_IN_FILES], // тип хранителя логов
        'db_conf_key'  => 'db',       // ключ конфига БД (пример), если храним логи в базе
        'table_name'   => 'kira_log', // таблица лога (значение по умолчанию) при записи в БД
        'log_path'     => TEMP_PATH,  // путь к каталогу, куда складывать файлы логов, если храним в файлах
        'php_timezone' => '',         // часовой пояс для записи лога
```
 
Логи могут писаться в БД или в файлы. Логер будет работать даже без явной конфигурации. По умолчанию он включен, пишет в файлы в каталоге, заданном в **TEMP_PATH**.

Выключать логер (настройка `switch_on`) имеет смысл в среде разработки (dev, local), чтобы не забивалась база/не плодились файлы.

Часовой пояс (настройка `php_timezone`): сайт может работать в одном поясе, а логи можно писать в поясе хостера хотя бы для того, чтобы в случае сбоя вести диалог с тех.поддержкой про одно и тоже время. Пояса по версии PHP, полный cписок [тут] (http://php.net/manual/en/timezones.php).

*Прим: префикс "php_" означает, что часовой пояс задается названием из списка поясов PHP. Для примера, в MySQL названия поясов могут быть другими.*
                         
Если задан каталог к файлам, он должен завершаться слешем. У веб-сервера должен быть доступ на запись в этот каталог. Если указать пустое значение для `log_path`, тогда логирование в файлы будет исключено.

**Внимание**. Даже при хранении логов в базе рекомендуется задать каталог для лог-файлов. В случае сбоя подключения к БД логер попытается писать в файлы. Если сбоит сохранение в файлы, будет отправлено письмо админу, один раз на каждый реквест браузера (если в сборке ответа есть логирование). Если не задан даже админский email, тогда всё - /dev/nul.

## Использование 

Рабочие методы логера: `Log::add()` и `Log::addTyped()`. Пример:

```PHP
    App::log()->add(['msg' => 'У нас тут серьезная ошибка', 'type' => Log::EXCEPTION, 'notify' => true]);
    
    App::log()->addTyped('Удалил запись по запросу', Log::UNTYPED);
```

Метод `add()` - полная версия с кучей параметров, `addTyped()` - сокращенная версия, только само сообщение и его тип. Описания ниже.
 
Сообщения лога, кроме текста, сопровождаются полезной информацией: дата/время, часовой пояс (для удобства анализа логов), тип сообщения, IP юзера, если удалось его получить, URL запроса, источник сообщения. Любое сообщение кроме записи в лог можно отправить на админский ящик.

**Важно**. При записи сообщения не проверяется доступ в базу или существование и создание каталога. Этим занимался метод инициализации, не тратим время в обычном рабочем процессе. 

#### Log::add()

Ожидаем либо строку с сообщением либо массив, содержащий сообщение и другие данные. Полный формат массива такой (*с указанием значений по умолчанию*):

```PHP
    [
        'message'    => string                 текст сообщения
        'type'       => const  | self::UNTYPED тип лога, см. константы этого класса
        'source'     => string | ''            источник сообщения
        'notify'     => bool | FALSE           флаг "Нужно оповещение по почте"
        'file_force' => bool | FALSE           сообщение писать в файл, независимо от настройки.
    ]
```


Если устраивают значения массива по умолчанию - тогда можно передать вместо него строковый параметр сообщения и всё. Иначе через ключи массива уточняем, что поменять в поведении записи лога.

Типы сообщения - строки, описанные в константах класса логера. Тип необязательно указывать константой класса. Легко можно ввести свой тип и указывать его. Это же строка, просто пишем, что нужно, в качестве типа лога.

**TODO** *перенести сюда константы типов*

Источник сообщения (*'src'*) - любой текст, например, имя метода или вообще произвольное описание. Может использоваться программистом для уточнения места, откуда отправлено сообщение. См. так же [волшебные константы PHP] (http://php.net/manual/ru/language.constants.predefined.php)

Уведомление на почту отсылается, если ящик указан в конфиге приложения, `admin_mail`.

Параметр `'file_force' = TRUE`. Движок логирует ошибки подключения в базе. Всегда пишет их в файлы, для принудительного переключения служит этот флаг. Можно использовать его и в своих целях. Кстати, ошибки SQL-запросов тоже логируются движком.

*Прим.: логирование ошибок запросов и подключений проиходит только при `DEBUG = false`. Иначе [PDOException] (http://php.net/manual/ru/class.pdoexception.php) пробрасывается дальше. Если настройкой подключения запрещены исключения, тогда логирования не будет. По теме можно почитать в [PDO::setAttribute()] (http://php.net/manual/ru/pdo.setattribute.php), PDO::ATTR_ERRMODE.*

#### Log::addTyped()

Функция-обертка: запись в лог сообщения с указанием типа.

Как оказалось, из всех параметров обычной записи в лог наиболее актуальным является тип лога, остальное можно принять по умолчанию. Для сокращенного вызова записи в лог служит данная обертка. Принимает два строковых параметра: само сообщение и его тип (в константах класса или произвольным текстом).

---

Работает так: при вызове метода `App::log()` один раз **на цикл выполнения приложения** создается объект логера. Вычисляются его настройки. Если указана настройка "запись в базу", но ключа конфига не существует, автоматически переключаемся на логирование в файлы (в лог будет добавлено сообщение об этой ошибке).
 
Если *очередное* сообщение не получится записать в БД (при заданной настройке, разумеется), переключаемся на запись в файлы, к сообщению добавляем инфу о ситуации с базой. Если нельзя писать и файлы, тогда логер переходит в аварийный режим: первое сообщение лога в цикле выполнения приложения будет отправлено админу независимо от параметра `notify` метода `Log::add()`. К сообщению будет добавлена информация о сбое. Остальные сообщения канут в Лету.

## Ручное создание окружения

Мастер приложения сам создает все необходимое для логера. Тем не менее, возможна ситуация, когда требуется его ручная настройка. Полная конфигурация логера описана в начале этого документа. Собственно, что нужно сделать руками:
- при логировании в файлы создать каталог для логов, разрешить права на запись в него для процесса веб-сервера.
- при логировании в БД, создать таблицу в заданной базе данных. Для MySQL-сервера запрос такой: 
```MySQL
CREATE TABLE `kira_log` (
    `id` int(12) unsigned NOT NULL AUTO_INCREMENT,
    `ts` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'Дата/время события',
    `timezone` char(10) NOT NULL COMMENT 'Часовой пояс, которому соответствует указанное время события',
    `logType` varchar(20) NOT NULL COMMENT 'Тип сообщения',
    `message` text NOT NULL COMMENT 'Сообщение',
    `userIP` char(15) DEFAULT '' COMMENT 'IPv4, адрес юзера, когда удалось его определить',
    `request` varchar(255) DEFAULT '' COMMENT 'URL запроса, в ходе обработки которого пишем лог',
    `source` varchar(100) DEFAULT '' COMMENT 'источник сообщения (функция, скрипт, какая-то пометка кодера)',
    PRIMARY KEY (`id`),
    KEY `ts` (`ts`),
    KEY `logType` (`logType`)
) ENGINE=MyISAM;
```

*Прим: имя таблицы может отличаться, в соответствии с конфигурацией логера.*

По дампу нужно отметить следующее: не задаем кодировку, тогда она будет, как у базы. Явно задаем движок таблицы `MyISAM`. Он значительно шустрее на select-ах и insert-ах, чем InnoDB. И логам не требуется поддержка транзакций. Явная выгода.

Все файлы логов (при логировании в файлы) будут в одном каталоге. Маска имен `yyyymmdd_kira_log.csv`, разделитель данных - точка с запятой. Каждый день новый файл. Дата в имени файла определяется в часовом поясе, заданном в настройке логера.
