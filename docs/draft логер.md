# Логер

Класс `engine\Log`. Логер предназначен для записи критической информации (ошибок) на больших отрезках времени. Реально он нужен для записи ошибок на *production*. 

*Пример #1: движок сам логирует ошибку подключения к базе и ошибки sql-запросов. Во время разработки такие ошибки в основном отлавливаются. А вот когда на проде сбоит сервер БД - узнать об этом можно через логи этого класса.*

*Пример #2: логирование 404, 403 ошибок HTTP. Реализация зависит от приложения, но сама по себе информация полезна. Да, я знаю, про логи веб-сервера и их парсеры :) Я не настаиваю.*

## Конфигурация

Конфиг логера (подмассив в конфиге приложения):
```PHP
    'log' => [
        'switch_on'    => true,      // включить логирование
        'store'        => \engine\Log::[STORE_IN_DB | STORE_IN_FILES], // тип хранителя логов
        'db_conf_key'  => 'db',      // ключ конфига БД, если храним логи в базе
        'log_path'     => TEMP_PATH, // путь к каталогу, куда складывать файлы логов, если храним в файлах
        'php_timezone' => '',        // часовой пояс для записи лога
```
 
Логи могут писаться в БД или в файлы. Логер будет работать даже без явной конфигурации. По умолчанию он включен, пишет в файлы в каталоге, заданном в **TEMP_PATH**.

Выключать логер (настройка `switch_on`) имеет смысл в среде разработки (dev, local), чтобы не забивалась база/не плодились файлы.

Часовой пояс (настройка `php_timezone`): сайт может работать в одном поясе, а логи можно писать в поясе хостера хотя бы для того, чтобы в случае сбоя вести диалог с тех.поддержкой про одно и тоже время. Пояса по версии PHP, полный cписок [тут] (http://php.net/manual/en/timezones.php).

*Прим: преффикс "php_" означает, что часовой пояс задается названием из списка поясов PHP. Для примера, в MySQL названия поясов могут быть другими.*
                         
Если задан каталог к файлам, он должен завершаться слешем. У веб-сервера должен быть доступ на запись в этот каталог. Если указать пустое значение для `log_path`, тогда логирование в файлы будет исключено.

**Внимание**. Даже при хранении логов в базе рекомендуется задать каталог для лог-файлов. В случае сбоя подключения к БД логер попытается писать в файлы. Если сбоит сохранение в файлы, будет отправлено письмо админу, один раз на каждый реквест браузера (если в сборке ответа есть логирование). Если не задан даже админский email, тогда всё - /dev/nul.

## Инициализация

Условия для логера создаются методом его инициализации, `Log::init()`. Предполагается одноразовый вызов этого метода, через мастер создания приложения (**TODO** *потребуется ссылка на док или URL к этой фиче*) или явным обращением из какого-то одноразового скрипта. Метод читает конфиг и создает по нему требуемое окружение. Возвращает ошибки, если что-то не получится.
**TODO** *дописать параметры метода инициализации. Особенно про ключи к СУБД с указанием базы*

Если среда уже создана, ненужные шаги будут пропущены. Для работы в БД нужны ключи юзера с правами создания базы и таблицы в базе. Для создания иерархии каталогов у веб-сервера должны быть права на такую операцию.

Исходим из того, что база под управлением СУБД MySQL, запросы написаны для неё.

Все файлы логов будут в одном каталоге, но если нет родительских каталогов, они тоже будут созданы при инициализации.

Для записи в базу будет создана таблица `kira_log` (MyISAM или InnoDB, UTF-8), запись в файлы ведется по маске *"yyyymmdd_kira_log.csv"*, разделитель данных ";". Каждый день новый файл.

*Прим.: при инициализации можно выбрать движок таблицы.*

*Прим.: дата в имени файла определяется в часовом поясе, заданном в настройке логера.*

## Использование 

Рабочие методы логера: `Log::add()` и `Log::addTyped()`. Пример:

```PHP
    App::log()->add(['msg' => 'У нас тут серьезная ошибка', 'type' => Log::EXCEPTION, 'notify' => true]);
    
    App::log()->addTyped('Удалил запись по запросу', Log::UNTYPED);
```

Метод `add()` - полная версия с кучей параметров, `addTyped()` - сокращенная версия, только само сообщение и его тип. Описания ниже.
 
Сообщения лога, кроме текста, сопровождаются полезной информацией: дата/время, часовой пояс (для удобства анализа логов), тип сообщения, IP юзера, если удалось его получить, URL запроса, источник сообщения. Любое сообщение кроме записи в лог можно отправить на админский ящик.

**Важно**. При записи сообщения не проверяется доступ в базу или существование и создание каталога. Этим занимался метод инициализации, не тратим время в обычном рабочем процессе. 

#### Log::add()

Ожидаем либо строку с сообщением либо массив, содержащий сообщение и другие данные. Полный формат массива такой (*с указанием значений по умолчанию*):

```PHP
    [
        'message'    => string                 текст сообщения
        'type'       => const  | self::UNTYPED тип лога, см. константы этого класса
        'source'     => string | ''            источник сообщения
        'notify'     => bool | FALSE           флаг "Нужно оповещение по почте"
        'file_force' => bool | FALSE           сообщение писать в файл, независимо от настройки.
    ]
```


Если устраивают значения массива по умолчанию - тогда можно передать вместо него строковый параметр сообщения и всё. Иначе через ключи массива уточняем, что поменять в поведении записи лога.

Типы сообщения - строки, описанные в константах класса логера. Тип необязательно указывать константой класса. Легко можно ввести свой тип и указывать его. Это же строка, просто пишем, что нужно, в качестве типа лога.

**TODO** *перенести сюда константы типов*

Источник сообщения (*'src'*) - любой текст, например, имя метода или вообще произвольное описание. Может использоваться программистом для уточнения места, откуда отправлено сообщение. См. так же [волшебные константы PHP] (http://php.net/manual/ru/language.constants.predefined.php)

Уведомление на почту отсылается, если ящик указан в конфиге приложения, `admin_mail`.

Параметр `'file_force' = TRUE`. Движок логирует ошибки подключения в базе. Всегда пишет их в файлы, для принудительного переключения служит этот флаг. Можно использовать его и в своих целях. Кстати, ошибки SQL-запросов тоже логируются движком.

*Прим.: логирование ошибок запросов и подключений проиходит только при `DEBUG = false`. Иначе [PDOException] (http://php.net/manual/ru/class.pdoexception.php) пробрасывается дальше. Если настройкой подключения запрещены исключения, тогда логирования не будет. По теме можно почитать в [PDO::setAttribute()] (http://php.net/manual/ru/pdo.setattribute.php), PDO::ATTR_ERRMODE.*

#### Log::addTyped()

Функция-обертка: запись в лог сообщения с указанием типа.

Как оказалось, из всех параметров обычной записи в лог наиболее актуальным является тип лога, остальное можно принять по умолчанию. Для сокращенного вызова записи в лог служит данная обертка. Принимает два строковых параметра: само сообщение и его тип (в константах класса или произвольным текстом).

---

Работает так: при вызове метода `App::log()` один раз **на цикл выполнения приложения** создается объект логера. Вычисляются его настройки. Если указана настройка "запись в базу", но ключа конфига не существует, автоматически переключаемся на логирование в файлы (в лог будет добавлено сообщение об этой ошибке).
 
Если *очередное* сообщение не получится записать в БД (при заданной настройке, разумеется), переключаемся на запись в файлы, к сообщению добавляем инфу о ситуации с базой. Если нельзя писать и файлы, тогда логер переходит в аварийный режим: первое сообщение лога в цикле выполнения приложения будет отправлено админу независимо от параметра `notify` метода `Log::add()`. К сообщению будет добавлена информация о сбое. Остальные сообщения канут в Лету.
