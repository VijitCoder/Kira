# DB

Движок точно работает с MySQL-сервером. Настройки в конфиге именно для него. Не гарантирую полную поддержку других СУБД.

ORM нет никакой. Пока нет :)

Конструктора запросов тоже нет. Они мне не нравятся. Я считаю неправильным такой подход: писать sql-запрос конструктором (иногда значительно больше, чем прямым текстом), но при этом не задумываться, какой реальный sql-запрос за ним стоИт и сколько времени он стОит. Максимальную скорость и эффективность можно получить, только описывая запросы на языке СУБД. И читаются они легче констуктора (ну если про MySQL говорить :))

Минус отсутствия ORM и/или конструктора - сменишь БД-сервер, например MySQL на PostgreSQL, придется переписывать весь слой моделей. Но! Сколько вы знаете случаев смены БД-сервера под рабочим сайтом? Вот и я о том же :)

В движке реализован класс `\kira\Db\DbModel`, в котором описана работа с базой данных и несколько методов общего применения. DB-модели приложения должны наследовать ее. При этом модель-наследник может не отражать в себе какую-то конкретную таблицу базы данных. Возможно это кому-то покажется слишком "низкоуровневым" кодингом запросов, но код в понимании проще, имхо.

По вопросам PDO очень полезная [статья](http://phpfaq.ru/pdo).

## Конфигурация

Конфигураций БД может быть несколько, описываются в настройках приложения. По умолчанию ключ *"db"*, другие конфиги можно описать произвольными ключами и указывать их в конструкторе `DbModel`. Рекомендую придерживаться соглашения: ключи конфигов базы данных имеют префикс *"db_"*.

Шаблон конфигурации БД:

```php
 'db' => [
    'dsn'            => string,
    'user'           => string,
    'password'       => string,
    'options'        => array | []
    'mysql_timezone' => string | '+00:00'
 ]
```

Обычно конфигурация c конфиденциальной информацией описывается в отдельном файле и не контролируется СКВ. По умолчанию мастер приложения (см. док *"Организация файлов > Мастер создания приложения"*) создает конфиг в `env.php`.

Почти все параметры соответствуют параметрам конструктора класса [PDO](http://php.net/manual/en/pdo.construct.php).

Про *"options"* можно почитать в [PDO::setAttribute()](http://php.net/manual/ru/pdo.setattribute.php).

*Прим.: несмотря на то, что **ключи** в PDO Options представляют собой **числовые константы**, массив настроек, описанный в `env.php`, успешно сливается c главным конфигом. Обеспечено особым методом движка, и об этом заботиться не нужно.*

#### Часовой пояс в MySQL-сессии

Полезные ссылки
waredom.ru: [Время в MySQL](http://waredom.ru/36#mysql)
stackoverflow.com: [How do I get the current time zone of MySQL?](http://stackoverflow.com/a/2934271/5497749)
stackoverflow.com: [Should MySQL have its timezone set to UTC?](http://stackoverflow.com/a/19075291/5497749)

Коротко, в чем смысл: часовой пояс для MySQL важен только для функций типа `now()`, `unix_timestamp()` и т.п. При записи даты/времени в поле типа DATE, DATETIME часовой пояс не пишется. Запись в поле TIMESTAMP сохраняется внутри MySQL в UTC не зависимо от часового пояса.

Что это дает: если вы хотите сохранить время с учетом часового пояса, то удобнее всего хранить его в нулевом поясе и при чтении переводить в нужный пояс. Т.е. вы всегда знаете, какое именно время у записи, независимо от перехода на летнее время, переезд базы на другой сервер или изменение настройки пояса на текущем сервере. Т.е. такой подход избавит вас от вероятных проблем в будущем.

Конечно если вы несогласны, тогда укажите в настройке приложения `mysql_timezone` желаемый часовой пояс. Формат значения должен быть понятен MySQL-серверу.

Если у вас есть доступ к MySQL-серверу, лучше сразу задать на нем требуемый часовой пояс. Потому что через PHP это будет дополнительный запрос при каждом соединении с базой:

```PHP
$dbh->prepare('SET time_zone = ?')->execute($conf['mysql_timezone']);
```

Только если в настройке `mysql_timezone` **пустая строка**, запрос не будет отправлен. Если настройки нет вообще, по умолчанию ее значение будет '+00:00' (GMT).

*Прим: префикс "mysql_" означает, что в случае, когда часовой пояс задается названием, он должен быть из списка поясов известных MySQL, таблица `mysql`.`time_zone`. В PHP названия поясов могут быть другими.*

#### Как можно задать пояс для MySQL в соответствии со временем скриптов?

Часовой пояс для php-скриптов может быть задан в *php.ini (date.timezone)* или через вызов в скипте:

```PHP
date_default_timezone_set('Asia/Novosibirsk');
```

Числовое значение пояса (даже с учетом летнего времени) можно получить через `php::date('P')`. Т.o. пишем в настройке базы:

```
db => [
    'mysql_timezone' => date('P'),
]
```

Теперь сессия с сервером MySQL будет работать в часовом поясе скриптов сайта.

## Использование

Работа с MySQL (а по умолчанию работаем именно с ней) идет через PDO. У движка есть обертки для подключения, подготовки и отправки запросов на сервер с последующим разбором ответа.

Подключение к БД осуществляется в конструкторе модели. Для переключения объекта модели на другую базу есть метод `DbModel::switchConnection()`.


#### Примеры работы с классом DbModel и его наследниками

**#1. Простой запрос**

```PHP
$ids = (new UserModel)
    ->query('SELECT id FROM Users ORDER BY id')
    ->fetchAll(\PDO::FETCH_NUM);
```

**#2. Запрос с подстановками**

```PHP
$uid = Request::getAsInt('uid');
$sql = 'SELECT login, mail, `status`, salt FROM Users WHERE id = ?';
$row = $this->query($sql, [$uid])->fetch();
```

*Прим.: поддерживаеются так же именованные подстановки. В таком случае передаем ассоциативный массив. См. так же полезный метод `DbModel::valueSet()`*

**#3. Служебные манипуляции, без выделения модели-наследника**

```PHP
if ((new DbModel)->query('TRUNCATE kira_log')->effect() > 0) {
    echo 'Таблица очищена';
}
```

**#4. Подготовка IN-условия**

```PHP
$sql = 'SELECT * FROM users WHERE id IN(:ids) AND status IN (:statuses) AND role = :role';
$params = [
    ':ids'      => [1, 4, 56],
    ':statuses' => ['active', 'new'],
    ':role'     => 'user'
];
$rows = (new UserModel)->prepareIN($sql, $params)->query(compact('sql', 'params'));
    ->prepareIN($sql, $params)
    ->query($sql, $params)
    ->fetchAll();
```

Что примечательно: все IN-подстановки будут подготовлены за один вызов метода `DBModel::prepareIN()`. Подстановка возможна только для именованного плейсходлера, т.к. заменить какой-то из кучи безымянных плейсхолдеров (помеченных знаком вопроса) - нетривиальная задача. Проще тогда написать свой парсер целиком.

Текстовые значения будут экранированы, другие значения останутся без изменений. Содержимое всего массива определяется по его первому элементу, т.е. считается что в нем однотипные данные.

Для экранирования строк используется [PDO::quote()](@see http://php.net/manual/en/pdo.quote.php). У него тоже есть ограничения, но это лучше, чем ничего.

**#5. Использование итератора**

```PHP
$iter = (new BlogModel)
    ->query('SELECT * FROM blog WHERE show_rec = 1 LIMIT 100')
    ->getIterator();

foreach ($iter as $row) {
    echo $row['date'] . ': ' . $row['title'];
    ...
}
```

Итераторы удобны тем, что в память выгружаются не все данные, а только один элемент массива. Применительно к запросу в базу: не все записи, а только одна. Экономия памяти в случае большого результата запроса. При этом, реализуя интерфейс \Iterator, получаем возможность обхода всех записей через цикл.

## Обработка ошибок

Ошибки запросов и подключения к БД пишутся в лог (см. док *"Логер"*). Если определено логирование в базу, тогда ошибки запросов пишутся в нее, ошибки подключения - в любом случае в файлы. Если в атрибутах подключения запрещены исключения, тогда логирования не будет. Про настройку тут [PDO::ATTR_ERRMODE](http://php.net/manual/ru/pdo.setattribute.php).

При возникновении ошибок в клиентский код будет проброшено исключение `kira\exceptions\DbException`.
