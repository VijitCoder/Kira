# DB

Движок точно работает с MySQL-сервером. Настройки в конфиге именно для него. Не гарантирую полную поддержку других СУБД.

ORM нет никакой. Пока нет :)

Конструктора запросов тоже нет. Они мне не нравятся. Я считаю неправильным такой подход: писать sql-запрос конструктором (иногда значительно больше, чем прямым текстом), но при этом не задумываться, какой реальный sql-запрос за ним стоИт и сколько времени он стОит. Максимальную скорость и эффективность можно получить, только описывая запросы на языке СУБД. И читаются они легче констуктора (ну если про MySQL говорить :))

Минус отсутствия ORM и/или конструктора - сменишь БД-сервер, например MySQL на PostgreSQL, придется переписывать весь слой моделей. Но! Сколько вы знаете случаев смены БД-сервера под рабочим сайтом? Вот и я о том же :)

В движке реализован класс `\engine\Db\DbModel`, в котором описана работа с базой данных и несколько методов общего применения. DB-модели приложения должны наследовать ее. При этом модель-наследник может не отражать в себе какую-то конкретную таблицу базы данных. Возможно это кому-то покажется слишком "низкоуровневым" кодингом запросов, но код в понимании проще, имхо.

## Конфигурация

Конфигураций БД может быть несколько, описываются в настройках приложения. По умолчанию ключ *"db"*, другие конфиги можно описать произвольными ключами и указывать их в конструкторе `DbModel`. Рекомендую придерживаться соглашения: ключи конфигов базы данных имеют префикс *"db_"*. 

Шаблон конфигурации БД:

```php
 'db' => [
    'dsn'            => string,
    'user'           => string,
    'password'       => string,
    'options'        => array | []
    'mysql_timezone' => string | '+00:00'
 ] 
```

Обычно конфигурация c конфиденциальной информацией описывается в отдельном файле и не контролируется СКВ. По умолчанию мастер приложения (см. док *"Организация файлов > Мастер создания приложения"*) создает конфиг в `env.php`.

Почти все параметры соответствуют параметрам конструктора класса [PDO] (http://php.net/manual/en/pdo.construct.php).

Про *"options"* можно почитать в [PDO::setAttribute()] (http://php.net/manual/ru/pdo.setattribute.php). 

*Прим.: несмотря на то, что **ключи** в PDO Options представляют собой **числовые константы**, массив настроек, описанный в `env.php`, успешно сливается c главным конфигом. Обеспечено особым методом движка, и об этом заботиться не нужно.* 

#### Часовой пояс в MySQL-сессии

Полезные ссылки
waredom.ru: [Время в MySQL] (http://waredom.ru/36#mysql)
stackoverflow.com: [How do I get the current time zone of MySQL?] (http://stackoverflow.com/a/2934271/5497749)
stackoverflow.com: [Should MySQL have its timezone set to UTC?] (http://stackoverflow.com/a/19075291/5497749)

Коротко, в чем смысл: часовой пояс для MySQL важен только для функций типа `now()`, `unix_timestamp()` и т.п. При записи даты/времени в поле типа DATE, DATETIME часовой пояс не пишется. Запись в поле TIMESTAMP сохраняется внутри MySQL в UTC не зависимо от часового пояса. 
 
Что это дает: если вы хотите сохранить время с учетом часового пояса, то удобнее всего хранить его в нулевом поясе и при чтении переводить в нужный пояс. Т.е. вы всегда знаете, какое именно время у записи, независимо от перехода на летнее время, переезд базы на другой сервер или изменение настройки пояса на текущем сервере. Т.е. такой подход избавит вас от вероятных проблем в будущем. 

Конечно если вы несогласны, тогда укажите в настройке приложения `mysql_timezone` желаемый часовой пояс. Формат значения должен быть понятен MySQL-серверу.

Если у вас есть доступ к MySQL-серверу, лучше сразу задать на нем требуемый часовой пояс. Потому что через PHP это будет дополнительный запрос при каждом соединении с базой:

```PHP
$dbh->prepare('SET time_zone = ?')->execute($conf['mysql_timezone']);
```

Только если в настройке `mysql_timezone` **пустая строка**, запрос не будет отправлен. Если настройки нет вообще, по умолчанию ее значение будет '+00:00' (GMT).

*Прим: префикс "mysql_" означает, что в случае, когда часовой пояс задается названием, он должен быть из списка поясов известных MySQL, таблица `mysql`.`time_zone`. В PHP названия поясов могут быть другими.*
                         
#### Как можно задать пояс для MySQL в соответствии со временем скриптов?
                         
Часовой пояс для php-скриптов может быть задан в *php.ini (date.timezone)* или через вызов в скипте:
 
```PHP
date_default_timezone_set('Asia/Novosibirsk');
```

Числовое значение пояса (даже с учетом летнего времени) можно получить через `php::date('P')`. Т.o. пишем в настройке базы:

```
db => [
    'mysql_timezone' => date('P'),
]
```

Теперь сессия с сервером MySQL будет работать в часовом поясе скриптов сайта.

## Использование 

Работа с MySQL (а по умолчанию работаем именно с ней) идет через PDO. У движка есть обертки для подключения, подготовки и отправки запросов на сервер с последующим разбором ответа.

Подключение к БД осуществляется в конструкторе модели. Для переключения объекта модели на другую базу есть метод `DbModel::switchConnection()`.

---

function __query($sql, $params = [])__: _$this_

Отправляем запрос в БД. Подготовка запроса и его выполнение. Перехват ошибок, сбор информации для отладки.

---

Результат запроса может быть каким-угодно. В зависимости от ожиданий можно использовать методы:

function __fetch($style)__: _mixed_
function __fetchAll($style)__: _mixed_
function __getIterator($style)__: _\engine\db\RowIterator_

`$style` в каком стиле выдать результат. Константы [PDO::FETCH_\*](http://php.net/manual/ru/pdostatement.fetch.php)

Это все для SELECT-запросов. Метод `DbModel::getIterator()` возвращает итератор, через который можно перебрать все ряды из результата запроса. В случае большого результата этот метод предпочтительнее, чем `DbModel::fetchAll()`, экономия памяти. 

---

function __effect()__: _int_

Для запросов, изменяющих данные в БД можно получить количество модифицированных строк.

---

function __findByField($field, $value, $ops = [])__: _mixed_
 
Не типичный метод. Поиск записи по заданному полю. Например, найти юзера по id или логину.. или мылу :) Подробности - в комментарии к методу.

---

Отдельная группа методов-оберток для управления транзациями:

function __beginTransaction()__
function __inTransaction()__
function __commit()__
function __rollBack()__

---

Для непосредственной работы с объектами PDO два геттера `getConnection()` и `getStatement()`.

Вспомогательные методы:
 
- `valueSet()` Подготовка ассоциативного массива данных для вставки в PDO запрос.
- `prepareIN()` Поддержка подстановок в IN()-выражения.

Подробности использования cм. в комментариях в коде.

---

#### Примеры работы с классом DbModel и его наследниками

**#1. Простой запрос**

```PHP
$ids = (new UserModel)
    ->query('SELECT id FROM Users ORDER BY id')
    ->fetchAll(\PDO::FETCH_NUM);
```

**#2. Запрос с подстановками**

```PHP
$uid = Request::getAsInt('uid');
$sql = 'SELECT login, mail, `status`, salt FROM Users WHERE id = ?';
$row = $this->query($sql, [$uid])->fetch();
```

*Прим.: поддерживаеются так же именованные подстановки. В таком случае передаем ассоциативный массив. См. так же полезный метод `DbModel::valueSet()`*

**#3. Служебные манипуляции, без выделения модели-наследника**

```PHP
if ((new DbModel)->query('TRUNCATE kira_log')->effect() > 0) {
    echo 'Таблица очищена';
}
```

**#4. Подготовка IN-условия**

```PHP
$sql = 'SELECT * FROM users WHERE id IN(:ids) AND status IN (:statuses) AND role = :role';
$params = [
    ':ids'      => [1, 4, 56], 
    ':statuses' => ['active', 'new'], 
    ':role'     => 'user'
];
$rows = (new UserModel)->prepareIN($sql, $params)->query(compact('sql', 'params'));
    ->prepareIN($sql, $params)
    ->query($sql, $params)
    ->fetchAll();
```

Что примечательно: все IN-подстановки будут подготовлены за один вызов метода `DBModel::prepareIN()`. Подстановка возможна только для именованного плейсходлера, т.к. заменить какой-то из кучи безымянных плейсхолдеров (помеченных знаком вопроса) - нетривиальная задача. Проще тогда написать свой парсер целиком.

**#5. Использование итератора**

```PHP
$iter = (new BlogModel)
    ->query('SELECT * FROM blog WHERE show_rec = 1 LIMIT 100')
    ->getIterator();
    
foreach ($iter as $row) {
    echo $row['date'] . ': ' . $row['title'];
    ...
}
```

## Обработка ошибок

Ошибки запросов и подключения к БД пишутся в лог (см. док *"Логер"*). Если определено логирование в базу, тогда ошибки запросов пишутся в нее, ошибки подключения - в любом случае в файлы. Если в атрибутах подключения запрещены исключения, тогда логирования не будет. Про настройку тут [PDO::ATTR_ERRMODE] (http://php.net/manual/ru/pdo.setattribute.php).
