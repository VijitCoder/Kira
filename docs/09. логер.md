# Логер

Класс `\kira\core\Logger`

Реализуемый интерфейс `\kira\core\AbstractLogger`

Логер можно подменить через конфиг приложения. Нужен в основном для возможности подмены реазлизации на mock-объект в unit-тестах. В целом логер хорошо реализован в движке и нет смысла в замене на свою реализацию.

Логер предназначен для записи критической информации (ошибок) на больших отрезках времени. Реально он нужен для записи ошибок на *production*.

*Пример #1: движок сам логирует ошибку подключения к базе и ошибки sql-запросов. Во время разработки такие ошибки в основном отлавливаются. А вот когда на проде сбоит сервер БД - узнать об этом можно через логи этого класса.*

*Пример #2: логирование 404, 403 ошибок HTTP. Реализация зависит от приложения, но сама по себе информация полезна. Да, я знаю, про логи веб-сервера и их парсеры. Я не настаиваю :)*

Сам по себе движок логирует ошибки подключения в базе. Ошибки SQL-запросов тоже логируются движком.

## Конфигурация

**Логер будет работать даже без конфигурации**. По умолчанию он включен, пишет в файлы в каталоге, заданном в **KIRA_TEMP_PATH**.

Конфиг логера (подмассив в конфиге приложения):

```PHP
'log' => [
    // 'class'     => string,
    'switch_on'    => bool | true,         включить логирование
    'store'        => Logger::[STORE_IN_DB | STORE_IN_FILES], тип хранителя логов
    'db_conf_key'  => string | 'db',       ключ конфига БД, если храним логи в базе
    'table_name'   => string | 'kira_log', таблица лога (значение по умолчанию) при записи в БД
    'log_path'     => string | KIRA_TEMP_PATH,  путь к каталогу, куда складывать файлы логов, если храним в файлах
    'php_timezone' => string | '',         часовой пояс для записи лога
]
```

Отключать логер (`switch_on => false`) имеет смысл в среде разработки (dev, local), чтобы не забивалась база/не плодились файлы.

Логи могут писаться в БД или в файлы (`store`). Для записи в БД можно определить ключ конфигурации базы (`db_conf_key`) и имя таблицы (`table_name`), иначе используются значения по умолчанию. **Доступ к базе и наличие таблицы уже должны быть, логер их не проверяет**. Дамп таблицы см. ниже в разделе *"Ручное создание окружения"*.

*Прим.: движок сам логирует ошибки подключения к базе из клиентского кода. При этом всегда пишет такие ошибки в файлы, независимо от настройки `store`.*

Часовой пояс (`php_timezone`): сайт работает в своем поясе, а логи можно писать в поясе хостера хотя бы для того, чтобы в случае сбоя вести диалог с тех.поддержкой про одно и тоже время. Пояса по версии PHP, полный cписок [тут](http://php.net/manual/en/timezones.php).

*Прим: префикс "php_" означает, что часовой пояс задается названием из списка поясов PHP. В MySQL, например, названия поясов могут быть другими.*

Если задан каталог к файлам (`log_path`), то:

- каталог должен существовать;
- путь должен вести от корня диска и завершаться слешем.
- у веб-сервера должен быть доступ на запись в этот каталог.

Если указать пустое значение для `log_path`, тогда логирование в файлы будет исключено.

**Внимание**. Даже при хранении логов в базу, рекомендуется задать каталог для лог-файлов. В случае сбоя подключения к БД логер попытается писать в файлы. Если сбоит сохранение в файлы, будет отправлено письмо админу (см. основной конфиг, `admin_mail`), один раз на каждый реквест браузера. Если не задан даже админский ящик, тогда всё - /dev/nul.

## Использование

Рабочие методы логера: `Log::add()` и `Log::addTyped()`. Пример:

```PHP
use \kira\core\Logger;

App::log()->add(['msg' => 'У нас тут серьезная ошибка', 'type' => Logger::EXCEPTION, 'notify' => true]);

App::log()->addTyped('Удалил запись по запросу', Logger::UNTYPED);
```

Метод `add()` - полная версия с кучей параметров, `addTyped()` - сокращенная версия, только само сообщение и его тип. Описания ниже.

*Почему `App::log()`, а не прямое обращение к классу: в зависимости от настроек и доступности базы, логирование может вестись в БД или файлы. Если таблица окажется недоступна, будем сбрасывать логи в файлы. Чтоб в течение выполнения приложения не выяснять на каждой записи в лог факт доступности базы, используем этот геттер.*

Работает так: при вызове метода `App::log()` один раз **на цикл выполнения приложения** создается объект логера. Вычисляются его настройки. Если указана настройка "запись в базу", но ключа конфига не существует, автоматически переключаемся на логирование в файлы (в лог будет добавлено сообщение об этой ошибке).

Если *очередное* сообщение не получится записать в БД (при заданной настройке, разумеется), переключаемся на запись в файлы, к сообщению добавляем инфу о ситуации с базой. Если нельзя писать и файлы, тогда логер переходит в аварийный режим: первое сообщение лога во время выполнения приложения будет отправлено админу независимо от параметра `notify` метода `Log::add()`. К сообщению будет добавлена информация о сбое. Остальные сообщения канут в Лету.

Сообщения лога, кроме текста, сопровождаются полезной информацией: дата/время, часовой пояс для удобства анализа логов, тип сообщения, IP юзера (если удалось его получить), URL запроса, источник сообщения. Дополнительно, кроме записи в лог, любое сообщение можно отправить на админский ящик.

---

function __add($data)__: _void_

Ожидаем либо строку с сообщением либо массив, содержащий сообщение и другие данные. Полный формат массива такой (*с указанием значений по умолчанию*):

```PHP
[
    'message'    => string                 текст сообщения
    'type'       => const  | Logger::UNTYPED тип лога, см. константы этого класса
    'source'     => string | ''            источник сообщения
    'notify'     => bool | FALSE           флаг "Нужно оповещение по почте"
    'file_force' => bool | FALSE           сообщение писать в файл, независимо от настройки.
]
```

Если устраивают значения массива по умолчанию - тогда можно передать вместо него строковый параметр сообщения и всё. Иначе через ключи массива уточняем, что поменять в поведении записи лога.

`message` - собственно сообщение. Дополнительная служебная информация будет добавлена автоматически.

`type` - тип сообщения. Строки, описанные в константах абстрактного класса логера:

```PHP
ENGINE     = 'engine',
DB_CONNECT = 'DB connection',
DB_QUERY   = 'DB query',
EXCEPTION  = 'exception',
HTTP_ERROR = 'HTTP error', // например, 404, 403 можно логировать
INFO       = 'information',
UNTYPED    = 'untyped';
```

Тип необязательно указывать константой класса. Легко можно ввести свой тип и указывать его. Это же строка, просто пишем, что нужно, в качестве типа лога.

`source` - источник сообщения. Любой текст, например, имя метода или вообще произвольное описание. Может использоваться программистом для уточнения места, откуда отправлено сообщение. См. так же [волшебные константы PHP](http://php.net/manual/ru/language.constants.predefined.php)

`notify` - уведомление на почту. Отсылается, если ящик указан в конфиге приложения, `admin_mail`. Пишем письмо, если установлен флаг или произойдет сбой логирования в файлы, т.е. когда письмо - это последний возможный вариант сообщить о проблеме.

`file_force`. Допустим, согласно конфигурации логера все пишется в таблицу БД. Но конкретное сообщение нужно сбросить в файлы. Для принудительного переключения служит этот флаг.

---

function __addTyped($message, $type)__: _void_

Функция-обертка: запись в лог сообщения с указанием типа.

Как оказалось, из всех параметров обычной записи в лог наиболее актуальным является тип лога, остальное можно принять по умолчанию. Для сокращенного вызова записи в лог служит данная обертка. Принимает два строковых параметра: само сообщение и его тип (в константах класса или произвольным текстом).

## Ручное создание окружения

Мастер приложения сам создает все необходимое для логера. Тем не менее, возможна ситуация, когда требуется его ручная настройка. Полная конфигурация логера описана в начале этого документа. Собственно, что нужно сделать руками:

- при логировании в файлы создать каталог для логов, разрешить права на запись в него для процесса веб-сервера.
- при логировании в БД, создать таблицу в заданной базе данных. Для MySQL-сервера запрос такой:

```MySQL
CREATE TABLE `kira_log` (
    `id` int(12) unsigned NOT NULL AUTO_INCREMENT,
    `created_at` DATETIME NOT NULL COMMENT 'Дата/время события',
    `timezone` char(10) NOT NULL COMMENT 'Часовой пояс, которому соответствует указанное время события',
    `log_type` varchar(20) NOT NULL COMMENT 'Тип сообщения',
    `message` text NOT NULL COMMENT 'Сообщение',
    `user_ip` char(15) DEFAULT '' COMMENT 'IPv4, адрес юзера, когда удалось его определить',
    `request` varchar(255) DEFAULT '' COMMENT 'URL запроса, в ходе обработки которого пишем лог',
    `source` varchar(100) DEFAULT '' COMMENT 'источник сообщения (функция, скрипт, какая-то пометка кодера)',
    PRIMARY KEY (`id`),
    KEY `created_at` (`created_at`),
    KEY `log_type` (`log_type`)
) ENGINE=MyISAM;
```

*Прим: имя таблицы может отличаться, в соответствии с конфигурацией логера.*

По дампу нужно отметить следующее: не задаем кодировку, тогда она будет, как у базы. Явно задаем движок таблицы `MyISAM`. Он значительно шустрее на select-ах и insert-ах, чем InnoDB. И логам не требуется поддержка транзакций. Явная выгода.

Все файлы логов (при логировании в файлы) будут в одном каталоге. Маска имен `yyyymmdd_kira_log.csv`, разделитель данных - точка с запятой. Каждый день новый файл. Дата в имени файла определяется в часовом поясе, заданном в настройке логера.
