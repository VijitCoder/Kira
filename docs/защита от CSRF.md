# Защита от CSRF атаки

CSRF-токен защиты может храниться на стороне клиента в cookie или на стороне сервера в сессии. Любой из выборов имеет достоинства и недостатки: печеньку можно украсть, но проще доступ из js; сессия нагружает сервер, особенно если она хранится в базе, зато меньше вероятность, что токен сперли. Выбор за вами.

Для создания токена вызвать `CsrfProtection::createToken()` или `CsrfProtection::getfToken(true)`. Где при этом будет сохранен созданный токен, определяется параметром `$clientStore` в указанных методах.

Имя печеньки токена или сессионного ключа - `CSRF_TOKEN`.

В модели формы есть свойство `$checkCsrf`. Если нужна проверка, ставим `TRUE`. Передать токен можно в поле формы `csrf-token` или в заголовке `X-Csrf-Token`. При включенной проверке модель формы попытается сначала найти токен среди переданных данных, потом поищет в заголовках.

Токен проверяется при валидации формы, непосредственно перед валидацией полей. Поскольку это внутренний механизм, то в нем нельзя указать, где хранится выданный токен, - в сессии или cookie. Поэтому начала предпринимается попытка найти его в печеньке, потом в сессии.

В итоге имеем: эталон токена - из печеньки или сессии, токен, переданный клиентом - из массива данных или заголовка запроса.

Если токен не пройдет проверку, будет проброшено исключение `FormException` с кодом 400. Именно исключение, а не просто ошибка валидации, т.к. токен не зависит от действий юзера, это скорее сбой приложения, реакция соответствующая. Код передается для удобства, клиентское приложение может по-своему реагировать на такое исключение.

*Прим: код 400 взят по аналогии с HTTP-кодом "400 Bad request".*

Проверка токена возможна только в GET и POST запросах.

## Ajax

В ajax-запросы токен тоже нужно как-то передавать. Если хранить ее в cookie, то можно прочитать без проблем. Другой вариант - писать токен в мета-тег страницы и читать его оттуда, тогда можно хранить эталон в сессии. Пример с мета-тегом:

```html
<meta name="csrf-token" content="<?=\kira\net\Request::getCsrfToken()?>">
```

Где бы он не хранился, его удобно прописать его для jQuery/ajax в настройках. Например, передача токена в заголовке:

```js
$.ajaxSetup({
    headers: {
        'X-Csrf-Token': $('meta[name="csrf-token"]').attr('content')
        // или
        'X-Csrf-Token': $.cookie('CSRF_TOKEN')
    }
});
```

*`$.cookie` это плагин, [**JQuery cookie**](https://github.com/carhartl/jquery-cookie#usage)*

Добавление токена в при POST:

```js
$.ajaxSetup({
    beforeSend: function(xhr, settings) {
        if (settings.type.toLowerCase() === 'post')
        xhr.setRequestHeader('X-Csrf-Token', $.cookie('CSRF_TOKEN'));
    }
});
```

**Не рекомедую делать так**:

```js
$.ajaxSetup({
    data: {
        'csrf-token': $.cookie('CSRF_TOKEN')
    }
});
```

В таком решении, во-первых, токен будет передаваться так же и в (ajax)GET, имхо, это лишнее. Во-вторых, при использовании сериализации форм в ваших ajax-конструкциях эта установка будет стерта, [пруфЪ](https://coderwall.com/p/cxwg_g/setting-up-jquery-to-pass-csrf-tokens-to-django)
