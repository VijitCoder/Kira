# Утилиты

Каталог [engine/utils/]. Не описываю детально каждый метод. Просто лень :) Тут упомянуты только те методы, по которым комментариев в коде недостаточно.

Для всех классов утилит есть модульные тесты. Можно смотреть для получения примеров.

## Arrays

Класс `\kira\utils\Arrays`

Работа с массивами. В это трудно поверить, но при всем богатстве php-методов все еще есть, что свое написать :) В частности, методы работы с многомерными массивами через рекурсию или извлечение конечного значения по многомерному ключу массива.

В PHP есть [SPL с итераторами](http://php.net/manual/ru/spl.iterators.php). Но как показывает практика, например, [тут](http://php.net/manual/ru/class.recursiveiteratoriterator.php#112713), рекурсивные функции быстрее. Хотя конечно для всех итераторов я тесты не видел.

---

Получение значения из массива по заданной цепочке ключей

function __getValue(array &$arr, $chain)__: _mixed_

В чем смысл. Допустим, есть некий многомерный массив:

```php
$data = [
    'path' => [
        'app' => [
            'level1' => '/home',
            'level2' => '/www',
        ],
    ],
 ...
];
```

Нужно получить значение из `level2`. В обычной ситуации это будет:

```php
$v = $data['path']['app']['level2'];
```

Но когда мы не можем напрямую описать ключи, используем эту функцию:

```php
/**
 * Получение сообщения для конкретного поля формы
 * @param array $messages многомерный массив сообщений по полям формы
 * @param array $key      многомерный массив ключей, указывающий на конкретное поле
 */
function getMessage($messages, $key)
{
    return Arrays::getValue($messages, $key);
}
```

---

Стабильная сортировка массива через callback-функцию.

function __stableSort(array &$array, callable $comparisionFunction)__: _void_

Все PHP `*sort()` функции нестабильны. Они могут перемешать результ, если в массиве больше 16 элементов И если
некоторые из них равны. Эта проблема известна годами, но до сих пор присутствует в PHP 7.1. Официально в мануле сказано:

> Если оба сравниваемых значения эквивалентны, то порядок их в отсортированном массиве не определен.

На практике это означает, что равные элементы могут быть переставлены между собой, что не есть гуд. С точки зрениясортировки ошибки нет, т.к. функция сказала, что элементы равны, значит из положение относительно друг друга не имеет значения. Но с клиентской стороны иногда нужно, чтобы исходное положение равных элементов все же не поменялось. Для этого служит метод `stableSort()`.

## ColorConsole

Класс `\kira\utils\ColorConsole`

Работа с консолью через управляющие последовательности: цвет, стиль текста и т.п. Так же можно рисовать в консоли, перемещая курсор и используя пвсевдографику.

Для кодов псевдографики рекомендую заглянуть [сюда](https://unicode-table.com/ru/blocks/box-drawing/)

Пример использования:

```php
(new ColorConsole)
    ->setBgColor('white')

    ->setColor('green')
    ->addText('test')

    ->setColor('red')
    ->setStyle('italic')
    ->addText(' some')

    ->reset()
    ->draw(PHP_EOL)
    ->flush();
```

Получится два слова на белом фоне, первое - зеленым текстом, второе - красным курсивом.

**Важный момент**: все сеттеры на самом деле добавляют управляющие последовательности в текст. Поэтому если вы сбросили текст, например функцией `ColorConsole::setText()`, то заданные ранее цвета и стили будут стерты.

Ссылки по теме:

[Управление курсором, цветом и звуком консоли Linux](https://www.opennet.ru/base/dev/console_ctl.txt.html)
[man 4 console_codes](https://www.opennet.ru/man.shtml?topic=console_codes&category=4&russian=0)
[Box drawing in PHP](http://jonathonhill.net/2012-11-26/box-drawing-in-php/)

## Dumper

Класс `\kira\utils\Dumper`

Дамп переменной. Взял в Yii 1.x и слегка переделал под себя. Все публичные методы этой утилиты работают аналогично php::var_dump() и php::print_r(), но возвращают информацию в более приглядном виде.

В движке есть "shortcut"-функция для отладки - `dd()`. Обращается именно в этот класс, но доступна в любом месте сайта, без подключения класса, namespaces и т.д.

## Enum

Класс `\kira\utils\Enum`

Абстрактный класс. Наследники должны представлять собой классы, содержащие только константы. В классе `Enum` несколько полезных методов по работе с такими константами.

На практике выделение класса под константы оказывается удобно. Пример: есть статусы пользователя: `new`, `active`, `banned`, `deleted`. Обычно такие статусы в базе хранятся в поле `enum`. В коде желательно избегать строковых значений, следовательно нужны константы для каждого статуса. Но где их хранить? Первая мысль - в модели, т.к. есть соответствие данным базы. Но что, если нет четкого равенства между моделью пользователя и таблицами пользователя? К тому же, статусы только в базе хранятся в каком-то поле, в коде бэкенда действия с ними могут происходить в любом слое приложения.

Вот для этого заводим отдельный класс `UserStatus`, и в нем описываем все статусы пользователя. Причем класс не относится к какому-то слою приложения, он общедоступен из любого из них.

Кстати, иногда требуется так же передать все статусы на фронт, используйте `Enum::getConstants()`.

## FS

Класс `\kira\utils\FS`

Файловая система. В основном это обертки PHP-функций, но с перехватом ошибок. Если что-то пойдет не так, функции этого класса возвращают сообщение об ошибке, а не роняют код с E_ERROR. Особого внимания заслуживают функции работы с каталогами.

---

function __normalizePath($path, $isFile = false)__: _string_
function __isWindowsRootedPath($path)__: _bool_

Первая функция приводит любую запись пути каталогов к одному виду: все слеши заменяются на прямые (как принято в Linux), нет слеша в начале, есть слеш в конце, если переданный путь не ведет к файлу.

Удаление ведущего слеша порождает проблему: когда нужно получить абсолютный путь, приходится его дописывать. Но тогда нарушится кросс-платформенность приложения, потому что абсолютные пути в стиле Windows не содержат ведущий слеш. Поэтому придумана вторая функция, для определения, на какой каталог похожа проверяемая строка.

Зачем такие заморочки, можно бы просто при нормализации не изменять наличие ведущего слеша? Тогда нет уверенности, что нормализованный каталог будет именно таким, как ожидается. И поэтому приходится в клиентском коде втыкать удаление этого слеша для получения гарантированно однозначного результата. Практика показала, что текущее решение - удобнее.

---

Создание каталога:

function __makeDir($path, $mode = 0777)__: _true|string_

Как работает: выясняем, сколько каталогов по пути нужно будет создать. Создаем все разом через `php::mkdir()`. Каждому новому каталогу с конца назначаем требуемые права. Почему с конца: если запрещено исполнение, то в каталог нельзя будет попасть после установки прав.

Не используем для вычисления родителя функцию `php::dirname()`, она привносит свои заморочки.

**Какая польза от этого метода**

По умолчанию, линуксовые команды из PHP скрипта выполняются от имени юзера, запускающего скрипт. Т.е. когда скрипт запускает сервер Apache, юзером числится *www-data*.

При создании каталогов с назначением прав через [php::mkdir()](http://php.net/manual/ru/function.mkdir.php) учитывается так же текущее значение `umask`. Об этом можно почитать в [Википедии](https://ru.wikipedia.org/wiki/Umask) и в мануале PHP по соответствующим функциям. Коротко: что указано в umask, то будет запрещено в правах к каталогу. На практике обычно получаем такие права к каталогу: 755. Это значит, что кроме создателя остальным можно только читать из него.

Сообсно, в чем суть проблемы: во время разработки сайта с такими каталогами неудобно работать, прав не хватает. Даже если создать каталог с полным доступом всем, получим грабли при создании вложенных каталогов!

Пример. Допустим, есть временный каталог приложения [/www/site/temp/]. В нем для импорта нужно создать такую иерархию [/www/site/temp/import/XXX/], где XXX - это timestamp на момент создания. Код с использованием нативных php-функций будет таким:

```php
$path = '/www/site/temp/import/' . time();
mkdir($path);
chmod($path, 0777);
```

В итоге получим права:

```sh
user@comp:/www/site/temp$ ls -l
drwxr-xr-x 3 www-data www-data   4096 Jun  3 14:10 import

user@comp:/www/site/temp/import$ ls -l
drwxrwxrwx 2 www-data www-data 4096 Jun  3 14:12 1464937950
```

В чем проблема? Нельзя удалить каталог из [import/], т.к. прав недостаточно. Зато свободно можно работать в его подкаталоге. Вообщем, мне это неудобно. Функция

```php
function makeDir($path, $mode): bool|string
```

создает все каталоги до заданного и задает всем новым каталогам указанные права.

Кроме прочего, она перехватывает ошибки от PHP функций `mkdir()` и `chmod()` и возвращает их строкой. Без перехвата был бы `E_WARNING`.

---

function __removeDir($path, $fuseLevel = 1)__: _true|string_

Удаление каталога с подкаталогами и файлами.

`$fuseLevel` - максимальный уровень вложенности каталогов используется как предохранитель (чтобы себе в ногу не выстрелить): сначала выясняем, превышает ли заданный уровень реальная вложенность, и возвращаем ошибку, если так. Только потом удаляем, через рекурсию вспомогательной функции.

Сделал суровые условия: удалить можно от 1 до 4 уровней каталогов. Это очень опасная функция, нужно вообще избегать ее использования.

---

function __clearDir($path, $filter = '')__: _true|string_

Очистка каталога от файлов.

Не работает с подкаталогами из соображений безопасности, очистка проводится только в текущем каталоге. Удаляем все файлы или подходящие под заданный фильтр (регулярное выражение). Символические ссылки тоже удаляются, оригиналы файлов при этом не будут затронуты.

*Прим.: для очистки процессу нужен доступ на запись в целевой каталог. Доступ к файлам может вообще отсутствовать.*

## Mailer

Класс `\kira\utils\Mailer`

Простой класс по отправке почты. Способен создать и отправить письмо любой сложности, с вложениями, прикрепленными файлами, разными версиями письма. Но в итоге функционал опирается на функцию `php::mail()`. Мне некогда писать свою низкоуровневую реализацию на сокетах.

Есть несколько RFС по стандарту электронных писем. Однако не все почтовые клиенты им следуют, да и не все сервера.

> Например, чтобы Thunderbird 38.5 увидел имя прикрепленного файла, нужно его указывать после MIME, причем в той же строке. Или после attachment, и опять же в той же строке. Странно, но только так работает.

Вопрос отправки писем имеет множество ньюансов. Если методы этого класса не работают в вашем случае - создавайте свои :) Ну или используйте сторонние библиотеки разной степени глючности и веса.

Полезно почитать

- [php::mail()](http://php.net/manual/ru/function.mail.php)
- [Как грамотно отправлять почту из скриптов](https://habrahabr.ru/post/17531/)
- [RFC 2047 - MIME. Part Three](http://www.faqs.org/rfcs/rfc2047.html): *"Message Header Extensions for Non-ASCII Text"*. Тут изложены требования к заголовкам писем, кодированию текста и разбивке на строки.

#### Сложное письмо с вложениями

function __complex__(_string_ __$from__, _string_ __$to__, _string_ __$subject__, __$body__, _array_ __$files__ = [])): _bool_

<table>
    <tr><td><b>$from</b></td><td>от кого</td></tr>
    <tr><td><b>$to</b></td><td>кому</td></tr>
    <tr><td><b>$subject</b></td><td>тема письма</td></tr>
    <tr><td><b>$body</b></td><td>текст письма. Если массив, тогда [text|html|MIME-type => тест письма]</td></tr>
    <tr><td><b>$files</b></td><td>вложения. Смешанный массив</td></tr>
</table>

**Версии текстов письма**

Параметр `$body`. Можно указать несколько версий текста. Де-факто люди пишут *text* и *html* версии. Порядок включения текстов в письмо соответствует порядку их указания в массиве.

Пример описания версий письма:

```php
[
    'text' => ...,
    'html' => ...,
    'text/html; charset=win-1251' => ...  //тоже html, но в другой кодировке
]
```

Для ключей `text|html` будут установлены нужные заголовки Content-Type (кодировка utf-8). Любые другие ключи пропишутся в Content-Type как есть. Такие "другие" версии - эксперимент, не гарантирую их корректную работу со связанным контентом из вложений.

Если тело письма не является массивом, считаем его html-текстом и снабжаем заголовком `Content-Type: text/html; charset=utf-8`.

**Вложения**

Параметр `$files`. Можно вложить файлы. Можно добавить картинки в html-версию и так же их приложить к письму. Пример вложений:

```php
[
    0 => '/path/file.zip',
    1 => '/another/path/file.doc',
    '/images/head.png' => 'image/png',
    '/images/logo.jpg' => 'image/jpeg',
    28 => 'images/just_file.jpg',
]
```

Когда ключ числовой, файл будет описан как вложение с `Content-Type: application/octet-stream;`.

Если ключ строковый, тогда он указывает на картинку, значение - ее MIME-тип. Такие файлы будут вложены как данные,связанные с html-текстом письма (multipart/related). Подключить их можно через `src="cid:image_file"` в теге [img].

Замечания:

- встроенные в html картинки можно не передавать, как вложения, если прописывать в теге [img] полный URL к картинке-источнику. При этом почтовый клиент должен запросить их по заданному адресу.

- связи с картинками (multipart/related) оформляются только для версии письма, отмеченной "html". Как такие связи будут работать с другими версиями - я не знаю, официально не поддерживается.

#### Баг

У себя на локалке обнаружил баг при подготовке строк заголовков согласно стандарта **RFC 2047 Part Thr**. В конце кодированного значения **From, To** и **Reply-To** добавляется имя моей машины:

> From: =?utf-8?b?0K7Qt9C10YAgT25lIDx1c2VyX29uZUBtYWlsLnJ1Pg==?=@Z710

Причем это не PHP, т.к. дамп готовых значений ничего лишнего не показывает. Если записать одинаковое значение в адрес отправителя и в тему письма, то этот хвост появляется только у адресов! Эта приписочка очевидно ломает адрес получателя и письмо не доходит. Либо программа `mail` гонит, либо сервис `postfix`, на котором я провожу тесты. Не знаю, как искать причину. Пока отключил кодирование заголовков. На боевом стоит проверить, если бага не будет, оставить функцию включенной.

## Strings

Класс `\kira\utils\Strings`

Работа со строками. В классе есть:

- клевая функция для генерации пароля по заданным требованиям
- транслитеральные функции (en-ru)
- функция для склонения слова в зависимости от заданного числа
- недостающие функции обработки мультибайтных строк

---

Разбиение строки на части заданной длины в буквах:

function __word_chunk($str, $len = 76, $end = "\r\n")__: _string_

Безопасно для мультибайтных строк, т.е. не разделит букву посредине ее кода. Такой проблемой страдают php-функции `chunk_split()` и `wordwrap()` (в случае, когда ей разрешено разбивать слова). Эти функции делят строку по байтам.

При выборе требуемой длины следует вычитать символы конца строки. Функция их добавляет к итоговой длине.
Например, Strings::word_chunk('русский', 3, ' + ') даст 'рус + ски + й'

---

Проверка: символ экранирован

function __isShielded(string $text)__: _bool_

Это узкоспециализированная функция. Полезна в случае парсинга строки, например, для добавления в нее стилей. Практический пример: я использую эту функцию для нахождения закрывающих кавычек и скобок в упаковщике статики.

Как использовать: предположим у вас есть некий текст, ваш код нашел в нем символ, который влиет на дальнейшее поведение программы, но только при условии, что он не экранирован. Передаете в функцию весь текст до этого символа. Она посчитает количество обратных слешей в конце строки (т.е. переданного текста). Если количество нечетное, значит символ экранирован. Т.е. парные слеши - это экранирование их самих (первый экранирует второй), а свободный слеш уже экранирует следующий за ним символ.

## Typecast

Строгое приведение типов. Если переданное значение не может без изменений трактоваться, как ожидается, возращаем NULL или то значение, которое указано, как заменитель.

Приведение типов может быть полезным для чисел, строк и логических значений. Иными словами, для скалярных величин.

Замечание относительно `Typecast::bool()` и `Strings::strBool()`. Назначение у этих функций противоположное: первая превращает значение из ожидаемого набора в логическое TRUE|FALSE, вторая же заменяет допустимое логическое значение на его строковое название. Похожим образом работает `php::strval()`, но и тут есть разница. Используя эту функцию можно получить только преобразование `true = "1"`, `false = "0"` и все. А `Strings::strBool()` может выдать "true", "да", "1" и т.д.
