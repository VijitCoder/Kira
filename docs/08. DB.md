# DB

Движок точно работает с MySQL-сервером. Настройки в конфиге именно для него. Не гарантирую полную поддержку других СУБД.

ORM нет никакой. Пока нет :)

Конструктора запросов тоже нет. Они мне не нравятся. Я считаю неправильным такой подход: писать sql-запрос конструктором (иногда значительно больше, чем прямым текстом), но при этом не задумываться, какой реальный sql-запрос за ним стоИт и сколько времени он стОит. Максимальную скорость и эффективность можно получить, только описывая запросы на языке СУБД. И читаются они легче констуктора (ну если про MySQL говорить :))

Минус отсутствия ORM и/или конструктора - сменишь БД-сервер, например MySQL на PostgreSQL, придется переписывать весь слой моделей. Но! Сколько вы знаете случаев смены БД-сервера под рабочим сайтом? Вот и я о том же :)

В движке реализован класс `\kira\Db\DbModel`, в котором описана работа с базой данных и несколько методов общего применения. DB-модели приложения должны наследовать ее. При этом модель-наследник может не отражать в себе какую-то конкретную таблицу базы данных, т.е. **модель !== таблица**. Модель объединяет SQL запросы, связанные *логической областью использования*.

Возможно это кому-то покажется слишком "низкоуровневым" кодингом запросов, но код в понимании проще, имхо.

По вопросам PDO очень полезная [статья](http://phpfaq.ru/pdo).

## Конфигурация

Конфигураций БД может быть несколько, описываются в настройках приложения. По умолчанию ключ *"db"*, другие конфиги можно описать произвольными ключами и указывать их в конструкторе `DbModel`. Рекомендую придерживаться соглашения: ключи конфигов базы данных имеют префикс *"db_"*.

Шаблон конфигурации БД:

```php
 'db' => [
    'dsn'            => string,
    'user'           => string,
    'password'       => string,
    'options'        => array | []
    'mysql_timezone' => string | '+00:00'
 ]
```

Обычно конфигурация c конфиденциальной информацией описывается в отдельном файле и не контролируется СКВ. По умолчанию мастер приложения (см. док *"Организация файлов > Мастер создания приложения"*) создает конфиг в `env.php`.

Почти все параметры соответствуют параметрам конструктора класса [PDO](http://php.net/manual/en/pdo.construct.php).

Про *"options"* можно почитать в [PDO::setAttribute()](http://php.net/manual/ru/pdo.setattribute.php).

*Прим.: несмотря на то, что **ключи** в PDO Options представляют собой **числовые константы**, массив настроек, описанный в `env.php`, успешно сливается c главным конфигом. Обеспечено особым методом движка, и об этом заботиться не нужно.*

#### Часовой пояс в MySQL-сессии

Полезные ссылки
waredom.ru: [Время в MySQL](http://waredom.ru/36#mysql)
stackoverflow.com: [How do I get the current time zone of MySQL?](http://stackoverflow.com/a/2934271/5497749)
stackoverflow.com: [Should MySQL have its timezone set to UTC?](http://stackoverflow.com/a/19075291/5497749)

Коротко, в чем смысл: часовой пояс для MySQL важен только для функций типа `now()`, `unix_timestamp()` и т.п. При записи даты/времени в поле типа DATE, DATETIME часовой пояс не пишется. Запись в поле TIMESTAMP сохраняется внутри MySQL в UTC не зависимо от часового пояса.

Что это дает: если вы хотите сохранить время с учетом часового пояса, то удобнее всего хранить его в нулевом поясе и при чтении переводить в нужный пояс. Т.е. вы всегда знаете, какое именно время у записи, независимо от перехода на летнее время, переезд базы на другой сервер или изменение настройки пояса на текущем сервере. Т.е. такой подход избавит вас от вероятных проблем в будущем.

Конечно если вы не согласны, тогда укажите в настройке приложения `mysql_timezone` желаемый часовой пояс. Формат значения должен быть понятен MySQL-серверу.

Если у вас есть доступ к MySQL-серверу, лучше сразу задать на нем требуемый часовой пояс. Потому что через PHP это будет дополнительный запрос при каждом соединении с базой:

```PHP
$dbh->prepare('SET time_zone = ?')->execute($conf['mysql_timezone']);
```

Только если в настройке `mysql_timezone` **пустая строка**, запрос не будет отправлен. Если настройки нет вообще, по умолчанию ее значение будет '+00:00' (GMT).

*Прим: префикс "mysql_" означает, что в случае, когда часовой пояс задается названием, он должен быть из списка поясов известных MySQL, таблица `mysql`.`time_zone`. В PHP названия поясов могут быть другими.*

#### Как можно задать пояс для MySQL в соответствии со временем скриптов?

Часовой пояс для php-скриптов может быть задан в *php.ini (date.timezone)* или через вызов в скипте:

```PHP
date_default_timezone_set('Asia/Novosibirsk');
```

Числовое значение пояса (даже с учетом летнего времени) можно получить через `php::date('P')`. Т.o. пишем в настройке базы:

```
db => [
    'mysql_timezone' => date('P'),
]
```

Теперь сессия с сервером MySQL будет работать в часовом поясе скриптов сайта.

## Использование

Работа с MySQL (а по умолчанию работаем именно с ней) идет через PDO. У движка есть обертки для подключения, подготовки и отправки запросов на сервер с последующим разбором ответа.

Подключение к БД осуществляется в конструкторе модели. Для переключения объекта модели на другую базу есть метод `DbModel::switchConnection()`.


#### Примеры работы с классом DbModel и его наследниками

**#1. Простой запрос**

```PHP
$ids = (new UserModel)
    ->query('SELECT id FROM Users ORDER BY id')
    ->fetchAll(\PDO::FETCH_NUM);
```

**#2. Запрос с подстановками**

```PHP
$uid = Request::getAsInt('uid');
$sql = 'SELECT login, mail, `status`, salt FROM Users WHERE id = ?';
$row = $this->query($sql, [$uid])->fetch();
```

*Прим.: поддерживаеются так же именованные подстановки. В таком случае передаем ассоциативный массив. См. так же полезный метод `DbModel::valueSet()`*

**#3. Служебные манипуляции, без выделения модели-наследника**

```PHP
if ((new DbModel)->query('TRUNCATE kira_log')->effect() > 0) {
    echo 'Таблица очищена';
}
```

**#4. Подготовка IN-условия**

```PHP
$sql = 'SELECT * FROM users WHERE id IN(:ids) AND status IN (:statuses) AND role = :role';
$params = [
    ':ids'      => [1, 4, 56],
    ':statuses' => ['active', 'new'],
    ':role'     => 'user'
];
$rows = (new UserModel)->prepareIN($sql, $params)->query(compact('sql', 'params'));
    ->prepareIN($sql, $params)
    ->query($sql, $params)
    ->fetchAll();
```

Что примечательно: все IN-подстановки будут подготовлены за один вызов метода `DBModel::prepareIN()`. Подстановка возможна только для именованного плейсходлера, т.к. заменить какой-то из кучи безымянных плейсхолдеров (помеченных знаком вопроса) - нетривиальная задача. Проще тогда написать свой парсер целиком.

Текстовые значения будут экранированы, другие значения останутся без изменений. Содержимое всего массива определяется по его первому элементу, т.е. считается что в нем однотипные данные.

Для экранирования строк используется [PDO::quote()](@see http://php.net/manual/en/pdo.quote.php). У него тоже есть ограничения, но это лучше, чем ничего.

**#5. Использование итератора**

```PHP
$iter = (new BlogModel)
    ->query('SELECT * FROM blog WHERE show_rec = 1 LIMIT 100')
    ->getIterator();

foreach ($iter as $row) {
    echo $row['date'] . ': ' . $row['title'];
    ...
}
```

Итераторы удобны тем, что в память выгружаются не все данные, а только один элемент массива. Применительно к запросу в базу: не все записи, а только одна. Экономия памяти в случае большого результата запроса. При этом, реализуя интерфейс \Iterator, получаем возможность обхода всех записей через цикл.

**#6. Запросы с LIKE и подстановками**

> Работая с подготовленными выражениями, следует понимать, что плейсхолдер может заменять только строку или число. Ни ключевое слово, ни идентификатор, ни часть строки или набор строк через плейсхолдер подставить нельзя. Поэтому для LIKE надо сначала подготовить строку поиска целиком, а потом ее подставлять в запрос (c) <http://phpfaq.ru/pdo#like>

Максимум, что берет на себя PDO при подстановке - это экранирование кавычек. Т.о. запрос может быть таким:

```php
// Найти всех юзеров, начинающихся с Мак'Кормик

$sql = 'SELECT * FROM users WHERE name LIKE :name';
$params = [':name' => "Mac'Cormick%"];
$names = (new UserModel)->query($sql, $params)->fetchColumn('name');
dd($names);

// Результат

array(
    "Mac'Cormick Genry",
    "Mac'Cormick Jhon",
    "Mac'Cormick Maggy",
)
```

Другой момент: символы `%` и `_` являются подстановочными знаками (wildcards) в LIKE-выражениях. И тут уже только кодер может знать, когда экранировать такие символы, а когда использовать, как элементы маски поиска. Вспомогательный метод `DbModel::escapeLike()` можно использовать для экранирования всех вхождений таких символов в строке. Пример использования:

```php
// Найти все активы, израсходованные на 50%

$sql = 'SELECT * FROM activities WHERE rest LIKE :half';
$params = [':half' => '%' . ActivitiesModel::escapeLike('50%') . '%'];
$activities = (new ActivitiesModel)->query($sql, $params)->fetchAll();
dd($activities);

// Результат

array(
    '50% of whater',
    'gold - 50%',
    'oxigen - 50%, carbon - 35%'
);
```

## Обработка ошибок

Ошибки запросов и подключения к БД пишутся в лог (см. док *"Логер"*). Если определено логирование в базу, тогда ошибки запросов пишутся в нее, ошибки подключения - в любом случае в файлы. Если в атрибутах подключения запрещены исключения, тогда логирования не будет. Про настройку тут [PDO::ATTR_ERRMODE](http://php.net/manual/ru/pdo.setattribute.php).

При возникновении ошибок в клиентский код будет проброшено исключение `kira\exceptions\DbException`.
