# DB

Движок точно работает с MySQL-сервером. Настройки в конфиге именно для него. Не гарантирую полную поддержку других СУБД.

ORM нет никакой. Пока нет :)

Конструктора запросов тоже нет. Они мне не нравятся. Я считаю неправильным такой подход: писать sql-запрос конструктором (иногда значительно больше, чем прямым текстом), но при этом не задумываться, какой реальный sql-запрос за ним стоИт и сколько времени он стОит. Максимальную скорость и эффективность можно получить, только описывая запросы на языке СУБД. И читаются они легче констуктора (ну если про MySQL говорить :))

Минус отсутствия ORM и/или конструктора - сменишь БД-сервер, например MySQL на PostgreSQL, придется переписывать весь слой моделей. Но! Сколько вы знаете случаев смены БД-сервера под рабочим сайтом? Вот и я о том же :)

В движке реализован класс `\kira\Db\DbModel`, в котором описана работа с базой данных и несколько методов общего применения. DB-модели приложения должны наследовать ее. При этом модель-наследник может не отражать в себе какую-то конкретную таблицу базы данных, т.е. **модель !== таблица**. Модель объединяет SQL запросы, связанные *логической областью использования*.

Возможно это кому-то покажется слишком "низкоуровневым" кодингом запросов, но код в понимании проще, имхо.

По вопросам PDO очень полезная [статья](http://phpfaq.ru/pdo).

## Конфигурация

Конфигураций БД может быть несколько, описываются в настройках приложения. По умолчанию ключ *"db"*, другие конфиги можно описать произвольными ключами и указывать их в конструкторе `DbModel`. Рекомендую придерживаться соглашения: ключи конфигов базы данных имеют префикс *"db_"*.

Шаблон конфигурации БД:

```php
 'db' => [
    'dsn'            => string,
    'user'           => string,
    'password'       => string,
    'options'        => array | []
    'mysql_timezone' => string | '+00:00'
 ]
```

Обычно конфигурация c конфиденциальной информацией описывается в отдельном файле и не контролируется СКВ. По умолчанию мастер приложения (см. док *"Организация файлов > Мастер создания приложения"*) создает конфиг в `env.php`.

Почти все параметры соответствуют параметрам конструктора класса [PDO](http://php.net/manual/en/pdo.construct.php).

Про *"options"* можно почитать в [PDO::setAttribute()](http://php.net/manual/ru/pdo.setattribute.php).

*Прим.: несмотря на то, что **ключи** в PDO Options представляют собой **числовые константы**, массив настроек, описанный в `env.php`, успешно сливается c главным конфигом. Обеспечено особым методом движка, и об этом заботиться не нужно.*

#### Часовой пояс в MySQL-сессии

Полезные ссылки
waredom.ru: [Время в MySQL](http://waredom.ru/36#mysql)
stackoverflow.com: [How do I get the current time zone of MySQL?](http://stackoverflow.com/a/2934271/5497749)
stackoverflow.com: [Should MySQL have its timezone set to UTC?](http://stackoverflow.com/a/19075291/5497749)

Коротко, в чем смысл:

- если значение даты/времени задается функцией `mysql::now()` или ее аналогами, то его вычисление времени зависит от пояса сервера. При этом не важен тип поля, просто при вычислении значения для него учитывается часовой пояс сервера.
- при записи даты/времени в поле типа DATE, DATETIME часовой пояс в значении ни как не сохраняется. Это постоянное значение, результат чтения не зависит от текущего пояса сервера.
- запись в поле TIMESTAMP при сохранении переводится внутри MySQL в UTC, но при чтении значение опять переводится в *текущий пояс* MySQL-сервера. И не факт, что пояс при записи и чтении будет один и тот же.

Следовательно, при работе с полями типа TIMESTAMP нужно помнить про перевод из/в текущий часовой пояс севера. Если при этом пояс отличается от GMT 00:00, то на результате может отразиться, например, летнее время в заданном часовом поясе на момент записи.. или чтения. Чтобы избежать путаницы в сохраненном значении, можно сразу выставить часовой пояс MySQL-сервера в ноль, а получаемые TIMESTAMP-значения переводить в нужный пояс по своему усмотрению.

Конечно если вы не согласны, тогда укажите в настройке приложения `mysql_timezone` желаемый часовой пояс. Формат значения должен быть понятен MySQL-серверу.

Если у вас есть доступ к MySQL-серверу, лучше сразу задать на нем требуемый часовой пояс. Потому что через PHP это будет дополнительный запрос при каждом соединении с базой:

```PHP
$dbh->prepare('SET time_zone = ?')->execute($conf['mysql_timezone']);
```

Только если в настройке `mysql_timezone` **пустая строка**, запрос не будет отправлен. Если настройки нет вообще, по умолчанию ее значение будет '+00:00' (GMT).

*Прим: префикс "mysql_" означает, что в случае, когда часовой пояс задается названием, он должен быть из списка поясов известных MySQL, таблица `mysql`.`time_zone`. В PHP названия поясов могут быть другими.*

#### Как можно задать пояс для MySQL в соответствии со временем скриптов?

Часовой пояс для php-скриптов может быть задан в *php.ini (date.timezone)* или через вызов в скипте:

```PHP
date_default_timezone_set('Asia/Novosibirsk');
```

Числовое значение пояса (даже с учетом летнего времени) можно получить через `php::date('P')`. Т.o. пишем в настройке базы:

```
db => [
    'mysql_timezone' => date('P'),
]
```

Теперь сессия с сервером MySQL будет работать в часовом поясе скриптов сайта.

## Использование

Работа с MySQL (а по умолчанию работаем именно с ней) идет через PDO. У движка есть обертки для подключения, подготовки и отправки запросов на сервер с последующим разбором ответа.

Подключение к БД осуществляется в конструкторе модели. Для переключения объекта модели на другую базу есть метод `DbModel::switchConnection()`.

#### Примеры работы с классом DbModel и его наследниками

**#1. Простой запрос**

```PHP
$ids = (new UserModel)
    ->query('SELECT id FROM Users ORDER BY id')
    ->fetchAll(\PDO::FETCH_NUM);
```

**#2. Запрос с подстановками**

```PHP
$uid = Request::getAsInt('uid');
$sql = 'SELECT login, mail, `status`, salt FROM Users WHERE id = ?';
$row = $this->query($sql, [$uid])->fetch();
```

*Прим.: поддерживаеются так же именованные подстановки. В таком случае передаем ассоциативный массив. См. так же полезный метод `DbModel::valueSet()`*

**#3. Служебные манипуляции, без выделения модели-наследника**

```PHP
if ((new DbModel)->query('TRUNCATE kira_log')->effect() > 0) {
    echo 'Таблица очищена';
}
```

**#4. Подготовка IN-условия**

```PHP
$sql = 'SELECT * FROM users WHERE id IN(:ids) AND status IN (:statuses) AND role = :role';
$params = [
    ':ids'      => [1, 4, 56],
    ':statuses' => ['active', 'new'],
    ':role'     => 'user'
];
$rows = (new UserModel)
    ->prepareIN($sql, $params)
    ->query($sql, $params)
    ->fetchAll();
```

Любые значения-массивы из списка параметров рассматриваются, как подстановки в IN-условие. Метод `prepareIN()` нацелен именно на значения-массивы.

Все IN-подстановки будут подготовлены за один вызов метода `DBModel::prepareIN()`. Подстановка возможна только для именованного плейсходлера, т.к. заменить какой-то из кучи безымянных плейсхолдеров (помеченных знаком вопроса) - нетривиальная задача. Проще тогда написать свой парсер целиком.

Текстовые значения будут экранированы, другие значения останутся без изменений. Содержимое всего массива определяется по его первому элементу, т.е. считается что в нем однотипные данные.

Для экранирования строк используется [PDO::quote()](@see http://php.net/manual/en/pdo.quote.php). У него тоже есть ограничения, но это лучше, чем ничего.

**#5. Использование итератора**

```PHP
$iter = (new BlogModel)
    ->query('SELECT * FROM blog WHERE show_rec = 1 LIMIT 100')
    ->getIterator();

foreach ($iter as $row) {
    echo $row['date'] . ': ' . $row['title'];
    ...
}
```

Итераторы удобны тем, что в память выгружаются не все данные, а только один элемент массива. Применительно к запросу в базу: не все записи, а только одна. Экономия памяти в случае большого результата запроса. При этом, реализуя интерфейс \Iterator, получаем возможность обхода всех записей через цикл.

**#6. Запросы с LIKE и подстановками**

> Работая с подготовленными выражениями, следует понимать, что плейсхолдер может заменять только строку или число. Ни ключевое слово, ни идентификатор, ни часть строки или набор строк через плейсхолдер подставить нельзя. Поэтому для LIKE надо сначала подготовить строку поиска целиком, а потом ее подставлять в запрос (c) <http://phpfaq.ru/pdo#like>

Максимум, что берет на себя PDO при подстановке - это экранирование кавычек. Т.о. запрос может быть таким:

```php
// Найти всех юзеров, начинающихся с Мак'Кормик

$sql = 'SELECT * FROM users WHERE name LIKE :name';
$params = [':name' => "Mac'Cormick%"];
$names = (new UserModel)->query($sql, $params)->fetchColumn('name');
dd($names);

// Результат

array(
    "Mac'Cormick Genry",
    "Mac'Cormick Jhon",
    "Mac'Cormick Maggy",
)
```

Другой момент: символы `%` и `_` являются подстановочными знаками (wildcards) в LIKE-выражениях. И тут уже только кодер может знать, когда экранировать такие символы, а когда использовать, как элементы маски поиска. Вспомогательный метод `DbModel::escapeLike()` можно использовать для экранирования всех вхождений таких символов в строке. Пример использования:

```php
// Найти все активы, израсходованные на 50%

$sql = 'SELECT * FROM activities WHERE rest LIKE :half';
$params = [':half' => '%' . ActivitiesModel::escapeLike('50%') . '%'];
$activities = (new ActivitiesModel)->query($sql, $params)->fetchAll();
dd($activities);

// Результат

array(
    '50% of whater',
    'gold - 50%',
    'oxigen - 50%, carbon - 35%'
);
```

**#7. Запрос с пагинацией**

Допустим, у нас есть большой список данных, нам нужно получить его срез - данные для одной страницы. При этом нужна инфа об общем количестве записей, соответствущих запросу. Для этих нужд служит метод `DbModel::paginate()`. Он дополняет переданный в него запрос инструкцией `SQL_CALC_FOUND_ROWS` для последующего вызова спец. запроса [FOUND_ROWS()](https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_found-rows). В итоге метод вернет все необходимые данные. От вас требуется передать ему: сам текст запроса **без выражения LIMIT**, параметры подстановки, номер страницы и количество записей на страницу.

```php
$sql =
    'SELECT *
    FROM blog
    WHERE `status`="public"
        AND title LIKE :title
    ORDER BY created_at';

$params = ['title' => 'Тру-ля-%'];

$page = max(1, Request::getAsInt('page', 1));

$result = (new BlogModel)->paginate($sql, $params, $page, $perPage = 10);
```

Результат - это DTO-объект класса `\kira\db\specifications\PaginateSpec`. Он содержит итератор с найденными записями и два счетчика: все записи и количество записей для текущей страницы. Последний счетчик не особо и нужен, он для удобства.

Про спецификации, к которым относится `PaginateSpec`, см. отдельный док *"Спецификации"*, про DTO тоже есть отдельный док - *"DTO"*.

**Важно**: поскольку метод универсальный, он имеет некоторый overhead - вызывает `Db::prepareIN()` для подготовки IN-условий, даже если их нет в запросе. Это не ломает запрос и ни к чему не обязывает клиентский код. Просто выполняется вся возможная подготовка запроса.

## Обработка ошибок

Ошибки запросов и подключения к БД пишутся в лог (см. док *"Логер"*). Если определено логирование в базу, тогда ошибки запросов пишутся в нее, ошибки подключения - в любом случае в файлы. Если в атрибутах подключения к БД запрещены исключения, тогда логирования не будет; про атрибуты подключения тут [PDO::ATTR_ERRMODE](http://php.net/manual/ru/pdo.setattribute.php).

При возникновении ошибок в клиентский код будет проброшено исключение `kira\exceptions\DbException`. Его параметр `$code` (второй параметр в конструкторе `\Throwable`) указывает на причину исключения:

```
// kira\exceptions\DbException
QUERY = 1
CONNECT = 2
LOGIC = 3
```

По большей части это сделано для движка, чтобы корректно лог писать. Значения констант могут измениться в дальнейшем.

Не логируются ошибки логики использования (`DbException::LOGIC`), т.к. предполагается неверное использование фунционала программистом, исключение возникнет на этапе разработки.

Инициатива движка логировать сбои БД важна, т.к. такие вещи трудно отслеживать в клиентском коде, а серьезность их достаточно высокая.
