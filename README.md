# Kira Engine v1.0
*Since 20/09/2015*

(PHP 5 >= 5.4.0)

 **Черновик**.

Мое представление об удобном web-движке.

Причиной появления сего творения стала тестовая задача одного из работодателей. Требовалось создать функционал по регистрации юзера: форма регистрации, фронт/бэкенд валидация и т.д.

Название движку взял по имени кошки, которую очень любил. Это не значит, что я так же тащусь от этого проекта :), просто на ум пришло, когда нужно было назвать. Кстати, коша была строптивая, независимая и злая. Посмотрим, что покажет двиг имени нее.

На данный момент ядро не закончено и в самом репозитории лежит выполненная задача теста. Если хватит времени и стремления, доведу проект до ума.

## Общее описание

Придерживаюсь парадигмы MVC + сервисы. Тонкие контроллеры, бизнес-логика в сервисах, запросы в базу и валидаторы форм - в моделях. Шаблонизатора нет, есть поддержка представлений типа "макет" и "вставки" (взял идею в Yii). Но для простоты *представления* называю *шаблонами*.

Стараюсь не плодить классы только потому, что того требует ООП или какой-то шаблон проектирования. Применяю "бритву Оккама" кроме прочих соображений.

Реализована поддержка локализации (i18n). Можно перевести flash-сообщения пользователю, js-сообщения, даже отдельные страницы сайта. Правда для этого придется дублировать шаблоны.

Нет логера (пока). Но можно пробрасывать исключения по любому поводу. Все ловит core/App.php Он же проверяет константу DEBUG и решает, что выдавать на полученное исключение. Поэтому в клиентском коде условие с DEBUG в таких случаях не нужно.

## DB

ORM нет никакой. Мне не нравятся конструкторы запросов и те "шланги", кто готов писать в разы больше кода конструктором, но не задумываться, какой sql-запрос за ним стоИт и сколько времени он стОит. В моей реализации есть суперкласс DbModel, в котором реализована работа с базой данных и несколько методов общего применения. Все остальные запросы можно и нужно писать руками, в моделях-наследниках. При этом модель может не отражать в себе какую-то конкретную таблицу БД. Возможно это кому-то покажется слишком "низкоуровневым" кодингом запросов, зато так работает быстрее и в понимании проще.

Минус отсутствия ORM - сменишь БД-сервер, например MySQL на Oracle или MSSQL, придется переписывать весь слой моделей. НО! Сколько вы знаете случаев смены БД-сервера под рабочим сайтом? Вот и я о том же :)

Разумеется, работа с MySQL (а по умолчанию работаем именно с ней) идет через PDO. У движка есть обертки для подключения, подготовки и отправки ваших запросов на MySQL сервер с последующим разбором ответа. И все это сосредоточено всего в двух методах:

*DbModel::connect()*
    подключение к базе
    Возвращает PDO объект подключения к БД

*DbModel::query(array $ops)*
```PHP
    $ops = [
        'q' => null,              //текст запроса
        'p' => array(),           //параметры для вставки в запрос
        'fs' => PDO::FETCH_ASSOC, //разбор ответа (в случае SELECT-запроса)
        'one' => false,           //ожидаем один ряд или все (вложенность массива меньше)
    ];
```
Возвращает ряд/ряды при SELECT или количество затронутых рядов при других CrUD-запросах.

Все sql-запросы через query(). В методе вызваются PDO-функции подготовки, выполнения и разбора ответа. Практика показывает, что на такую последовательность приходится 99% всех запросов в базу. Если вам нужно особенное поведение - получите соединение через connect() и описывайте остальное в своей модели.